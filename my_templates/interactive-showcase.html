<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Showcase | Nick Holmes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/style.css">
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet">
  
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  
  <!-- Three.js for 3D Minecraft -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <style>
    :root {
      --primary-color: #00d9ff;
      --secondary-color: #a855f7;
      --accent-color: #f59e0b;
      --bg-dark: #0a0a0f;
      --bg-card: #1a1a2e;
      --text-primary: #ffffff;
      --text-secondary: #a0aec0;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-card) 100%);
      color: var(--text-primary);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow-x: hidden;
      position: relative;
    }

    /* Animated background */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 50%, rgba(0, 217, 255, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(168, 85, 247, 0.05) 0%, transparent 50%);
      animation: gradientShift 15s ease infinite;
      pointer-events: none;
      z-index: 0;
    }

    @keyframes gradientShift {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.1); }
    }

    /* Code Matrix Rain Effect */
    #matrix-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.15;
      pointer-events: none;
    }

    header, section {
      position: relative;
      z-index: 1;
    }

    .hero {
      text-align: center;
      padding: 100px 20px 60px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .hero h1 {
      font-size: clamp(3rem, 8vw, 5rem);
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color), var(--accent-color));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: 900;
      margin-bottom: 20px;
      animation: fadeInUp 0.8s ease;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .hero p {
      font-size: 1.4rem;
      color: var(--text-secondary);
      max-width: 800px;
      margin: 0 auto 40px;
      line-height: 1.7;
    }

    /* Category Navigation */
    .category-nav {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
      max-width: 1200px;
      margin: 40px auto;
      padding: 0 20px;
    }

    .category-btn {
      padding: 12px 24px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      color: var(--text-secondary);
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .category-btn:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(0, 217, 255, 0.3);
      transform: translateY(-2px);
    }

    .category-btn.active {
      background: linear-gradient(135deg, rgba(0, 217, 255, 0.2), rgba(168, 85, 247, 0.2));
      border-color: var(--primary-color);
      color: var(--primary-color);
    }

    .category-btn i {
      font-size: 1.1rem;
    }

    .showcase-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 30px;
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 20px 60px;
    }

    .demo-card {
      background: rgba(26, 26, 46, 0.6);
      backdrop-filter: blur(10px);
      border: 2px solid transparent;
      border-radius: 20px;
      padding: 30px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      background-clip: padding-box;
    }

    .demo-card::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(135deg, #00d9ff, #a855f7, #f59e0b);
      border-radius: 20px;
      z-index: -1;
      opacity: 0.4;
      transition: opacity 0.3s ease;
    }

    .demo-card:hover::after {
      opacity: 1;
    }

    .demo-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #00d9ff, #a855f7, #f59e0b);
      background-size: 200% 100%;
      animation: shimmer 3s linear infinite;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .demo-card:hover::before {
      opacity: 1;
    }

    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    .demo-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 20px 60px rgba(0, 217, 255, 0.3), 0 0 40px rgba(168, 85, 247, 0.2);
      background: rgba(26, 26, 46, 0.8);
    }

    .expand-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
    }

    .demo-card:hover .expand-btn {
      opacity: 1;
    }

    .expand-btn:hover {
      transform: scale(1.1) rotate(15deg);
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.5);
    }

    .fullscreen-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 30, 0.98);
      z-index: 10000;
      overflow-y: auto;
      animation: fadeIn 0.3s ease;
    }

    .fullscreen-overlay.active {
      display: block;
    }

    .fullscreen-content {
      max-width: 1400px;
      margin: 0 auto;
      padding: 40px 20px;
      animation: slideInUp 0.4s ease;
    }

    .fullscreen-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 2px solid rgba(0, 217, 255, 0.3);
    }

    .fullscreen-title {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .close-fullscreen-btn {
      padding: 12px 30px;
      border: 2px solid var(--primary-color);
      border-radius: 10px;
      background: rgba(0, 217, 255, 0.1);
      color: var(--primary-color);
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .close-fullscreen-btn:hover {
      background: var(--primary-color);
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 217, 255, 0.4);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideInUp {
      from { transform: translateY(30px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    /* Modern Category Group Styling */
    .demo-group {
      grid-column: 1 / -1;
      margin: 40px 0 30px 0;
    }

    .category-header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 25px;
      padding: 25px 30px;
      background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(123, 96, 238, 0.1));
      border-radius: 20px;
      border-left: 5px solid var(--primary-color);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .category-header:hover {
      transform: translateY(-3px);
      box-shadow: 0 15px 50px rgba(0, 217, 255, 0.3);
    }

    .category-icon {
      font-size: 3rem;
      filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.5));
      animation: bounce 2s ease-in-out infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .category-title {
      font-size: 2rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: 0.5px;
      text-shadow: 0 0 30px rgba(0, 217, 255, 0.3);
    }

    .category-count {
      margin-left: auto;
      padding: 10px 25px;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      border-radius: 25px;
      color: white;
      font-weight: 700;
      font-size: 1.1rem;
      box-shadow: 0 5px 20px rgba(0, 217, 255, 0.4);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .category-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 30px;
      padding: 0 10px;
    }

    /* Enhanced demo card styling in groups */
    .demo-group .demo-card {
      position: relative;
      overflow: hidden;
    }

    /* Smooth scroll behavior */
    html {
      scroll-behavior: smooth;
    }

    /* Back to top button */
    .back-to-top {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 55px;
      height: 55px;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 8px 25px rgba(0, 217, 255, 0.4);
    }

    .back-to-top.visible {
      opacity: 1;
      visibility: visible;
    }

    .back-to-top:hover {
      transform: translateY(-5px) scale(1.1);
      box-shadow: 0 12px 35px rgba(0, 217, 255, 0.6);
    }

    /* Loading animation for demos */
    @keyframes cardFadeIn {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .demo-card {
      animation: cardFadeIn 0.6s ease forwards;
    }

    .demo-card:nth-child(1) { animation-delay: 0.1s; }
    .demo-card:nth-child(2) { animation-delay: 0.2s; }
    .demo-card:nth-child(3) { animation-delay: 0.3s; }
    .demo-card:nth-child(4) { animation-delay: 0.4s; }
    .demo-card:nth-child(5) { animation-delay: 0.5s; }
    .demo-card:nth-child(6) { animation-delay: 0.6s; }

    /* Search bar styling */
    .search-container {
      max-width: 600px;
      margin: 30px auto;
      position: relative;
    }

    .search-input {
      width: 100%;
      padding: 15px 50px 15px 20px;
      border: 2px solid rgba(0, 217, 255, 0.3);
      border-radius: 50px;
      background: rgba(20, 20, 40, 0.6);
      color: var(--text-color);
      font-size: 1rem;
      transition: all 0.3s ease;
      outline: none;
    }

    .search-input:focus {
      border-color: var(--primary-color);
      box-shadow: 0 0 20px rgba(0, 217, 255, 0.3);
      background: rgba(20, 20, 40, 0.9);
    }

    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    .search-icon {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--primary-color);
      font-size: 1.2rem;
      pointer-events: none;
    }

    .clear-search {
      position: absolute;
      right: 55px;
      top: 50%;
      transform: translateY(-50%);
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      font-size: 1.2rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.3s ease;
      padding: 5px;
    }

    .clear-search.visible {
      opacity: 1;
    }

    .clear-search:hover {
      color: var(--primary-color);
    }

    .demo-header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
    }

    .demo-icon {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
    }

    .demo-card h3 {
      font-size: 1.5rem;
      color: var(--text-primary);
      font-weight: 700;
    }

    .demo-card p {
      color: var(--text-secondary);
      line-height: 1.7;
      margin-bottom: 20px;
    }

    .demo-content {
      margin-top: 20px;
    }

    /* Typing Speed Test */
    .typing-area {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      padding: 20px;
      margin: 15px 0;
      font-family: 'Fira Code', monospace;
      font-size: 1.1rem;
      line-height: 1.8;
      color: var(--text-secondary);
    }

    .typing-input {
      width: 100%;
      padding: 15px;
      border: 2px solid rgba(0, 217, 255, 0.3);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      font-family: 'Fira Code', monospace;
      font-size: 1.1rem;
      margin: 10px 0;
      transition: all 0.3s ease;
    }

    .typing-input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 4px rgba(0, 217, 255, 0.1);
    }

    .typing-stats {
      display: flex;
      justify-content: space-around;
      margin-top: 15px;
      flex-wrap: wrap;
      gap: 15px;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--primary-color);
    }

    .stat-label {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    /* Color Picker */
    .color-display {
      width: 100%;
      height: 150px;
      border-radius: 15px;
      margin: 15px 0;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }

    .color-input-group {
      display: flex;
      gap: 15px;
      margin: 15px 0;
      flex-wrap: wrap;
    }

    .color-input-wrapper {
      flex: 1;
      min-width: 120px;
    }

    .color-input-wrapper label {
      display: block;
      margin-bottom: 8px;
      color: var(--text-secondary);
      font-weight: 600;
      font-size: 0.9rem;
    }

    .color-input-wrapper input {
      width: 100%;
      padding: 10px;
      border: 2px solid rgba(0, 217, 255, 0.3);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      font-size: 1rem;
    }

    /* Calculator */
    .calculator {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 15px;
      padding: 20px;
      max-width: 300px;
      margin: 20px auto;
    }

    .calc-display {
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(0, 217, 255, 0.3);
      border-radius: 10px;
      padding: 20px;
      text-align: right;
      font-size: 2rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 15px;
      min-height: 60px;
      word-wrap: break-word;
    }

    .calc-buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .calc-btn {
      padding: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      font-size: 1.2rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .calc-btn:hover {
      background: rgba(0, 217, 255, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 217, 255, 0.3);
    }

    .calc-btn:active {
      transform: translateY(0);
    }

    .calc-btn.operator {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
    }

    .calc-btn.equals {
      background: linear-gradient(135deg, var(--accent-color), #e85d04);
      grid-column: span 2;
    }

    /* Password Generator */
    .password-display {
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(0, 217, 255, 0.3);
      border-radius: 10px;
      padding: 20px;
      font-family: 'Fira Code', monospace;
      font-size: 1.3rem;
      color: var(--primary-color);
      margin: 15px 0;
      word-break: break-all;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .password-options {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin: 15px 0;
    }

    .password-option {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .password-option input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .password-option label {
      color: var(--text-secondary);
      cursor: pointer;
      user-select: none;
    }

    .slider-group {
      margin: 15px 0;
    }

    .slider-group label {
      display: block;
      margin-bottom: 10px;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .slider-group input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      appearance: none;
    }

    .slider-group input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      cursor: pointer;
    }

    .btn {
      width: 100%;
      padding: 15px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 10px;
    }

    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 217, 255, 0.5);
    }

    .btn:active {
      transform: translateY(-1px);
    }

    /* Code Editor */
    .code-editor {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
      overflow: hidden;
      margin: 15px 0;
    }

    .editor-header {
      background: rgba(255, 255, 255, 0.05);
      padding: 10px 15px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .editor-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .editor-dot.red { background: #ff5f56; }
    .editor-dot.yellow { background: #ffbd2e; }
    .editor-dot.green { background: #27c93f; }

    .editor-content {
      padding: 20px;
    }

    .editor-content textarea {
      width: 100%;
      min-height: 200px;
      background: transparent;
      border: none;
      color: var(--text-primary);
      font-family: 'Fira Code', monospace;
      font-size: 1rem;
      line-height: 1.6;
      resize: vertical;
      outline: none;
    }

    .editor-output {
      background: rgba(0, 217, 255, 0.1);
      border-top: 1px solid rgba(0, 217, 255, 0.3);
      padding: 15px 20px;
      font-family: 'Fira Code', monospace;
      color: var(--text-secondary);
      max-height: 200px;
      overflow-y: auto;
    }

    /* Todo List */
    .todo-input {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .todo-input input {
      flex: 1;
      padding: 12px 15px;
      border: 2px solid rgba(0, 217, 255, 0.3);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-primary);
      font-size: 1rem;
    }

    .todo-list {
      list-style: none;
      padding: 0;
    }

    .todo-item {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 15px;
      transition: all 0.3s ease;
    }

    .todo-item:hover {
      background: rgba(0, 217, 255, 0.05);
      border-color: var(--primary-color);
    }

    .todo-item.completed {
      opacity: 0.6;
      text-decoration: line-through;
    }

    .todo-item input[type="checkbox"] {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .todo-item span {
      flex: 1;
      color: var(--text-primary);
    }

    .todo-item button {
      background: rgba(255, 59, 48, 0.2);
      border: 1px solid rgba(255, 59, 48, 0.5);
      color: #ff3b30;
      padding: 5px 15px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .todo-item button:hover {
      background: rgba(255, 59, 48, 0.4);
    }

    @media (max-width: 768px) {
      .showcase-grid {
        grid-template-columns: 1fr;
      }

      .hero h1 {
        font-size: 2.5rem;
      }
      
      /* RPG responsive layout */
      #inventoryGrid {
        grid-template-columns: repeat(4, 1fr) !important;
      }
      
      .inv-slot {
        width: 50px !important;
        height: 50px !important;
        font-size: 1.5rem !important;
      }
      
      .equip-slot {
        padding: 10px !important;
      }
    }
    
    @media (max-width: 1024px) {
      /* Make RPG stack on smaller screens */
      [style*="grid-template-columns: 300px 1fr"] {
        grid-template-columns: 1fr !important;
      }
    }
  </style>
</head>
<body data-page="showcase">
  <canvas id="matrix-canvas"></canvas>

  <header>
    <nav>
      <h1></h1>
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="projects.html">Projects</a></li>
        <li><a href="contact.html">Contact</a></li>
        <li><a href="certificates.html">Certificates</a></li>
        <li><a href="services-faq.html">Services FAQ</a></li>
        <li><a href="interactive-showcase.html" class="active">Showcase</a></li>
        <li><a href="blog.html">Blog</a></li>
        <li><a href="performance-metrics.html">Performance</a></li>
      </ul>
    </nav>
  </header>

  <section class="hero">
    <h1>Interactive Showcase</h1>
    <p>Experience my technical skills through these interactive demos. Built with vanilla JavaScript to demonstrate coding proficiency.</p>
    <div style="margin-top: 20px; padding: 15px 30px; background: linear-gradient(135deg, rgba(0, 217, 255, 0.1), rgba(123, 96, 238, 0.1)); border-radius: 15px; display: inline-block; border: 2px solid rgba(0, 217, 255, 0.3);">
      <i class="fas fa-rocket" style="color: var(--primary-color); margin-right: 10px;"></i>
      <span id="demoCounter" style="font-weight: 700; font-size: 1.2rem; color: var(--primary-color);">Loading demos...</span>
    </div>
  </section>

  <!-- Category Navigation -->
  <div class="category-nav">
    <button class="category-btn active" data-category="all" onclick="filterCategory('all')">
      <i class="fas fa-th"></i> All
    </button>
    <button class="category-btn" data-category="impressive" onclick="filterCategory('impressive')" style="background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); font-weight: bold;">
      <i class="fas fa-star"></i> ‚≠ê Impressive
    </button>
    <button class="category-btn" data-category="games" onclick="filterCategory('games')">
      <i class="fas fa-gamepad"></i> Games
    </button>
    <button class="category-btn" data-category="utilities" onclick="filterCategory('utilities')">
      <i class="fas fa-tools"></i> Utilities
    </button>
    <button class="category-btn" data-category="creative" onclick="filterCategory('creative')">
      <i class="fas fa-paint-brush"></i> Creative
    </button>
    <button class="category-btn" data-category="data-viz" onclick="filterCategory('data-viz')">
      <i class="fas fa-chart-line"></i> Data Viz
    </button>
    <button class="category-btn" data-category="ai-ml" onclick="filterCategory('ai-ml')">
      <i class="fas fa-brain"></i> AI/ML
    </button>
    <button class="category-btn" data-category="advanced" onclick="filterCategory('advanced')" style="border: 2px solid var(--accent-color);">
      <i class="fas fa-rocket"></i> Advanced
    </button>
  </div>

  <!-- Search Bar -->
  <div class="search-container">
    <input 
      type="text" 
      id="demoSearch" 
      class="search-input" 
      placeholder="Search demos... (e.g., 'game', 'calculator', 'AI')"
      autocomplete="off"
    />
    <button class="clear-search" id="clearSearch" title="Clear search">
      <i class="fas fa-times"></i>
    </button>
    <i class="fas fa-search search-icon"></i>
  </div>

  <div class="showcase-grid">
    <!-- Typing Speed Test -->
    <div class="demo-card" data-category="utilities">
      <div class="demo-header">
        <div class="demo-icon"><i class="fas fa-keyboard"></i></div>
        <h3>Typing Speed Test</h3>
      </div>
      <p>Test your typing speed and accuracy!</p>
      
      <div class="demo-content">
        <div class="typing-area" id="typingText">The quick brown fox jumps over the lazy dog. Programming requires practice and patience.</div>
        <input type="text" class="typing-input" id="typingInput" placeholder="Start typing here...">
        
        <div class="typing-stats">
          <div class="stat">
            <div class="stat-value" id="wpm">0</div>
            <div class="stat-label">WPM</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="accuracy">100%</div>
            <div class="stat-label">Accuracy</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="time">0s</div>
            <div class="stat-label">Time</div>
          </div>
        </div>
        
        <button class="btn" onclick="resetTypingTest()">Reset</button>
      </div>
    </div>

    <!-- Color Mixer -->
    <div class="demo-card" data-category="utilities creative">
      <div class="demo-header">
        <div class="demo-icon"><i class="fas fa-palette"></i></div>
        <h3>Color Mixer</h3>
      </div>
      <p>Create and visualize custom colors!</p>
      
      <div class="demo-content">
        <div class="color-display" id="colorDisplay"></div>
        
        <div class="color-input-group">
          <div class="color-input-wrapper">
            <label>Red (0-255)</label>
            <input type="number" id="redInput" min="0" max="255" value="0" onchange="updateColor()">
          </div>
          <div class="color-input-wrapper">
            <label>Green (0-255)</label>
            <input type="number" id="greenInput" min="0" max="255" value="217" onchange="updateColor()">
          </div>
          <div class="color-input-wrapper">
            <label>Blue (0-255)</label>
            <input type="number" id="blueInput" min="0" max="255" value="255" onchange="updateColor()">
          </div>
        </div>
        
        <div style="text-align: center; color: var(--text-secondary); margin-top: 10px;">
          <strong>HEX:</strong> <span id="hexOutput">#00d9ff</span>
        </div>
        
        <button class="btn" onclick="copyColor()">Copy HEX Code</button>
      </div>
    </div>

    <!-- Calculator -->
    <div class="demo-card" data-category="utilities">
      <div class="demo-header">
        <div class="demo-icon"><i class="fas fa-calculator"></i></div>
        <h3>Calculator</h3>
      </div>
      <p>A functional calculator built with JavaScript!</p>
      
      <div class="demo-content">
        <div class="calculator">
          <div class="calc-display" id="calcDisplay">0</div>
          <div class="calc-buttons">
            <button class="calc-btn" onclick="appendToCalc('7')">7</button>
            <button class="calc-btn" onclick="appendToCalc('8')">8</button>
            <button class="calc-btn" onclick="appendToCalc('9')">9</button>
            <button class="calc-btn operator" onclick="appendToCalc('/')">/</button>
            
            <button class="calc-btn" onclick="appendToCalc('4')">4</button>
            <button class="calc-btn" onclick="appendToCalc('5')">5</button>
            <button class="calc-btn" onclick="appendToCalc('6')">6</button>
            <button class="calc-btn operator" onclick="appendToCalc('*')">√ó</button>
            
            <button class="calc-btn" onclick="appendToCalc('1')">1</button>
            <button class="calc-btn" onclick="appendToCalc('2')">2</button>
            <button class="calc-btn" onclick="appendToCalc('3')">3</button>
            <button class="calc-btn operator" onclick="appendToCalc('-')">-</button>
            
            <button class="calc-btn" onclick="appendToCalc('0')">0</button>
            <button class="calc-btn" onclick="appendToCalc('.')">.</button>
            <button class="calc-btn operator" onclick="clearCalc()">C</button>
            <button class="calc-btn operator" onclick="appendToCalc('+')">+</button>
            
            <button class="calc-btn equals" onclick="calculateResult()">=</button>
            <button class="calc-btn operator" onclick="backspace()">‚Üê</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Password Generator -->
    <div class="demo-card" data-category="utilities">
      <div class="demo-header">
        <div class="demo-icon"><i class="fas fa-lock"></i></div>
        <h3>Password Generator</h3>
      </div>
      <p>Generate secure passwords with custom options!</p>
      
      <div class="demo-content">
        <div class="password-display" id="passwordDisplay">Click generate to create a password</div>
        
        <div class="slider-group">
          <label>Length: <span id="lengthValue">16</span></label>
          <input type="range" id="lengthSlider" min="8" max="32" value="16" oninput="document.getElementById('lengthValue').textContent = this.value">
        </div>
        
        <div class="password-options">
          <div class="password-option">
            <input type="checkbox" id="includeUpper" checked>
            <label for="includeUpper">Include Uppercase Letters</label>
          </div>
          <div class="password-option">
            <input type="checkbox" id="includeLower" checked>
            <label for="includeLower">Include Lowercase Letters</label>
          </div>
          <div class="password-option">
            <input type="checkbox" id="includeNumbers" checked>
            <label for="includeNumbers">Include Numbers</label>
          </div>
          <div class="password-option">
            <input type="checkbox" id="includeSymbols" checked>
            <label for="includeSymbols">Include Symbols (!@#$%^&*)</label>
          </div>
        </div>
        
        <button class="btn" onclick="generatePassword()">Generate Password</button>
        <button class="btn" onclick="copyPassword()">Copy to Clipboard</button>
      </div>
    </div>

    <!-- Interactive Todo List -->
    <div class="demo-card" data-category="utilities">
      <div class="demo-header">
        <div class="demo-icon"><i class="fas fa-tasks"></i></div>
        <h3>Todo List</h3>
      </div>
      <p>Manage tasks with this interactive todo list!</p>
      
      <div class="demo-content">
        <div class="todo-input">
          <input type="text" id="todoInput" placeholder="Add a new task...">
          <button class="btn" onclick="addTodo()" style="width: auto; padding: 12px 25px; margin: 0;">Add</button>
        </div>
        
        <ul class="todo-list" id="todoList">
          <!-- Todos will be added here -->
        </ul>
      </div>
    </div>

    <!-- Code Formatter -->
    <div class="demo-card" data-category="utilities" style="grid-column: span 2;">
      <div class="demo-header">
        <div class="demo-icon"><i class="fas fa-code"></i></div>
        <h3>JSON Formatter</h3>
      </div>
      <p>Format and validate JSON data!</p>
      
      <div class="demo-content">
        <div class="code-editor">
          <div class="editor-header">
            <div class="editor-dot red"></div>
            <div class="editor-dot yellow"></div>
            <div class="editor-dot green"></div>
            <span style="margin-left: 10px; color: var(--text-secondary); font-size: 0.9rem;">JSON Input</span>
          </div>
          <div class="editor-content">
            <textarea id="jsonInput" placeholder='Enter JSON here... e.g., {"name": "Nick", "role": "Developer"}'></textarea>
          </div>
          <div class="editor-output" id="jsonOutput">Formatted JSON will appear here...</div>
        </div>
        
        <div style="display: flex; gap: 10px; margin-top: 15px;">
          <button class="btn" onclick="formatJSON()">Format JSON</button>
          <button class="btn" onclick="minifyJSON()">Minify JSON</button>
        </div>
      </div>
    </div>

    <!-- Memory Game Demo -->
    <div class="demo-card" data-category="games">
      <div class="demo-header">
        <i class="fas fa-brain demo-icon"></i>
        <h3>Memory Match Game</h3>
      </div>
      <div class="demo-content">
        <p>Test your memory by matching pairs of cards!</p>
        
        <div style="margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div>Moves: <span id="memoryMoves" style="color: var(--primary-color); font-weight: bold;">0</span></div>
            <div>Matches: <span id="memoryMatches" style="color: var(--secondary-color); font-weight: bold;">0/8</span></div>
            <div>Time: <span id="memoryTime" style="color: var(--accent-color); font-weight: bold;">0s</span></div>
          </div>
          <div id="memoryGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; max-width: 400px; margin: 0 auto;"></div>
        </div>
        
        <button class="btn" onclick="resetMemoryGame()">Reset Game</button>
      </div>
    </div>

    <!-- Stopwatch Demo -->
    <div class="demo-card" data-category="utilities">
      <div class="demo-header">
        <i class="fas fa-stopwatch demo-icon"></i>
        <h3>Precision Stopwatch</h3>
      </div>
      <div class="demo-content">
        <p>High-precision stopwatch with lap tracking.</p>
        
        <div style="text-align: center; margin-bottom: 20px;">
          <div id="stopwatchDisplay" style="font-size: 3rem; font-weight: bold; color: var(--primary-color); font-family: 'Courier New', monospace; margin: 20px 0;">00:00:00.000</div>
          
          <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 15px;">
            <button class="btn" id="stopwatchStartBtn" onclick="startStopwatch()">Start</button>
            <button class="btn" onclick="stopStopwatch()" style="background: var(--secondary-color);">Stop</button>
            <button class="btn" onclick="lapStopwatch()" style="background: var(--accent-color);">Lap</button>
            <button class="btn" onclick="resetStopwatch()">Reset</button>
          </div>
          
          <div id="lapsContainer" style="max-height: 200px; overflow-y: auto; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 10px;"></div>
        </div>
      </div>
    </div>

    <!-- Unit Converter Demo -->
    <div class="demo-card" data-category="utilities">
      <div class="demo-header">
        <i class="fas fa-exchange-alt demo-icon"></i>
        <h3>Unit Converter</h3>
      </div>
      <div class="demo-content">
        <p>Convert between different units of measurement.</p>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">Category:</label>
          <select id="converterCategory" onchange="updateConverterUnits()" style="width: 100%; padding: 10px; background: rgba(10,10,15,0.95); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; margin-bottom: 15px;">
            <option value="length" style="background: #0a0a0f; color: white;">Length</option>
            <option value="weight" style="background: #0a0a0f; color: white;">Weight</option>
            <option value="temperature" style="background: #0a0a0f; color: white;">Temperature</option>
            <option value="data" style="background: #0a0a0f; color: white;">Data Storage</option>
          </select>
          
          <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; align-items: end;">
            <div>
              <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">From:</label>
              <input type="number" id="converterInput" oninput="convertUnits()" placeholder="Enter value" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: var(--text-primary);">
              <select id="converterFromUnit" onchange="convertUnits()" style="width: 100%; padding: 10px; background: rgba(10,10,15,0.95); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; margin-top: 5px;"></select>
            </div>
            
            <div style="padding-bottom: 45px;">
              <i class="fas fa-arrow-right" style="color: var(--primary-color); font-size: 1.5rem;"></i>
            </div>
            
            <div>
              <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">To:</label>
              <input type="text" id="converterOutput" readonly placeholder="Result" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: var(--primary-color); font-weight: bold;">
              <select id="converterToUnit" onchange="convertUnits()" style="width: 100%; padding: 10px; background: rgba(10,10,15,0.95); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; margin-top: 5px;"></select>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Drawing Canvas Demo -->
    <div class="demo-card" data-category="creative">
      <div class="demo-header">
        <i class="fas fa-paint-brush demo-icon"></i>
        <h3>Drawing Canvas</h3>
      </div>
      <div class="demo-content">
        <p>Express your creativity with this interactive drawing canvas.</p>
        
        <div style="margin-bottom: 15px;">
          <div style="display: flex; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; align-items: center;">
            <label style="color: var(--text-secondary);">Brush Size:</label>
            <input type="range" id="brushSize" min="1" max="20" value="5" style="flex: 1; min-width: 150px;">
            <span id="brushSizeValue" style="color: var(--primary-color); font-weight: bold;">5px</span>
            
            <label style="color: var(--text-secondary); margin-left: 20px;">Color:</label>
            <input type="color" id="brushColor" value="#00d9ff" style="width: 50px; height: 35px; border: none; border-radius: 5px; cursor: pointer;">
          </div>
          
          <canvas id="drawingCanvas" style="width: 100%; max-width: 600px; height: 400px; background: white; border-radius: 8px; cursor: crosshair; display: block; margin: 0 auto; touch-action: none;"></canvas>
          
          <div style="display: flex; gap: 10px; margin-top: 10px; justify-content: center;">
            <button class="btn" onclick="clearCanvas()">Clear Canvas</button>
            <button class="btn" onclick="downloadDrawing()" style="background: var(--secondary-color);">Download</button>
            <button class="btn" onclick="toggleEraser()" id="eraserBtn" style="background: var(--accent-color);">Eraser Mode</button>
          </div>
        </div>
      </div>
    </div>

    <!-- 3D Particle System -->
    <div class="demo-card" data-category="creative">
      <div class="demo-header">
        <i class="fas fa-cube demo-icon"></i>
        <h3>3D Particle System</h3>
      </div>
      <div class="demo-content">
        <p>Interactive 3D particle animation with mouse control</p>
        <canvas id="particleCanvas" style="width: 100%; height: 400px; background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%); border-radius: 12px; cursor: move;"></canvas>
        <div style="display: flex; gap: 10px; margin-top: 15px; align-items: center; flex-wrap: wrap;">
          <label style="color: var(--text-secondary);">Particle Count:</label>
          <input type="range" id="particleCount" min="50" max="500" value="200" onchange="resetParticles()" style="flex: 1; min-width: 150px;">
          <span id="particleCountValue" style="color: var(--primary-color); font-weight: bold;">200</span>
          <button class="btn" onclick="resetParticles()" style="margin-left: auto;">Reset</button>
        </div>
      </div>
    </div>

    <!-- Real-time Code Editor -->
    <div class="demo-card" data-category="utilities">
      <div class="demo-header">
        <i class="fas fa-code demo-icon"></i>
        <h3>Live Code Editor</h3>
      </div>
      <div class="demo-content">
        <p>Write HTML/CSS/JS and see results instantly!</p>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
          <div>
            <label style="color: var(--text-secondary); display: block; margin-bottom: 5px;">HTML</label>
            <textarea id="htmlCode" onkeyup="runCode()" style="width: 100%; height: 120px; background: rgba(255,255,255,0.05); border: 1px solid rgba(0,217,255,0.3); border-radius: 8px; color: var(--text-primary); font-family: 'Fira Code', monospace; padding: 10px; resize: vertical;"><h1>Hello!</h1></textarea>
          </div>
          <div>
            <label style="color: var(--text-secondary); display: block; margin-bottom: 5px;">CSS</label>
            <textarea id="cssCode" onkeyup="runCode()" style="width: 100%; height: 120px; background: rgba(255,255,255,0.05); border: 1px solid rgba(168,85,247,0.3); border-radius: 8px; color: var(--text-primary); font-family: 'Fira Code', monospace; padding: 10px; resize: vertical;">h1 { color: #00d9ff; }</textarea>
          </div>
        </div>
        <div>
          <label style="color: var(--text-secondary); display: block; margin-bottom: 5px;">JavaScript</label>
          <textarea id="jsCode" onkeyup="runCode()" style="width: 100%; height: 80px; background: rgba(255,255,255,0.05); border: 1px solid rgba(245,158,11,0.3); border-radius: 8px; color: var(--text-primary); font-family: 'Fira Code', monospace; padding: 10px; resize: vertical; margin-bottom: 10px;">// Try: document.querySelector('h1').onclick = () => alert('Clicked!');</textarea>
        </div>
        <label style="color: var(--text-secondary); display: block; margin-bottom: 5px;">Preview</label>
        <iframe id="codePreview" style="width: 100%; height: 200px; background: white; border-radius: 8px; border: 2px solid rgba(0,217,255,0.2);"></iframe>
      </div>
    </div>

    <!-- Data Visualization Chart Builder -->
    <div class="demo-card" data-category="data-viz">
      <div class="demo-header">
        <i class="fas fa-chart-bar demo-icon"></i>
        <h3>Chart Builder</h3>
      </div>
      <div class="demo-content">
        <p>Create beautiful charts from your data</p>
        <div style="margin: 15px 0;">
          <label style="color: var(--text-secondary); display: block; margin-bottom: 5px;">Enter data (comma-separated):</label>
          <input type="text" id="chartData" value="10,25,15,40,30,50,35" oninput="updateChart()" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.05); border: 1px solid rgba(0,217,255,0.3); border-radius: 8px; color: var(--text-primary); margin-bottom: 10px;">
          <div style="display: flex; gap: 10px; margin-bottom: 10px;">
            <select id="chartType" onchange="updateChart()" style="flex: 1; padding: 10px; background: rgba(10,10,15,0.95); border: 1px solid rgba(0,217,255,0.3); border-radius: 8px; color: var(--text-primary);">
              <option value="bar" style="background: #0a0a0f; color: white;">Bar Chart</option>
              <option value="line" style="background: #0a0a0f; color: white;">Line Chart</option>
              <option value="pie" style="background: #0a0a0f; color: white;">Pie Chart</option>
            </select>
          </div>
          <canvas id="dataChart" style="width: 100%; height: 300px; background: rgba(255,255,255,0.02); border-radius: 8px;"></canvas>
        </div>
      </div>
    </div>

    <!-- Snake Game -->
    <div class="demo-card" data-category="games impressive">
      <div class="demo-header">
        <i class="fas fa-gamepad demo-icon"></i>
        <h3>Classic Snake Game</h3>
      </div>
      <div class="demo-content">
        <p>Use arrow keys to control the snake. Eat food to grow!</p>
        <div style="text-align: center; margin: 15px 0;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
            <div>Score: <span id="snakeScore" style="color: var(--primary-color); font-weight: bold; font-size: 1.2rem;">0</span></div>
            <div>High: <span id="snakeHigh" style="color: var(--accent-color); font-weight: bold; font-size: 1.2rem;">0</span></div>
          </div>
          <canvas id="snakeCanvas" style="width: 100%; max-width: 400px; height: 400px; background: #0a0a0f; border: 2px solid rgba(0,217,255,0.3); border-radius: 12px; display: block; margin: 0 auto;"></canvas>
          <button class="btn" onclick="startSnakeGame()" style="margin-top: 10px;">Start Game</button>
        </div>
      </div>
    </div>

    <!-- Sentiment Analysis -->
    <div class="demo-card" data-category="ai-ml impressive">
      <div class="demo-header">
        <i class="fas fa-brain demo-icon"></i>
        <h3>Sentiment Analyzer</h3>
      </div>
      <div class="demo-content">
        <p>AI-powered text sentiment analysis</p>
        <textarea id="sentimentText" placeholder="Type or paste text here to analyze its sentiment..." style="width: 100%; height: 120px; background: rgba(255,255,255,0.05); border: 1px solid rgba(0,217,255,0.3); border-radius: 8px; color: var(--text-primary); padding: 15px; margin: 15px 0; resize: vertical;">I love this amazing portfolio! The interactive features are incredible.</textarea>
        <button class="btn" onclick="analyzeSentiment()">Analyze Sentiment</button>
        <div id="sentimentResult" style="margin-top: 15px; padding: 20px; background: rgba(255,255,255,0.03); border-radius: 12px; display: none;">
          <div style="display: flex; justify-content: space-around; margin-bottom: 15px;">
            <div style="text-align: center;">
              <div style="font-size: 2rem; font-weight: bold;" id="sentimentEmoji">üòä</div>
              <div style="color: var(--text-secondary); margin-top: 5px;" id="sentimentLabel">Positive</div>
            </div>
            <div style="text-align: center;">
              <div style="font-size: 2rem; font-weight: bold; color: var(--primary-color);" id="sentimentScore">85%</div>
              <div style="color: var(--text-secondary); margin-top: 5px;">Confidence</div>
            </div>
          </div>
          <div style="display: flex; gap: 10px; margin-top: 15px;">
            <div style="flex: 1;">
              <div style="color: var(--text-secondary); margin-bottom: 5px;">Positive</div>
              <div style="height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                <div id="positiveBar" style="height: 100%; background: linear-gradient(90deg, #10b981, #34d399); width: 0%; transition: width 0.5s ease;"></div>
              </div>
            </div>
            <div style="flex: 1;">
              <div style="color: var(--text-secondary); margin-bottom: 5px;">Negative</div>
              <div style="height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                <div id="negativeBar" style="height: 100%; background: linear-gradient(90deg, #ef4444, #f87171); width: 0%; transition: width 0.5s ease;"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Maze Generator & Solver -->
    <div class="demo-card" data-category="games ai-ml impressive">
      <div class="demo-header">
        <i class="fas fa-project-diagram demo-icon"></i>
        <h3>Maze Generator & Solver</h3>
      </div>
      <div class="demo-content">
        <p>Generate random mazes and watch AI solve them!</p>
        <canvas id="mazeCanvas" style="width: 100%; max-width: 500px; height: 500px; background: #0a0a0f; border: 2px solid rgba(0,217,255,0.3); border-radius: 12px; display: block; margin: 15px auto;"></canvas>
        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
          <button class="btn" onclick="generateMaze()">New Maze</button>
          <button class="btn" onclick="solveMaze()" style="background: var(--secondary-color);">Solve with AI</button>
          <button class="btn" onclick="resetMaze()" style="background: var(--accent-color);">Reset</button>
        </div>
      </div>
    </div>

    <!-- Image Filters -->
    <div class="demo-card" data-category="creative impressive">
      <div class="demo-header">
        <i class="fas fa-images demo-icon"></i>
        <h3>Image Filter Studio</h3>
      </div>
      <div class="demo-content">
        <p>Apply professional filters to images in real-time</p>
        <input type="file" id="imageUpload" accept="image/*" onchange="loadImage(event)" style="display: block; margin: 15px 0; color: var(--text-secondary);">
        <canvas id="imageCanvas" style="width: 100%; max-width: 500px; height: auto; background: rgba(255,255,255,0.02); border-radius: 12px; display: block; margin: 15px auto; min-height: 300px;"></canvas>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; margin-top: 15px;">
          <button class="btn" onclick="applyFilter('grayscale')">Grayscale</button>
          <button class="btn" onclick="applyFilter('sepia')">Sepia</button>
          <button class="btn" onclick="applyFilter('invert')">Invert</button>
          <button class="btn" onclick="applyFilter('blur')">Blur</button>
          <button class="btn" onclick="applyFilter('brightness')">Brighten</button>
          <button class="btn" onclick="applyFilter('contrast')">Contrast</button>
          <button class="btn" onclick="applyFilter('reset')" style="background: var(--accent-color);">Reset</button>
        </div>
      </div>
    </div>

    <!-- Physics Simulator -->
    <div class="demo-card" data-category="creative impressive">
      <div class="demo-header">
        <i class="fas fa-atom demo-icon"></i>
        <h3>Physics Simulator</h3>
      </div>
      <div class="demo-content">
        <p>Interactive physics engine with gravity, collisions, and bounce dynamics</p>
        <canvas id="physicsCanvas" width="600" height="400" style="width: 100%; max-width: 600px; height: auto; aspect-ratio: 3/2; background: linear-gradient(180deg, rgba(10,10,20,0.8), rgba(20,10,30,0.8)); border-radius: 12px; cursor: crosshair; display: block; margin: 15px auto; box-shadow: inset 0 0 20px rgba(0,0,0,0.5);"></canvas>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0;">
          <div style="padding: 12px; background: rgba(0,217,255,0.1); border-radius: 8px;">
            <label style="display: block; color: var(--primary-color); font-weight: bold; margin-bottom: 5px;">Gravity: <span id="gravityValue">0.3</span></label>
            <input type="range" id="gravitySlider" min="0" max="10" value="3" step="1" oninput="updateGravity(this.value)" style="width: 100%;">
          </div>
          <div style="padding: 12px; background: rgba(245,158,11,0.1); border-radius: 8px;">
            <label style="display: block; color: var(--accent-color); font-weight: bold; margin-bottom: 5px;">Bounce: <span id="bounceValue">0.8</span></label>
            <input type="range" id="bounceSlider" min="0" max="10" value="8" step="1" oninput="updateBounce(this.value)" style="width: 100%;">
          </div>
          <div style="padding: 12px; background: rgba(168,85,247,0.1); border-radius: 8px;">
            <label style="display: block; color: var(--secondary-color); font-weight: bold; margin-bottom: 5px;">Time: <span id="timeScaleValue">1.0x</span></label>
            <input type="range" id="timeSlider" min="1" max="20" value="10" step="1" oninput="updateTimeScale(this.value)" style="width: 100%;">
          </div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin: 15px 0;">
          <button class="btn" onclick="addPhysicsBall()">üîµ Add Ball</button>
          <button class="btn" onclick="addPhysicsBox()" style="background: linear-gradient(135deg, #f59e0b, #d97706);">üüß Add Box</button>
          <button class="btn" onclick="addMagnet()" style="background: linear-gradient(135deg, #ef4444, #dc2626);">üß≤ Add Magnet</button>
          <button class="btn" onclick="addBlackHole()" style="background: linear-gradient(135deg, #6b21a8, #4c1d95);">‚ö´ Black Hole</button>
          <button class="btn" onclick="addSpring()" style="background: linear-gradient(135deg, #f59e0b, #ea580c);">üîó Add Spring</button>
          <button class="btn" onclick="togglePhysicsPause()" id="physicsPlayBtn">‚è∏Ô∏è Pause</button>
          <button class="btn" onclick="clearPhysicsBalls()" style="background: var(--accent-color);">üóëÔ∏è Clear All</button>
        </div>
        
        <div style="text-align: center; margin-top: 10px; padding: 10px; background: rgba(168,85,247,0.05); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 5px;">üí° Tips:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem;">Click canvas to add objects ‚Ä¢ Magnets attract balls ‚Ä¢ Adjust physics parameters above!</div>
          <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 5px;">Objects: <span id="objectCount" style="color: var(--primary-color); font-weight: bold;">0</span></div>
        </div>
      </div>
    </div>

    <!-- Music Visualizer -->
    <div class="demo-card" data-category="creative impressive">
      <div class="demo-header">
        <i class="fas fa-music demo-icon"></i>
        <h3>Audio Visualizer</h3>
      </div>
      <div class="demo-content">
        <p>Real-time frequency analysis and stunning audio visualization</p>
        <canvas id="audioCanvas" width="600" height="300" style="width: 100%; max-width: 600px; height: auto; aspect-ratio: 2/1; background: radial-gradient(circle at center, rgba(10,10,30,0.9), rgba(5,5,15,1)); border-radius: 12px; display: block; margin: 15px auto; box-shadow: 0 0 30px rgba(0,217,255,0.3);"></canvas>
        
        <div style="padding: 12px; background: rgba(0,217,255,0.1); border-radius: 8px; margin: 15px 0;">
          <label style="display: block; color: var(--primary-color); font-weight: bold; margin-bottom: 5px;">Sensitivity: <span id="sensitivityValue">1.0x</span></label>
          <input type="range" id="sensitivitySlider" min="5" max="30" value="10" step="1" oninput="updateSensitivity(this.value)" style="width: 100%;">
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 15px;">
          <button class="btn" id="audioStartBtn" onclick="startAudioVisualizer()">üé§ Start Microphone</button>
          <button class="btn" onclick="toggleVisualizerStyle()" id="visualizerStyleBtn">üé® Style: Bars</button>
          <button class="btn" onclick="toggleVisualizerPause()" id="visualizerPauseBtn" disabled>‚è∏Ô∏è Pause</button>
        </div>
        <div style="text-align: center; margin-top: 10px; color: var(--text-secondary); font-size: 0.9rem;">üé§ Uses your microphone to create real-time visualizations</div>
      </div>
    </div>

    <!-- Neural Network Visualizer -->
    <div class="demo-card" data-category="ai-ml impressive">
      <div class="demo-header">
        <i class="fas fa-brain demo-icon"></i>
        <h3>Neural Network Visualizer</h3>
      </div>
      <div class="demo-content">
        <p>Watch a neural network learn to classify data in real-time! See it improve as it trains on XOR problem.</p>
        <canvas id="neuralCanvas" width="800" height="500" style="width: 100%; max-width: 800px; height: auto; aspect-ratio: 8/5; background: linear-gradient(135deg, rgba(10,10,25,0.9), rgba(25,10,40,0.9)); border-radius: 12px; display: block; margin: 15px auto; box-shadow: 0 0 40px rgba(168,85,247,0.2);"></canvas>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0;">
          <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="font-size: 1.5rem; color: var(--primary-color); font-weight: bold;" id="nnEpoch">0</div>
            <div style="font-size: 0.85rem; color: var(--text-secondary);">Epoch</div>
          </div>
          <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="font-size: 1.5rem; color: var(--secondary-color); font-weight: bold;" id="nnLoss">1.000</div>
            <div style="font-size: 0.85rem; color: var(--text-secondary);">Loss</div>
          </div>
          <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="font-size: 1.5rem; color: #00ff88; font-weight: bold;" id="nnAccuracy">0%</div>
            <div style="font-size: 0.85rem; color: var(--text-secondary);">Accuracy</div>
          </div>
          <div style="text-align: center; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 8px;">
            <div style="font-size: 1.5rem; color: #ff9800; font-weight: bold;" id="nnCorrect">0/4</div>
            <div style="font-size: 0.85rem; color: var(--text-secondary);">Correct</div>
          </div>
        </div>
        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
          <button class="btn" onclick="startNeuralTraining()" id="nnTrainBtn">‚ñ∂Ô∏è Start Training</button>
          <button class="btn" onclick="stopNeuralTraining()">‚è∏Ô∏è Pause</button>
          <button class="btn" onclick="resetNeuralNetwork()" style="background: var(--accent-color);">üîÑ Reset</button>
        </div>
        <div style="margin-top: 15px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 5px;">üß† Training XOR Problem:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem;">Left: Network structure | Middle: Decision boundary | Right: Predictions. Watch the boundary improve!</div>
        </div>
      </div>
    </div>

    <!-- Weather Dashboard -->
    <div class="demo-card" data-category="data-viz utilities">
      <div class="demo-header">
        <i class="fas fa-cloud-sun demo-icon"></i>
        <h3>Weather Dashboard</h3>
      </div>
      <div class="demo-content">
        <p>Real-time weather data with beautiful visualizations and forecasts</p>
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
          <input type="text" id="weatherCity" placeholder="Enter city name..." style="flex: 1; padding: 12px; background: rgba(255,255,255,0.05); border: 2px solid rgba(0,217,255,0.3); border-radius: 10px; color: white; font-size: 1rem;" onkeypress="if(event.key==='Enter') getWeather()">
          <button class="btn" onclick="getWeather()">Get Weather</button>
        </div>
        <div id="weatherDisplay" style="padding: 20px; background: linear-gradient(135deg, rgba(0,100,200,0.1), rgba(100,0,200,0.1)); border-radius: 12px; min-height: 200px; display: flex; align-items: center; justify-content: center; color: var(--text-secondary);">
          Enter a city name to see weather data
        </div>
        <div style="text-align: center; margin-top: 10px; color: var(--text-secondary); font-size: 0.85rem;">Try: New York, London, Tokyo, or your city!</div>
      </div>
    </div>

    <!-- Code Syntax Highlighter -->
    <div class="demo-card" data-category="utilities impressive">
      <div class="demo-header">
        <i class="fas fa-code demo-icon"></i>
        <h3>Code Syntax Highlighter</h3>
      </div>
      <div class="demo-content">
        <p>Beautiful syntax highlighting for multiple programming languages</p>
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
          <select id="syntaxLang" style="padding: 10px; background: rgba(10,10,15,0.95); border: 2px solid rgba(0,217,255,0.3); border-radius: 8px; color: white; flex: 1;" onchange="highlightCode()">
            <option value="javascript" style="background: #0a0a0f; color: white;">JavaScript</option>
            <option value="python" style="background: #0a0a0f; color: white;">Python</option>
            <option value="html" style="background: #0a0a0f; color: white;">HTML</option>
            <option value="css" style="background: #0a0a0f; color: white;">CSS</option>
            <option value="sql" style="background: #0a0a0f; color: white;">SQL</option>
          </select>
          <button class="btn" onclick="highlightCode()">Highlight</button>
        </div>
        <textarea id="codeInput" placeholder="Paste your code here..." style="width: 100%; min-height: 150px; padding: 15px; background: rgba(255,255,255,0.03); border: 2px solid rgba(0,217,255,0.2); border-radius: 10px; color: var(--text-secondary); font-family: 'Courier New', monospace; font-size: 0.95rem; resize: vertical;"></textarea>
        <div id="highlightedCode" style="margin-top: 15px; padding: 20px; background: linear-gradient(135deg, rgba(10,10,20,0.9), rgba(20,10,30,0.9)); border-radius: 12px; overflow-x: auto; min-height: 100px; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.6; display: none; box-shadow: inset 0 0 20px rgba(0,0,0,0.3);"></div>
      </div>
    </div>

    <!-- Real-Time Markdown Editor -->
    <div class="demo-card" data-category="impressive utilities">
      <div class="demo-header">
        <i class="fas fa-file-code demo-icon"></i>
        <h3>‚≠ê Live Markdown Editor</h3>
      </div>
      <div class="demo-content">
        <p>Real-time Markdown to HTML converter with live preview and syntax support</p>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
          <div>
            <div style="color: var(--primary-color); font-weight: bold; margin-bottom: 10px;">‚úçÔ∏è Markdown Input</div>
            <textarea id="markdownInput" placeholder="# Hello World&#10;&#10;This is **bold** and *italic*&#10;&#10;- List item 1&#10;- List item 2&#10;&#10;```javascript&#10;console.log('Hello!');&#10;```" style="width: 100%; min-height: 300px; padding: 15px; background: rgba(10,10,20,0.9); border: 2px solid rgba(0,217,255,0.3); border-radius: 10px; color: white; font-family: 'Courier New', monospace; font-size: 0.9rem; resize: vertical;" oninput="updateMarkdown()"></textarea>
          </div>
          <div>
            <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 10px;">üëÅÔ∏è Live Preview</div>
            <div id="markdownPreview" style="min-height: 300px; padding: 15px; background: rgba(255,255,255,0.03); border: 2px solid rgba(168,85,247,0.3); border-radius: 10px; overflow-y: auto; color: var(--text-secondary); line-height: 1.6;">Start typing Markdown to see the magic!</div>
          </div>
        </div>
      </div>
    </div>

    <!-- JSON Formatter & Validator -->
    <div class="demo-card" data-category="impressive utilities">
      <div class="demo-header">
        <i class="fas fa-brackets-curly demo-icon"></i>
        <h3>‚≠ê JSON Formatter & Validator</h3>
      </div>
      <div class="demo-content">
        <p>Parse, validate, beautify, and minify JSON with error detection</p>
        <textarea id="jsonInput" placeholder='{"name": "John", "age": 30, "city": "New York"}' style="width: 100%; min-height: 150px; padding: 15px; background: rgba(10,10,20,0.9); border: 2px solid rgba(0,217,255,0.3); border-radius: 10px; color: white; font-family: 'Courier New', monospace; font-size: 0.9rem; resize: vertical;"></textarea>
        <div style="display: flex; gap: 10px; margin: 15px 0; flex-wrap: wrap;">
          <button class="btn" onclick="formatJSON()">üé® Format (Beautify)</button>
          <button class="btn" onclick="minifyJSON()">üì¶ Minify</button>
          <button class="btn" onclick="validateJSON()">‚úÖ Validate</button>
        </div>
        <div id="jsonOutput" style="padding: 15px; background: rgba(255,255,255,0.03); border-radius: 10px; min-height: 100px; display: none;"></div>
        <div id="jsonError" style="padding: 15px; background: rgba(255,0,0,0.1); border: 2px solid #ff3b30; border-radius: 10px; color: #ff3b30; margin-top: 15px; display: none;"></div>
      </div>
    </div>

    <!-- Regex Tester -->
    <div class="demo-card" data-category="impressive utilities">
      <div class="demo-header">
        <i class="fas fa-search demo-icon"></i>
        <h3>‚≠ê Regex Pattern Tester</h3>
      </div>
      <div class="demo-content">
        <p>Test regular expressions with real-time highlighting and match extraction</p>
        <div style="margin-bottom: 15px;">
          <label style="color: var(--primary-color); font-weight: bold; display: block; margin-bottom: 5px;">Regular Expression:</label>
          <input type="text" id="regexPattern" placeholder="Enter regex pattern (e.g., \b\w+@\w+\.\w+\b)" value="\b\w+@\w+\.\w+\b" style="width: 100%; padding: 12px; background: rgba(10,10,20,0.9); border: 2px solid rgba(0,217,255,0.3); border-radius: 10px; color: white; font-family: 'Courier New', monospace;" oninput="testRegex()">
          <div style="margin-top: 10px;">
            <label style="margin-right: 15px;"><input type="checkbox" id="regexGlobal" checked onchange="testRegex()"> Global (g)</label>
            <label style="margin-right: 15px;"><input type="checkbox" id="regexCaseInsensitive" onchange="testRegex()"> Case Insensitive (i)</label>
            <label><input type="checkbox" id="regexMultiline" onchange="testRegex()"> Multiline (m)</label>
          </div>
        </div>
        <div style="margin-bottom: 15px;">
          <label style="color: var(--secondary-color); font-weight: bold; display: block; margin-bottom: 5px;">Test String:</label>
          <textarea id="regexTestString" placeholder="Enter text to test against..." style="width: 100%; min-height: 120px; padding: 12px; background: rgba(255,255,255,0.03); border: 2px solid rgba(168,85,247,0.3); border-radius: 10px; color: white; resize: vertical;" oninput="testRegex()">Contact me at john@example.com or jane.doe@company.org for more info!</textarea>
        </div>
        <div id="regexResults" style="padding: 15px; background: rgba(0,217,255,0.05); border: 2px solid var(--primary-color); border-radius: 10px; display: none;">
          <div style="font-weight: bold; color: var(--primary-color); margin-bottom: 10px;">Matches Found: <span id="regexMatchCount">0</span></div>
          <div id="regexMatches" style="color: var(--text-secondary);"></div>
        </div>
        <div id="regexError" style="padding: 15px; background: rgba(255,0,0,0.1); border: 2px solid #ff3b30; border-radius: 10px; color: #ff3b30; margin-top: 15px; display: none;"></div>
      </div>
    </div>

    <!-- Password Strength Analyzer -->
    <div class="demo-card" data-category="impressive utilities">
      <div class="demo-header">
        <i class="fas fa-shield-alt demo-icon"></i>
        <h3>‚≠ê Password Strength Analyzer</h3>
      </div>
      <div class="demo-content">
        <p>Advanced password security analysis with real-time feedback and suggestions</p>
        <input type="text" id="passwordInput" placeholder="Enter a password to analyze..." style="width: 100%; padding: 15px; background: rgba(10,10,20,0.9); border: 2px solid rgba(0,217,255,0.3); border-radius: 10px; color: white; font-size: 1.1rem; margin-bottom: 15px;" oninput="analyzePassword()">
        <div id="passwordStrengthBar" style="height: 10px; background: rgba(255,255,255,0.1); border-radius: 20px; overflow: hidden; margin-bottom: 20px;">
          <div id="passwordStrengthFill" style="height: 100%; width: 0%; background: linear-gradient(90deg, #ff3b30, #ff9500, #ffcc00, #34c759); transition: all 0.3s;"></div>
        </div>
        <div id="passwordFeedback" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;"></div>
        <div id="passwordScore" style="padding: 20px; background: rgba(255,255,255,0.03); border-radius: 12px; text-align: center; display: none;">
          <div style="font-size: 3rem; margin-bottom: 10px;" id="passwordEmoji">üîí</div>
          <div style="font-size: 1.5rem; font-weight: bold; margin-bottom: 5px;" id="passwordStrengthText">-</div>
          <div style="color: var(--text-secondary);" id="passwordCrackTime">Enter a password</div>
        </div>
        <div id="passwordSuggestions" style="margin-top: 15px; padding: 15px; background: rgba(0,217,255,0.05); border-left: 4px solid var(--primary-color); border-radius: 8px; display: none;">
          <div style="font-weight: bold; color: var(--primary-color); margin-bottom: 10px;">üí° Suggestions:</div>
          <ul id="passwordSuggestionsList" style="margin: 0; padding-left: 20px; color: var(--text-secondary);"></ul>
        </div>
      </div>
    </div>

    <!-- Text Diff Checker -->
    <div class="demo-card" data-category="impressive utilities">
      <div class="demo-header">
        <i class="fas fa-code-compare demo-icon"></i>
        <h3>‚≠ê Text Diff Checker</h3>
      </div>
      <div class="demo-content">
        <p>Compare two texts and visualize differences with color-coded highlighting</p>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
          <div>
            <label style="color: var(--primary-color); font-weight: bold; display: block; margin-bottom: 5px;">Original Text</label>
            <textarea id="diffText1" placeholder="Enter original text..." style="width: 100%; min-height: 200px; padding: 12px; background: rgba(10,10,20,0.9); border: 2px solid rgba(0,217,255,0.3); border-radius: 10px; color: white; font-family: 'Courier New', monospace; font-size: 0.9rem; resize: vertical;"></textarea>
          </div>
          <div>
            <label style="color: var(--secondary-color); font-weight: bold; display: block; margin-bottom: 5px;">Modified Text</label>
            <textarea id="diffText2" placeholder="Enter modified text..." style="width: 100%; min-height: 200px; padding: 12px; background: rgba(10,10,20,0.9); border: 2px solid rgba(168,85,247,0.3); border-radius: 10px; color: white; font-family: 'Courier New', monospace; font-size: 0.9rem; resize: vertical;"></textarea>
          </div>
        </div>
        <button class="btn" onclick="calculateDiff()" style="width: 100%; padding: 15px; font-size: 1.1rem;">üîç Compare Texts</button>
        <div id="diffResults" style="margin-top: 20px; display: none;">
          <div style="padding: 15px; background: rgba(255,255,255,0.03); border-radius: 10px; margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-around; text-align: center;">
              <div>
                <div style="font-size: 2rem; color: #34c759;" id="diffSame">0</div>
                <div style="color: var(--text-secondary);">Same</div>
              </div>
              <div>
                <div style="font-size: 2rem; color: #ff9500;" id="diffChanged">0</div>
                <div style="color: var(--text-secondary);">Changed</div>
              </div>
              <div>
                <div style="font-size: 2rem; color: #ff3b30;" id="diffRemoved">0</div>
                <div style="color: var(--text-secondary);">Removed</div>
              </div>
              <div>
                <div style="font-size: 2rem; color: #00d9ff;" id="diffAdded">0</div>
                <div style="color: var(--text-secondary);">Added</div>
              </div>
            </div>
          </div>
          <div id="diffOutput" style="padding: 20px; background: rgba(10,10,20,0.9); border-radius: 12px; font-family: 'Courier New', monospace; font-size: 0.9rem; line-height: 1.8; max-height: 400px; overflow-y: auto;"></div>
        </div>
      </div>
    </div>

    <!-- Base64 Encoder/Decoder -->
    <div class="demo-card" data-category="impressive utilities">
      <div class="demo-header">
        <i class="fas fa-lock demo-icon"></i>
        <h3>‚≠ê Base64 Encoder/Decoder</h3>
      </div>
      <div class="demo-content">
        <p>Encode and decode text or files to/from Base64 with drag-and-drop support</p>
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
          <button class="btn" onclick="setBase64Mode('encode')" id="base64EncodeBtn" style="flex: 1;">üîí Encode</button>
          <button class="btn" onclick="setBase64Mode('decode')" id="base64DecodeBtn" style="flex: 1; background: var(--secondary-color);">üîì Decode</button>
        </div>
        <div id="base64FileUpload" style="border: 2px dashed rgba(0,217,255,0.3); border-radius: 12px; padding: 40px; text-align: center; margin-bottom: 15px; cursor: pointer; transition: all 0.3s;" onclick="document.getElementById('base64FileInput').click()">
          <input type="file" id="base64FileInput" style="display: none;" onchange="handleBase64File(event)">
          <div style="font-size: 3rem; margin-bottom: 10px;">üìÅ</div>
          <div style="color: var(--primary-color); font-weight: bold;">Drop a file here or click to upload</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 5px;">For encoding files to Base64</div>
        </div>
        <textarea id="base64Input" placeholder="Enter text to encode/decode..." style="width: 100%; min-height: 150px; padding: 15px; background: rgba(10,10,20,0.9); border: 2px solid rgba(0,217,255,0.3); border-radius: 10px; color: white; font-family: 'Courier New', monospace; font-size: 0.9rem; resize: vertical;"></textarea>
        <button class="btn" onclick="processBase64()" style="width: 100%; margin: 15px 0; padding: 12px;">Process</button>
        <div id="base64Output" style="padding: 15px; background: rgba(255,255,255,0.03); border-radius: 10px; min-height: 100px; font-family: 'Courier New', monospace; word-break: break-all; display: none;"></div>
        <button class="btn" onclick="copyBase64()" id="base64CopyBtn" style="width: 100%; margin-top: 10px; display: none;">üìã Copy to Clipboard</button>
      </div>
    </div>

    <!-- AI Path Planning with A* Algorithm -->
    <div class="demo-card" data-category="impressive ai-ml">
      <div class="demo-header">
        <i class="fas fa-route demo-icon"></i>
        <h3>‚≠ê AI Path Planning (A* Algorithm)</h3>
      </div>
      <div class="demo-content">
        <p>Watch the A* pathfinding algorithm find optimal paths in real-time! Draw obstacles, move start/end points, see explored nodes!</p>
        <canvas id="astarCanvas" width="500" height="350" style="border: 3px solid var(--primary-color); border-radius: 10px; background: #0a0a0f; display: block; margin: 15px auto; cursor: crosshair; max-width: 100%;"></canvas>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0;">
          <button class="btn" onclick="astarSetMode('start')" id="astarModeStart" style="font-size: 0.9rem;">üìç Set Start</button>
          <button class="btn" onclick="astarSetMode('end')" id="astarModeEnd" style="font-size: 0.9rem;">üéØ Set End</button>
          <button class="btn" onclick="astarSetMode('wall')" id="astarModeWall" style="font-size: 0.9rem;">üß± Draw Walls</button>
          <button class="btn" onclick="astarClear()" style="font-size: 0.9rem;">üóëÔ∏è Clear</button>
        </div>
        <button class="btn" onclick="astarFindPath()" style="width: 100%; padding: 15px; font-size: 1.1rem; background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));">üöÄ Find Path!</button>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 15px;">
          <div style="padding: 15px; background: rgba(0,217,255,0.1); border-radius: 10px; text-align: center;">
            <div style="font-size: 1.5rem; color: var(--primary-color);" id="astarExplored">0</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Nodes Explored</div>
          </div>
          <div style="padding: 15px; background: rgba(245,158,11,0.1); border-radius: 10px; text-align: center;">
            <div style="font-size: 1.5rem; color: var(--accent-color);" id="astarPathLength">0</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Path Length</div>
          </div>
          <div style="padding: 15px; background: rgba(168,85,247,0.1); border-radius: 10px; text-align: center;">
            <div style="font-size: 1.5rem; color: var(--secondary-color);" id="astarTime">0ms</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Computation Time</div>
          </div>
        </div>
        <div style="margin-top: 15px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 8px;">üí° Legend:</div>
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; font-size: 0.9rem;">
            <div><span style="color: #10b981;">üü¢ Green:</span> Start Node</div>
            <div><span style="color: #ef4444;">üî¥ Red:</span> End Node</div>
            <div><span style="color: #dc2626;">üü• Red Walls:</span> Obstacles</div>
            <div><span style="color: #00d9ff;">üîµ Cyan:</span> Explored</div>
            <div><span style="color: #f59e0b;">üü° Yellow:</span> Optimal Path</div>
            <div><span style="color: #a855f7;">üü£ Purple:</span> Frontier</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Genetic Algorithm Evolution -->
    <div class="demo-card" data-category="impressive ai-ml">
      <div class="demo-header">
        <i class="fas fa-dna demo-icon"></i>
        <h3>‚≠ê Genetic Algorithm Evolution</h3>
      </div>
      <div class="demo-content">
        <p>Watch creatures evolve through natural selection! They learn to reach the <span style="color: #f59e0b; font-weight: bold;">YELLOW TARGET ‚≠ê</span> using genetic algorithms!</p>
        <canvas id="geneticCanvas" width="600" height="350" style="border: 3px solid var(--primary-color); border-radius: 10px; background: linear-gradient(135deg, #0a0a1e, #1a0a2e); display: block; margin: 15px auto; max-width: 100%;"></canvas>
        <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin: 15px 0; text-align: center;">
          <div style="padding: 15px; background: rgba(0,217,255,0.1); border-radius: 10px;">
            <div style="font-size: 1.5rem; color: var(--primary-color);" id="genGeneration">0</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Generation</div>
          </div>
          <div style="padding: 15px; background: rgba(16,185,129,0.1); border-radius: 10px;">
            <div style="font-size: 1.5rem; color: #10b981;" id="genBestFitness">0</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Best Fitness</div>
          </div>
          <div style="padding: 15px; background: rgba(245,158,11,0.1); border-radius: 10px;">
            <div style="font-size: 1.5rem; color: var(--accent-color);" id="genAvgFitness">0</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Avg Fitness</div>
          </div>
          <div style="padding: 15px; background: rgba(168,85,247,0.1); border-radius: 10px;">
            <div style="font-size: 1.5rem; color: var(--secondary-color);" id="genPopSize">50</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Population</div>
          </div>
          <div style="padding: 15px; background: rgba(239,68,68,0.1); border-radius: 10px;">
            <div style="font-size: 1.5rem; color: #ef4444;" id="genMutationRate">2%</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Mutation</div>
          </div>
        </div>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
          <button class="btn" onclick="startGeneticAlgorithm()" id="genStartBtn" style="padding: 12px; font-size: 1rem; background: linear-gradient(135deg, #10b981, #059669);">‚ñ∂Ô∏è Start Evolution</button>
          <button class="btn" onclick="pauseGeneticAlgorithm()" id="genPauseBtn" style="padding: 12px; font-size: 1rem;" disabled>‚è∏Ô∏è Pause</button>
          <button class="btn" onclick="resetGeneticAlgorithm()" style="padding: 12px; font-size: 1rem;">üîÑ Reset</button>
        </div>
        <div style="margin-top: 15px; padding: 15px; background: rgba(16,185,129,0.05); border-left: 4px solid #10b981; border-radius: 8px;">
          <div style="color: #10b981; font-weight: bold; margin-bottom: 8px;">üß¨ How It Works:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            <strong>1. Initialize:</strong> 50 creatures with random DNA (movement instructions)<br>
            <strong>2. Evaluate:</strong> Each creature tries to reach the target<br>
            <strong>3. Selection:</strong> Best performers get to reproduce<br>
            <strong>4. Crossover:</strong> DNA is mixed from two parents<br>
            <strong>5. Mutation:</strong> Random changes keep diversity<br>
            <strong>6. Repeat:</strong> Each generation gets closer to optimal behavior!
          </div>
        </div>
      </div>
    </div>

    <!-- Reinforcement Learning Agent -->
    <div class="demo-card" data-category="impressive ai-ml">
      <div class="demo-header">
        <i class="fas fa-gamepad demo-icon"></i>
        <h3>‚≠ê Reinforcement Learning Agent</h3>
      </div>
      <div class="demo-content">
        <p>Watch an AI learn to play a game using Q-Learning! It starts random but improves through trial and error!</p>
        <canvas id="rlCanvas" width="450" height="450" style="border: 3px solid var(--primary-color); border-radius: 10px; background: #0a0a0f; display: block; margin: 15px auto; max-width: 100%;"></canvas>
        <div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; margin: 15px 0; text-align: center;">
          <div style="padding: 8px; background: rgba(0,217,255,0.1); border-radius: 8px;">
            <div style="font-size: 1.2rem; color: var(--primary-color);" id="rlEpisode">0</div>
            <div style="color: var(--text-secondary); font-size: 0.7rem;">Episode</div>
          </div>
          <div style="padding: 8px; background: rgba(16,185,129,0.1); border-radius: 8px;">
            <div style="font-size: 1.2rem; color: #10b981;" id="rlReward">0</div>
            <div style="color: var(--text-secondary); font-size: 0.7rem;">Reward</div>
          </div>
          <div style="padding: 8px; background: rgba(245,158,11,0.1); border-radius: 8px;">
            <div style="font-size: 1.2rem; color: var(--accent-color);" id="rlSteps">0</div>
            <div style="color: var(--text-secondary); font-size: 0.7rem;">Steps</div>
          </div>
          <div style="padding: 8px; background: rgba(168,85,247,0.1); border-radius: 8px;">
            <div style="font-size: 1.2rem; color: var(--secondary-color);" id="rlEpsilon">100%</div>
            <div style="color: var(--text-secondary); font-size: 0.7rem;">Explore</div>
          </div>
          <div style="padding: 8px; background: rgba(239,68,68,0.1); border-radius: 8px;">
            <div style="font-size: 1.2rem; color: #ef4444;" id="rlSuccess">0%</div>
            <div style="color: var(--text-secondary); font-size: 0.7rem;">Success</div>
          </div>
        </div>
        <div style="display: flex; gap: 10px;">
          <button class="btn" onclick="startRLTraining()" id="rlStartBtn" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #10b981, #059669);">ü§ñ Start Learning</button>
          <button class="btn" onclick="stopRLTraining()" id="rlStopBtn" style="flex: 1; padding: 12px;" disabled>‚è∏Ô∏è Pause</button>
          <button class="btn" onclick="resetRLAgent()" style="padding: 12px;">üîÑ Reset</button>
        </div>
        <div style="margin-top: 15px; padding: 15px; background: rgba(16,185,129,0.05); border-left: 4px solid #10b981; border-radius: 8px;">
          <div style="color: #10b981; font-weight: bold; margin-bottom: 8px;">üéÆ Q-Learning Algorithm:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            <strong>Goal:</strong> Agent (ü§ñ) must reach treasure (üíé) while avoiding lava (üî•)<br>
            <strong>Learning:</strong> Explores randomly at first, then exploits learned knowledge<br>
            <strong>Rewards:</strong> +100 for treasure, -100 for lava, -1 per step<br>
            <strong>Q-Table:</strong> Learns value of each action in each state
          </div>
        </div>
      </div>
    </div>

    <!-- Multi-Language Code Compiler & Executor -->
    <div class="demo-card" data-category="impressive creative">
      <div class="demo-header">
        <i class="fas fa-code demo-icon"></i>
        <h3>‚≠ê Multi-Language Code Compiler & Executor</h3>
      </div>
      <div class="demo-content">
        <p>Full-featured code editor with real-time execution! Run JavaScript, preview HTML, validate JSON, format code, and more!</p>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; margin-bottom: 15px;">
          <button class="btn" onclick="setCodeLanguage('javascript')" id="langJS" style="background: linear-gradient(135deg, #f7df1e, #e6cf0e); color: black;">üíõ JavaScript</button>
          <button class="btn" onclick="setCodeLanguage('python')" id="langPY" style="background: linear-gradient(135deg, #3776ab, #2b5b8a);">üêç Python</button>
          <button class="btn" onclick="setCodeLanguage('html')" id="langHTML" style="background: linear-gradient(135deg, #e34c26, #c23616);">üåê HTML/CSS</button>
          <button class="btn" onclick="setCodeLanguage('sql')" id="langSQL" style="background: linear-gradient(135deg, #00758f, #005a6f);">üóÑÔ∏è SQL</button>
          <button class="btn" onclick="setCodeLanguage('json')" id="langJSON" style="background: linear-gradient(135deg, #5a5a5a, #3a3a3a);">üìã JSON</button>
        </div>
        
        <div style="margin-bottom: 15px;">
          <label style="display: block; color: var(--primary-color); font-weight: bold; margin-bottom: 8px;">üìù Code Editor:</label>
          <textarea id="codeEditor" spellcheck="false" style="width: 100%; min-height: 300px; padding: 15px; background: #1e1e1e; color: #d4d4d4; border: 2px solid var(--primary-color); border-radius: 10px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.5; resize: vertical;"></textarea>
          <div style="display: flex; gap: 15px; margin-top: 8px; color: var(--text-secondary); font-size: 0.85rem;">
            <span>Lines: <span id="codeLines" style="color: var(--primary-color); font-weight: bold;">0</span></span>
            <span>Characters: <span id="codeChars" style="color: var(--accent-color); font-weight: bold;">0</span></span>
            <span>Language: <span id="currentLang" style="color: var(--secondary-color); font-weight: bold;">JavaScript</span></span>
          </div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; margin-bottom: 15px;">
          <button class="btn" onclick="runCode()" style="background: linear-gradient(135deg, #10b981, #059669);">‚ñ∂Ô∏è Run Code</button>
          <button class="btn" onclick="validateCode()" style="background: linear-gradient(135deg, #3b82f6, #2563eb);">‚úì Validate</button>
          <button class="btn" onclick="formatCode()" style="background: linear-gradient(135deg, #8b5cf6, #7c3aed);">‚ú® Format</button>
          <button class="btn" onclick="clearCode()">üóëÔ∏è Clear</button>
          <button class="btn" onclick="loadTemplate()" style="background: linear-gradient(135deg, #f59e0b, #d97706);">üìÑ Template</button>
        </div>
        
        <div id="htmlPreview" style="display: none; margin-bottom: 15px;">
          <label style="display: block; color: var(--accent-color); font-weight: bold; margin-bottom: 8px;">üåê HTML Preview:</label>
          <iframe id="htmlFrame" style="width: 100%; height: 300px; border: 2px solid var(--accent-color); border-radius: 10px; background: white;"></iframe>
        </div>
        
        <div id="codeOutput" style="display: none; padding: 15px; background: rgba(0,217,255,0.05); border-left: 4px solid var(--primary-color); border-radius: 10px; margin-top: 15px;">
          <div style="color: var(--primary-color); font-weight: bold; margin-bottom: 8px;">üì§ Output:</div>
          <pre id="outputContent" style="margin: 0; color: var(--text-secondary); font-family: 'Courier New', monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word; max-height: 300px; overflow-y: auto;"></pre>
        </div>
        
        <div style="margin-top: 15px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 8px;">üí° Features:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            <strong>JavaScript:</strong> Real-time execution with console output capture<br>
            <strong>HTML/CSS:</strong> Live preview in iframe sandbox<br>
            <strong>JSON:</strong> Validation, formatting, and beautification<br>
            <strong>Python/SQL:</strong> Syntax validation and code templates<br>
            <strong>Auto-save:</strong> Code persists in browser storage per language!
          </div>
        </div>
      </div>
    </div>

    <!-- Mini Minecraft Clone -->
    <div class="demo-card" data-category="impressive games creative">
      <div class="demo-header">
        <i class="fas fa-cubes demo-icon"></i>
        <h3>‚≠ê 3D Minecraft Clone (First-Person)</h3>
      </div>
      <div class="demo-content">
        <p>Full 3D first-person Minecraft! Mine blocks with real mining time, craft tools, explore procedural world with collision detection and physics!</p>
        <div id="minecraftContainer" style="width: 100%; max-width: 800px; height: 500px; background: #87CEEB; border-radius: 12px; cursor: pointer; display: block; margin: 15px auto; box-shadow: 0 5px 25px rgba(0,0,0,0.3); position: relative; overflow: hidden;"></div>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin: 15px 0;">
          <div style="padding: 15px; background: rgba(0,217,255,0.1); border-radius: 10px;">
            <div style="color: var(--primary-color); font-weight: bold; margin-bottom: 10px;">üéí Inventory (<span id="mcInvCount">0</span>/27):</div>
            <div id="mcInventory" style="display: grid; grid-template-columns: repeat(9, 1fr); gap: 5px; max-height: 120px; overflow-y: auto;"></div>
          </div>
          <div style="padding: 15px; background: rgba(168,85,247,0.1); border-radius: 10px;">
            <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 10px;">ÔøΩÔ∏è Hotbar (1-5 keys):</div>
            <div id="mcHotbar" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px;"></div>
            <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px; font-size: 0.85rem;">
              <div style="color: white;">Selected: <span id="mcSelected" style="color: var(--primary-color); font-weight: bold;">Fist</span></div>
              <div style="color: var(--text-secondary); margin-top: 5px;">Mining: <span id="mcMiningProgress" style="color: #f59e0b;">0%</span></div>
            </div>
          </div>
        </div>
        <div style="display: flex; gap: 10px; margin: 15px 0;">
          <button class="btn" onclick="openMcCrafting()" style="flex: 1;">üî® Crafting Table</button>
          <button class="btn" onclick="resetMcWorld()" style="flex: 1;">üåç New World</button>
        </div>
        <div id="mcCraftingMenu" style="display: none; padding: 20px; background: rgba(0,0,0,0.95); border: 3px solid var(--primary-color); border-radius: 15px; margin: 15px 0;">
          <h4 style="color: var(--primary-color); margin-bottom: 15px;">ÔøΩ Crafting Recipes</h4>
          <div id="mcRecipes" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;"></div>
          <button class="btn" onclick="closeMcCrafting()" style="width: 100%; margin-top: 15px;">‚úñÔ∏è Close</button>
        </div>
        <div style="padding: 15px; background: rgba(0,217,255,0.05); border-left: 4px solid var(--primary-color); border-radius: 8px;">
          <div style="color: var(--primary-color); font-weight: bold; margin-bottom: 8px;">üéÆ Controls:</div>
          <div style="color: var(--text-secondary); font-size: 0.85rem; line-height: 1.6;">
            <strong>WASD:</strong> Move ‚Ä¢ <strong>Mouse:</strong> Look around ‚Ä¢ <strong>Space:</strong> Jump<br>
            <strong>Left Click:</strong> Mine (hold) ‚Ä¢ <strong>Right Click:</strong> Place block ‚Ä¢ <strong>1-5:</strong> Hotbar<br>
            <strong>C:</strong> Crafting ‚Ä¢ <strong>Click game to lock mouse</strong><br>
            Mine trees for wood ‚Ä¢ Craft wooden pickaxe to mine stone ‚Ä¢ Build anything!
          </div>
        </div>
      </div>
    </div>

    <!-- Space Shooter Game -->
    <div class="demo-card" data-category="impressive games">
      <div class="demo-header">
        <i class="fas fa-rocket demo-icon"></i>
        <h3>‚≠ê Space Shooter</h3>
      </div>
      <div class="demo-content">
        <p>Classic 2D space shooter with enemies, power-ups, and explosions!</p>
        <canvas id="spaceCanvas" width="800" height="500" style="width: 100%; height: auto; aspect-ratio: 8/5; background: linear-gradient(180deg, #000428, #004e92); border-radius: 12px; display: block; margin: 15px auto; box-shadow: 0 5px 25px rgba(0,217,255,0.3);"></canvas>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 15px 0;">
          <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.03); border-radius: 10px;">
            <div style="font-size: 2rem; color: var(--primary-color); font-weight: bold;" id="spaceScore">0</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Score</div>
          </div>
          <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.03); border-radius: 10px;">
            <div style="font-size: 2rem; color: #34c759; font-weight: bold;" id="spaceHealth">100</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Health</div>
          </div>
          <div style="text-align: center; padding: 15px; background: rgba(255,255,255,0.03); border-radius: 10px;">
            <div style="font-size: 2rem; color: var(--accent-color); font-weight: bold;" id="spaceHighScore">0</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">High Score</div>
          </div>
        </div>
        <button class="btn" onclick="initSpaceGame()" style="width: 100%; padding: 15px; font-size: 1.1rem;" id="spaceStartBtn">üöÄ Start Game</button>
        <div style="text-align: center; margin-top: 10px; color: var(--text-secondary); font-size: 0.9rem;">
          Use Arrow Keys to move ‚Ä¢ Space to shoot ‚Ä¢ Avoid enemies!
        </div>
      </div>
    </div>

    <!-- Flappy Bird Clone -->
    <div class="demo-card" data-category="impressive games">
      <div class="demo-header">
        <i class="fas fa-dove demo-icon"></i>
        <h3>‚≠ê Flappy Square</h3>
      </div>
      <div class="demo-content">
        <p>Addictive Flappy Bird-style game with smooth physics and scoring!</p>
        <canvas id="flappyCanvas" width="400" height="600" style="width: 100%; max-width: 400px; height: auto; aspect-ratio: 2/3; background: linear-gradient(180deg, #87CEEB, #E0F6FF); border-radius: 12px; cursor: pointer; display: block; margin: 15px auto; box-shadow: 0 5px 25px rgba(0,0,0,0.3);" onclick="flappyJump()"></canvas>
        <div style="display: flex; gap: 15px; margin: 15px 0;">
          <div style="flex: 1; text-align: center; padding: 15px; background: rgba(255,255,255,0.03); border-radius: 10px;">
            <div style="font-size: 2.5rem; color: var(--primary-color); font-weight: bold;" id="flappyScore">0</div>
            <div style="color: var(--text-secondary);">Score</div>
          </div>
          <div style="flex: 1; text-align: center; padding: 15px; background: rgba(255,255,255,0.03); border-radius: 10px;">
            <div style="font-size: 2.5rem; color: var(--accent-color); font-weight: bold;" id="flappyBest">0</div>
            <div style="color: var(--text-secondary);">Best</div>
          </div>
        </div>
        <button class="btn" onclick="startFlappyGame()" style="width: 100%; padding: 15px; font-size: 1.1rem;">üê¶ Start Flying</button>
        <div style="text-align: center; margin-top: 10px; color: var(--text-secondary); font-size: 0.9rem;">
          Click or tap to flap ‚Ä¢ Don't hit the pipes!
        </div>
      </div>
    </div>

    <!-- Tic Tac Toe AI -->
    <div class="demo-card" data-category="impressive games ai-ml">
      <div class="demo-header">
        <i class="fas fa-brain demo-icon"></i>
        <h3>‚≠ê Unbeatable Tic-Tac-Toe AI</h3>
      </div>
      <div class="demo-content">
        <p>Challenge an AI that uses the Minimax algorithm - can you beat it or force a draw?</p>
        <div id="ticTacBoard" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 400px; margin: 20px auto;"></div>
        <div style="text-align: center; margin: 20px 0;">
          <div style="font-size: 1.5rem; color: var(--primary-color); margin-bottom: 15px;" id="ticTacStatus">Your turn! (X)</div>
          <div style="display: flex; gap: 30px; justify-content: center; margin: 15px 0;">
            <div style="text-align: center;">
              <div style="font-size: 2rem; color: var(--primary-color);" id="ticTacWins">0</div>
              <div style="color: var(--text-secondary);">Wins</div>
            </div>
            <div style="text-align: center;">
              <div style="font-size: 2rem; color: var(--text-secondary);" id="ticTacDraws">0</div>
              <div style="color: var(--text-secondary);">Draws</div>
            </div>
            <div style="text-align: center;">
              <div style="font-size: 2rem; color: var(--accent-color);" id="ticTacLosses">0</div>
              <div style="color: var(--text-secondary);">Losses</div>
            </div>
          </div>
        </div>
        <button class="btn" onclick="resetTicTac()" style="width: 100%; padding: 15px; font-size: 1.1rem;">üîÑ New Game</button>
        <div style="text-align: center; margin-top: 15px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 5px;">ü§ñ AI Difficulty: Impossible</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem;">Using Minimax algorithm with perfect play</div>
        </div>
      </div>
    </div>

    <!-- Zombie Survival Shooter -->
    <div class="demo-card" data-category="impressive games">
      <div class="demo-header">
        <i class="fas fa-skull demo-icon"></i>
        <h3>‚≠ê Zombie Survival Shooter</h3>
      </div>
      <div class="demo-content">
        <p>Survive waves of zombies! Collect ammo, health packs, and weapons. Top-down shooter with inventory system.</p>
        <canvas id="zombieCanvas" width="700" height="500" style="width: 100%; max-width: 700px; height: auto; aspect-ratio: 7/5; border: 3px solid var(--primary-color); border-radius: 10px; background: linear-gradient(135deg, #1a1a2e, #0f0f1e); display: block; margin: 0 auto;"></canvas>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 20px 0; text-align: center;">
          <div style="padding: 15px; background: rgba(16,185,129,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: #10b981;" id="zombieWave">1</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Wave</div>
          </div>
          <div style="padding: 15px; background: rgba(239,68,68,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: #ef4444;" id="zombieHealth">100</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Health</div>
          </div>
          <div style="padding: 15px; background: rgba(245,158,11,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: #f59e0b;" id="zombieAmmo">30</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Ammo</div>
          </div>
          <div style="padding: 15px; background: rgba(168,85,247,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: #a855f7;" id="zombieScore">0</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Score</div>
          </div>
        </div>
        <div style="padding: 15px; background: rgba(0,217,255,0.05); border-radius: 10px; margin: 15px 0;">
          <div style="color: var(--primary-color); font-weight: bold; margin-bottom: 10px;">üéí Inventory:</div>
          <div id="zombieInventory" style="display: flex; gap: 10px; flex-wrap: wrap;"></div>
        </div>
        <div style="padding: 15px; background: rgba(255,0,0,0.05); border-radius: 10px; margin: 15px 0;">
          <div style="color: #ff0000; font-weight: bold; margin-bottom: 10px;">‚ö° Active Power-ups:</div>
          <div id="zombiePowerups" style="display: flex; gap: 10px; flex-wrap: wrap; min-height: 30px; align-items: center; color: var(--text-secondary); font-size: 0.9rem;">
            <span>None active</span>
          </div>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 15px;">
          <button class="btn" onclick="startZombieGame()" style="flex: 1;">üéÆ Start Game</button>
          <button class="btn" onclick="pauseZombieGame()" style="flex: 1;">‚è∏Ô∏è Pause</button>
        </div>
        <div style="margin-top: 15px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 8px;">üéØ Controls & Power-ups:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            <strong>WASD:</strong> Move &nbsp;|&nbsp; <strong>Mouse:</strong> Aim &nbsp;|&nbsp; <strong>Click:</strong> Shoot &nbsp;|&nbsp; <strong>R:</strong> Reload<br>
            <strong>1-4:</strong> Switch Weapons &nbsp;|&nbsp; <strong>E:</strong> Pick Up Items<br>
            <strong>Power-ups:</strong> üî• Minigun (auto-fire) ‚Ä¢ ‚ö° Rapid Fire ‚Ä¢ üõ°Ô∏è Shield ‚Ä¢ üí® Speed Boost
          </div>
        </div>
      </div>
    </div>

    <!-- AI Drawing Guesser -->
    <div class="demo-card" data-category="impressive ai">
      <div class="demo-header">
        <i class="fas fa-paint-brush demo-icon"></i>
        <h3>‚≠ê AI Drawing Guesser</h3>
      </div>
      <div class="demo-content">
        <p>Draw something and let the AI guess! Or let AI draw and you guess. Advanced pattern recognition!</p>
        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
          <button class="btn" id="modePlayer" onclick="setGuessMode('player')" style="flex: 1; background: var(--primary-color);">‚úèÔ∏è You Draw</button>
          <button class="btn" id="modeAI" onclick="setGuessMode('ai')" style="flex: 1;">ü§ñ AI Draws</button>
        </div>
        <canvas id="guessCanvas" width="600" height="400" style="width: 100%; max-width: 600px; height: auto; aspect-ratio: 3/2; border: 3px solid var(--primary-color); border-radius: 10px; background: white; display: block; margin: 0 auto; cursor: crosshair;"></canvas>
        <div style="margin: 20px 0;">
          <div id="playerDrawMode" style="display: block;">
            <div style="padding: 15px; background: rgba(0,217,255,0.1); border-radius: 10px; margin-bottom: 15px;">
              <div style="color: var(--primary-color); font-weight: bold; margin-bottom: 10px;">üéØ Draw this:</div>
              <div id="drawPrompt" style="font-size: 1.5rem; color: white; font-weight: bold;">Cat</div>
            </div>
            <input type="text" id="secretWord" placeholder="Enter what you're drawing..." style="width: 100%; padding: 12px; background: rgba(255,255,255,0.05); border: 2px solid rgba(0,217,255,0.3); border-radius: 8px; color: white; font-size: 1rem; margin-bottom: 15px;">
            <div id="aiGuesses" style="padding: 15px; background: rgba(168,85,247,0.05); border-radius: 10px; min-height: 100px;">
              <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 10px;">ü§ñ AI's Guesses:</div>
              <div id="guessList" style="color: var(--text-secondary);"></div>
            </div>
          </div>
          <div id="aiDrawMode" style="display: none;">
            <div style="padding: 15px; background: rgba(168,85,247,0.1); border-radius: 10px; margin-bottom: 15px;">
              <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 10px;">ü§ñ AI is drawing...</div>
              <div id="aiDrawingHint" style="color: var(--text-secondary);">Watch carefully and guess what it is!</div>
            </div>
            <input type="text" id="playerGuess" placeholder="What is the AI drawing?" style="width: 100%; padding: 12px; background: rgba(255,255,255,0.05); border: 2px solid rgba(168,85,247,0.3); border-radius: 8px; color: white; font-size: 1rem; margin-bottom: 15px;">
            <button class="btn" onclick="submitPlayerGuess()" style="width: 100%;">üéØ Submit Guess</button>
            <div id="guessResult" style="margin-top: 15px; padding: 15px; border-radius: 10px; display: none;"></div>
          </div>
        </div>
        <div style="display: flex; gap: 10px;">
          <button class="btn" onclick="clearGuessCanvas()" style="flex: 1;">üóëÔ∏è Clear</button>
          <button class="btn" onclick="newGuessRound()" style="flex: 1;">üîÑ New Round</button>
        </div>
        <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
          <div style="padding: 12px; background: rgba(16,185,129,0.1); border-radius: 8px;">
            <div style="font-size: 1.5rem; color: #10b981;" id="correctGuesses">0</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Correct</div>
          </div>
          <div style="padding: 12px; background: rgba(245,158,11,0.1); border-radius: 8px;">
            <div style="font-size: 1.5rem; color: #f59e0b;" id="totalRounds">0</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Rounds</div>
          </div>
          <div style="padding: 12px; background: rgba(168,85,247,0.1); border-radius: 8px;">
            <div style="font-size: 1.5rem; color: #a855f7;" id="accuracy">0%</div>
            <div style="color: var(--text-secondary); font-size: 0.85rem;">Accuracy</div>
          </div>
        </div>
      </div>
    </div>

    <!-- AI Hide and Seek -->
    <div class="demo-card" data-category="impressive ai">
      <div class="demo-header">
        <i class="fas fa-user-secret demo-icon"></i>
        <h3>‚≠ê AI Hide & Seek</h3>
      </div>
      <div class="demo-content">
        <p>Play hide and seek against intelligent AI with line-of-sight detection! AI chases when it sees you, patrols when you're hidden. New random map each game! Use WASD to move.</p>
        <canvas id="hideSeekCanvas" width="600" height="400" style="width: 100%; max-width: 600px; height: auto; aspect-ratio: 3/2; border: 3px solid var(--primary-color); border-radius: 10px; background: #1a1a2e; display: block; margin: 0 auto;"></canvas>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; text-align: center;">
          <div style="padding: 15px; background: rgba(0,217,255,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: var(--primary-color);" id="hideSeekTime">30</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Time Left</div>
          </div>
          <div style="padding: 15px; background: rgba(16,185,129,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: #10b981;" id="hideSeekWins">0</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Times Hidden</div>
          </div>
          <div style="padding: 15px; background: rgba(239,68,68,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: #ef4444;" id="hideSeekLosses">0</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Times Found</div>
          </div>
        </div>
        <div style="padding: 15px; background: rgba(168,85,247,0.1); border-radius: 10px; margin: 15px 0;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 10px;">ü§ñ AI Status:</div>
          <div id="aiStatus" style="color: var(--text-secondary);">Click Start to begin!</div>
        </div>
        <div style="display: flex; gap: 10px;">
          <button class="btn" onclick="startHideSeek()" style="flex: 1;">üéÆ Start Game</button>
          <button class="btn" onclick="toggleHideSeekDifficulty()" style="flex: 1;">‚öôÔ∏è Difficulty: <span id="aiDifficulty">Medium</span></button>
        </div>
        <div style="margin-top: 15px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 8px;">üéØ How to Play:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            <strong>WASD/Arrow Keys:</strong> Move your character (green circle)<br>
            <strong>Goal:</strong> Hide from the AI seeker (red circle) for 30 seconds!<br>
            <strong>AI Features:</strong> A* pathfinding, memory of your spots, predictive search patterns
          </div>
        </div>
      </div>
    </div>

    <!-- Advanced RPG Adventure - Full Width -->
    <div class="demo-card" data-category="impressive games" style="grid-column: 1 / -1;">
      <div class="demo-header">
        <i class="fas fa-shield-alt demo-icon"></i>
        <h3>‚≠ê Epic RPG Adventure - Open World</h3>
      </div>
      <div class="demo-content">
        <p style="margin-bottom: 15px;">Full-featured RPG with open world exploration, real-time combat with timing mechanics, quests, NPCs, dungeons, and epic boss fights! Use WASD or Arrow Keys to move.</p>
        
        <!-- Main Game Container -->
        <div style="display: grid; grid-template-columns: 250px 1fr 280px; gap: 15px; min-height: 600px;">
          
          <!-- Left Panel: Character & Equipment -->
          <div style="background: rgba(0,217,255,0.05); border-radius: 10px; padding: 15px; overflow-y: auto; max-height: 600px;">
            <div style="text-align: center; margin-bottom: 15px;">
              <div style="width: 80px; height: 80px; margin: 0 auto; background: linear-gradient(135deg, #00d9ff, #a855f7); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 2.5rem; position: relative; box-shadow: 0 0 30px rgba(0,217,255,0.6); animation: pulse 2s infinite;">
                <span id="heroEmoji">üó°Ô∏è</span>
                <div style="position: absolute; bottom: -5px; right: -5px; width: 28px; height: 28px; background: linear-gradient(135deg, #f59e0b, #ef4444); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; color: white; font-weight: bold; border: 3px solid #0f172a;" id="heroLevelBadge">1</div>
              </div>
              <div style="color: white; font-size: 1.1rem; margin-top: 10px; font-weight: bold;" id="heroName">Hero</div>
              <div style="color: var(--text-secondary); font-size: 0.8rem;">
                <span id="heroClass">Adventurer</span>
              </div>
              <div style="width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 10px; margin-top: 8px; overflow: hidden; border: 1px solid rgba(0,217,255,0.3);">
                <div id="xpBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #f59e0b, #ef4444); transition: width 0.5s; box-shadow: 0 0 10px rgba(245,158,11,0.8);"></div>
              </div>
              <div style="color: var(--text-secondary); font-size: 0.75rem; margin-top: 4px;">
                XP: <span id="heroXP">0</span>/<span id="heroXPNext">100</span>
              </div>
            </div>
            
            <div style="display: grid; gap: 8px; font-size: 0.9rem; margin-bottom: 15px;">
              <div style="display: flex; justify-content: space-between; padding: 8px 10px; background: rgba(239,68,68,0.15); border-radius: 6px; border: 1px solid rgba(239,68,68,0.3);">
                <span style="color: #ef4444;">‚ù§Ô∏è HP</span>
                <span style="color: white; font-weight: bold;" id="heroHealth">100/100</span>
              </div>
              <div style="display: flex; justify-content: space-between; padding: 8px 10px; background: rgba(59,130,246,0.15); border-radius: 6px; border: 1px solid rgba(59,130,246,0.3);">
                <span style="color: #3b82f6;">üíß MP</span>
                <span style="color: white; font-weight: bold;" id="heroMana">50/50</span>
              </div>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <div style="padding: 8px; background: rgba(245,158,11,0.15); border-radius: 6px; text-align: center; border: 1px solid rgba(245,158,11,0.3);">
                  <div style="color: #f59e0b; font-size: 0.75rem;">‚öîÔ∏è ATK</div>
                  <div style="color: white; font-weight: bold; font-size: 1.1rem;" id="heroAttack">10</div>
                </div>
                <div style="padding: 8px; background: rgba(16,185,129,0.15); border-radius: 6px; text-align: center; border: 1px solid rgba(16,185,129,0.3);">
                  <div style="color: #10b981; font-size: 0.75rem;">üõ°Ô∏è DEF</div>
                  <div style="color: white; font-weight: bold; font-size: 1.1rem;" id="heroDefense">5</div>
                </div>
              </div>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <div style="padding: 8px; background: rgba(245,158,11,0.15); border-radius: 6px; text-align: center; border: 1px solid rgba(245,158,11,0.3);">
                  <div style="color: #f59e0b; font-size: 0.75rem;">üí∞ Gold</div>
                  <div style="color: white; font-weight: bold; font-size: 1.1rem;" id="heroGold">100</div>
                </div>
                <div style="padding: 8px; background: rgba(168,85,247,0.15); border-radius: 6px; text-align: center; border: 1px solid rgba(168,85,247,0.3);">
                  <div style="color: #a855f7; font-size: 0.75rem;">ÔøΩ Kills</div>
                  <div style="color: white; font-weight: bold; font-size: 1.1rem;" id="killCount">0</div>
                </div>
              </div>
            </div>
            
            <h4 style="color: var(--primary-color); margin: 0 0 8px 0; font-size: 0.95rem; border-bottom: 2px solid rgba(0,217,255,0.3); padding-bottom: 6px;">üéí Equipment</h4>
            <div id="equipmentSlots" style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 0.75rem; margin-bottom: 15px;"></div>
            
            <h4 style="color: var(--secondary-color); margin: 0 0 8px 0; font-size: 0.95rem; border-bottom: 2px solid rgba(168,85,247,0.3); padding-bottom: 6px;">‚ú® Skills</h4>
            <div id="skillButtons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 0.75rem;"></div>
            
            <button class="btn" onclick="openInventoryMenu()" style="width: 100%; background: linear-gradient(135deg, #a855f7, #8b5cf6); padding: 10px; font-size: 0.9rem; margin-top: 15px;">üì¶ Open Inventory</button>
          </div>
          
          <!-- Center: Game World Canvas -->
          <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 10px; position: relative;">
            <div style="position: absolute; top: 15px; left: 15px; z-index: 10; background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 8px; border: 2px solid rgba(0,217,255,0.4);">
              <div style="color: var(--primary-color); font-size: 0.85rem; font-weight: bold; margin-bottom: 4px;">üìç Current Location</div>
              <div id="currentLocation" style="color: white; font-size: 0.9rem;">Town Square</div>
            </div>
            
            <div style="position: absolute; top: 15px; right: 15px; z-index: 10; background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 8px; border: 2px solid rgba(245,158,11,0.4); display: none;" id="npcInteraction">
              <div style="color: #f59e0b; font-size: 0.8rem; font-weight: bold;">Press SPACE to interact</div>
            </div>
            
            <canvas id="rpgWorldCanvas" width="900" height="600" style="width: 100%; height: 100%; border-radius: 8px; cursor: crosshair; background: linear-gradient(135deg, #1a3a1a, #0f1f0f); image-rendering: pixelated;"></canvas>
            
            <div style="position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); padding: 10px 20px; border-radius: 10px; border: 2px solid rgba(0,217,255,0.5); display: none;" id="combatHUD">
              <div style="text-align: center; margin-bottom: 8px;">
                <div style="color: #ef4444; font-size: 1rem; font-weight: bold;" id="enemyNameDisplay">Enemy</div>
                <div style="width: 300px; height: 12px; background: rgba(255,255,255,0.1); border-radius: 10px; margin: 6px auto; overflow: hidden; border: 1px solid rgba(239,68,68,0.5);">
                  <div id="enemyHealthBar" style="height: 100%; width: 100%; background: linear-gradient(90deg, #ef4444, #dc2626); transition: width 0.3s;"></div>
                </div>
                <div style="color: white; font-size: 0.85rem;" id="enemyHPText">100/100</div>
              </div>
              <div style="color: var(--text-secondary); font-size: 0.75rem; text-align: center; margin-top: 8px;">
                Click when the timing indicator is in the <span style="color: #10b981;">green zone</span> for critical hits!
              </div>
            </div>
            
            <div style="position: absolute; bottom: 15px; left: 15px; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 8px; border: 2px solid rgba(168,85,247,0.4);">
              <div style="color: var(--text-secondary); font-size: 0.75rem; line-height: 1.4;">
                <div><strong style="color: #00d9ff;">WASD / Arrows:</strong> Move</div>
                <div><strong style="color: #00d9ff;">SPACE:</strong> Interact/Attack</div>
                <div><strong style="color: #00d9ff;">E:</strong> Open Inventory</div>
                <div><strong style="color: #00d9ff;">M:</strong> Toggle Map</div>
              </div>
            </div>
          </div>
          
          <!-- Right Panel: Quest Log & Map -->
          <div style="display: flex; flex-direction: column; gap: 15px; overflow-y: auto; max-height: 600px;">
            
            <!-- Mini Map -->
            <div style="background: rgba(168,85,247,0.05); border-radius: 10px; padding: 12px; border: 2px solid rgba(168,85,247,0.2);">
              <h4 style="color: var(--secondary-color); margin: 0 0 10px 0; font-size: 0.95rem;">üó∫Ô∏è World Map</h4>
              <canvas id="miniMap" width="250" height="250" style="width: 100%; border-radius: 8px; background: rgba(0,0,0,0.3); border: 2px solid rgba(168,85,247,0.3);"></canvas>
              <div style="margin-top: 8px; font-size: 0.75rem; color: var(--text-secondary);">
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                  <span>üü¢ You</span>
                  <span>üî¥ Enemies</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                  <span>üü° NPCs</span>
                  <span>üíé Treasure</span>
                </div>
              </div>
            </div>
            
            <!-- Active Quest -->
            <div id="questPanel" style="background: rgba(245,158,11,0.05); border-radius: 10px; padding: 12px; border: 2px solid rgba(245,158,11,0.2);">
              <h4 style="color: #f59e0b; margin: 0 0 10px 0; font-size: 0.95rem;">üéØ Active Quest</h4>
              <div id="questTitle" style="color: white; font-weight: bold; font-size: 0.9rem; margin-bottom: 6px;">No active quest</div>
              <div id="questDescription" style="color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 10px; line-height: 1.4;">Explore the world to find quests!</div>
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="flex: 1; height: 8px; background: rgba(255,255,255,0.1); border-radius: 10px; margin-right: 10px; overflow: hidden; border: 1px solid rgba(245,158,11,0.3);">
                  <div id="questProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #10b981, #059669); transition: width 0.3s;"></div>
                </div>
                <span id="questProgressText" style="color: #10b981; font-size: 0.85rem; font-weight: bold;">0/5</span>
              </div>
              <div id="questReward" style="margin-top: 8px; padding: 8px; background: rgba(245,158,11,0.1); border-radius: 6px; font-size: 0.8rem; color: #f59e0b;">
                
              </div>
            </div>
            
            <!-- Game Log -->
            <div style="background: rgba(0,217,255,0.05); border-radius: 10px; padding: 12px; border: 2px solid rgba(0,217,255,0.2); flex: 1;">
              <h4 style="color: var(--primary-color); margin: 0 0 10px 0; font-size: 0.95rem;">üìú Adventure Log</h4>
              <div id="gameLog" style="background: rgba(0,0,0,0.4); border-radius: 6px; padding: 10px; min-height: 180px; max-height: 250px; overflow-y: auto; font-size: 0.8rem; line-height: 1.5;">
                <div style="color: var(--primary-color); font-weight: bold;">üåü Welcome to the Epic RPG Adventure!</div>
                <div style="color: white; margin-top: 6px;">Use WASD or Arrow Keys to explore the open world.</div>
                <div style="color: var(--text-secondary); margin-top: 4px;">Find NPCs, battle enemies, complete quests, and discover treasure!</div>
              </div>
            </div>
            
            <!-- Quick Stats -->
            <div style="background: rgba(16,185,129,0.05); border-radius: 10px; padding: 10px; border: 2px solid rgba(16,185,129,0.2);">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.8rem;">
                <div style="text-align: center; padding: 6px; background: rgba(239,68,68,0.1); border-radius: 6px;">
                  <div style="color: #ef4444; font-size: 1.2rem; font-weight: bold;" id="dungeonsClearedStat">0</div>
                  <div style="color: var(--text-secondary); font-size: 0.7rem;">Dungeons</div>
                </div>
                <div style="text-align: center; padding: 6px; background: rgba(168,85,247,0.1); border-radius: 6px;">
                  <div style="color: #a855f7; font-size: 1.2rem; font-weight: bold;" id="treasuresFoundStat">0</div>
                  <div style="color: var(--text-secondary); font-size: 0.7rem;">Treasures</div>
                </div>
                <div style="text-align: center; padding: 6px; background: rgba(245,158,11,0.1); border-radius: 6px;">
                  <div style="color: #f59e0b; font-size: 1.2rem; font-weight: bold;" id="questsCompletedStat">0</div>
                  <div style="color: var(--text-secondary); font-size: 0.7rem;">Quests</div>
                </div>
                <div style="text-align: center; padding: 6px; background: rgba(0,217,255,0.1); border-radius: 6px;">
                  <div style="color: #00d9ff; font-size: 1.2rem; font-weight: bold;" id="playtimeStat">0m</div>
                  <div style="color: var(--text-secondary); font-size: 0.7rem;">Playtime</div>
                </div>
              </div>
            </div>
            
          </div>
        </div>
        
        <!-- Item Tooltip -->
        <div id="itemTooltip" style="display: none; position: fixed; background: rgba(0,0,0,0.95); border: 2px solid var(--primary-color); border-radius: 10px; padding: 12px; min-width: 220px; z-index: 1000; box-shadow: 0 0 30px rgba(0,217,255,0.5);"></div>
        
        <!-- Inventory Modal -->
        <div id="inventoryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 2000; padding: 40px; overflow-y: auto;">
          <div style="max-width: 1000px; margin: 0 auto; background: linear-gradient(135deg, #1a1a2e, #16213e); border-radius: 15px; padding: 30px; border: 3px solid var(--primary-color); box-shadow: 0 0 50px rgba(0,217,255,0.5);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
              <h2 style="color: var(--primary-color); margin: 0;">üéí Inventory & Equipment</h2>
              <button onclick="closeInventoryMenu()" class="btn" style="padding: 8px 16px;">‚úñ Close</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px;">
              <div>
                <h3 style="color: var(--secondary-color); font-size: 1.1rem; margin-bottom: 10px;">Backpack (<span id="invModalCount">0</span>/48)</h3>
                <div id="inventoryModalGrid" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 8px; margin-bottom: 15px;"></div>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                  <button class="btn" onclick="generateRandomLoot()" style="padding: 10px; font-size: 0.9rem;">üé≤ Find Loot</button>
                  <button class="btn" onclick="openShop()" style="padding: 10px; font-size: 0.9rem;">üè™ Shop</button>
                  <button class="btn" onclick="craftItem()" style="padding: 10px; font-size: 0.9rem;">üî® Craft</button>
                  <button class="btn" onclick="sellAllJunk()" style="padding: 10px; font-size: 0.9rem;">üí∞ Sell Junk</button>
                </div>
              </div>
              
              <div style="background: rgba(0,217,255,0.05); border-radius: 10px; padding: 15px;">
                <h3 style="color: var(--primary-color); font-size: 1.1rem; margin-bottom: 15px;">Equipment</h3>
                <div id="equipmentModalSlots" style="display: grid; gap: 10px;"></div>
              </div>
            </div>
          </div>
        </div>
        
      </div>
    </div>

    <!-- Tower Defense Strategy -->
    <div class="demo-card" data-category="impressive games">
      <div class="demo-header">
        <i class="fas fa-tower-broadcast demo-icon"></i>
        <h3>‚≠ê Tower Defense Strategy</h3>
      </div>
      <div class="demo-content">
        <p>Strategic tower defense! Place towers, upgrade them, manage resources. Multiple enemy types and tower upgrades!</p>
        <canvas id="towerCanvas" width="1000" height="600" style="width: 100%; height: auto; border: 3px solid var(--primary-color); border-radius: 10px; background: linear-gradient(135deg, #1a4d2e, #0a2f1e); display: block; margin: 0 auto; cursor: pointer;"></canvas>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 20px 0; text-align: center;">
          <div style="padding: 15px; background: rgba(239,68,68,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: #ef4444;" id="towerLives">20</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Lives</div>
          </div>
          <div style="padding: 15px; background: rgba(245,158,11,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: #f59e0b;" id="towerGold">100</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Gold</div>
          </div>
          <div style="padding: 15px; background: rgba(0,217,255,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: var(--primary-color);" id="towerWave">1</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Wave</div>
          </div>
          <div style="padding: 15px; background: rgba(168,85,247,0.1); border-radius: 10px;">
            <div style="font-size: 1.8rem; color: var(--secondary-color);" id="towerScore">0</div>
            <div style="color: var(--text-secondary); font-size: 0.9rem;">Score</div>
          </div>
        </div>
        <div style="background: rgba(0,217,255,0.05); border-radius: 10px; padding: 20px; margin-bottom: 15px;">
          <h4 style="color: var(--primary-color); margin-bottom: 15px;">üèπ Build Towers</h4>
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
            <button class="btn" onclick="selectTowerType('basic')" style="padding: 15px;">
              <div style="font-size: 1.5rem;">üèπ</div>
              <div style="font-size: 0.9rem; margin-top: 5px;">Arrow Tower</div>
              <div style="color: #f59e0b; font-size: 0.85rem;">50 Gold</div>
            </button>
            <button class="btn" onclick="selectTowerType('cannon')" style="padding: 15px;">
              <div style="font-size: 1.5rem;">üí£</div>
              <div style="font-size: 0.9rem; margin-top: 5px;">Cannon Tower</div>
              <div style="color: #f59e0b; font-size: 0.85rem;">100 Gold</div>
            </button>
            <button class="btn" onclick="selectTowerType('magic')" style="padding: 15px;">
              <div style="font-size: 1.5rem;">‚ú®</div>
              <div style="font-size: 0.9rem; margin-top: 5px;">Magic Tower</div>
              <div style="color: #f59e0b; font-size: 0.85rem;">150 Gold</div>
            </button>
          </div>
        </div>
        <div style="display: flex; gap: 10px;">
          <button class="btn" onclick="startTowerWave()" style="flex: 1;">‚ñ∂Ô∏è Start Wave</button>
          <button class="btn" onclick="upgradeTower()" style="flex: 1;">‚¨ÜÔ∏è Upgrade Selected</button>
          <button class="btn" onclick="sellTower()" style="flex: 1;">üí∞ Sell Tower</button>
        </div>
        <div style="margin-top: 15px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 8px;">üéØ Strategy Tips:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            <strong>Arrow Towers:</strong> Fast attack, low damage (good early game)<br>
            <strong>Cannon Towers:</strong> Area damage, slow attack (groups of enemies)<br>
            <strong>Magic Towers:</strong> High damage, slowing effect (tough enemies)
          </div>
        </div>
      </div>
    </div>

    <!-- WebAssembly Performance Benchmark -->
    <div class="demo-card" data-category="impressive advanced">
      <div class="demo-header">
        <i class="fas fa-rocket demo-icon"></i>
        <h3>‚≠ê WebAssembly Benchmark</h3>
      </div>
      <div class="demo-content">
        <p>Compare JavaScript vs WebAssembly performance with real-time benchmarks. See 2-10x speedups with WASM optimization!</p>
        <a href="wasm-benchmark.html" target="_blank" class="btn" style="width: 100%; justify-content: center; text-decoration: none; margin-top: 15px;">
          <i class="fas fa-external-link-alt"></i> Launch WebAssembly Benchmark
        </a>
        <div style="margin-top: 20px; padding: 15px; background: rgba(0,217,255,0.05); border-left: 4px solid var(--primary-color); border-radius: 8px;">
          <div style="color: var(--primary-color); font-weight: bold; margin-bottom: 8px;">‚ú® Features:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            ‚Ä¢ Sorting benchmark (arrays 10k-500k elements)<br>
            ‚Ä¢ Matrix multiplication (100x100-500x500)<br>
            ‚Ä¢ Image processing (grayscale filters)<br>
            ‚Ä¢ Real-time Chart.js performance graphs<br>
            ‚Ä¢ Configurable data sizes
          </div>
        </div>
      </div>
    </div>

    <!-- Computer Vision AI Demo -->
    <div class="demo-card" data-category="impressive advanced ai">
      <div class="demo-header">
        <i class="fas fa-eye demo-icon"></i>
        <h3>‚≠ê Computer Vision AI</h3>
      </div>
      <div class="demo-content">
        <p>Real-time ML computer vision with TensorFlow.js. Object detection, pose estimation, face landmarks, and hand tracking!</p>
        <a href="computer-vision.html" target="_blank" class="btn" style="width: 100%; justify-content: center; text-decoration: none; margin-top: 15px;">
          <i class="fas fa-external-link-alt"></i> Launch Computer Vision Demo
        </a>
        <div style="margin-top: 20px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 8px;">ü§ñ AI Models:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            ‚Ä¢ COCO-SSD Object Detection<br>
            ‚Ä¢ MoveNet Pose Estimation<br>
            ‚Ä¢ FaceMesh Landmarks (468 points)<br>
            ‚Ä¢ HandPose Detection<br>
            ‚Ä¢ Real-time webcam processing with Canvas overlay
          </div>
        </div>
      </div>
    </div>

    <!-- GraphQL API Playground -->
    <div class="demo-card" data-category="impressive advanced">
      <div class="demo-header">
        <i class="fas fa-code-branch demo-icon"></i>
        <h3>‚≠ê GraphQL Playground</h3>
      </div>
      <div class="demo-content">
        <p>Interactive GraphQL API explorer with live schema introspection. Query real APIs (SpaceX, GitHub, Countries) with performance metrics!</p>
        <a href="graphql-playground.html" target="_blank" class="btn" style="width: 100%; justify-content: center; text-decoration: none; margin-top: 15px;">
          <i class="fas fa-external-link-alt"></i> Launch GraphQL Playground
        </a>
        <div style="margin-top: 20px; padding: 15px; background: rgba(245,158,11,0.05); border-left: 4px solid var(--accent-color); border-radius: 8px;">
          <div style="color: var(--accent-color); font-weight: bold; margin-bottom: 8px;">üöÄ Capabilities:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            ‚Ä¢ Live schema explorer with autocomplete<br>
            ‚Ä¢ Query editor with syntax formatting<br>
            ‚Ä¢ Connected to real public APIs<br>
            ‚Ä¢ Performance metrics (response time, data size)<br>
            ‚Ä¢ JSON syntax highlighting
          </div>
        </div>
      </div>
    </div>

    <!-- WebGPU 3D Renderer -->
    <div class="demo-card" data-category="impressive advanced">
      <div class="demo-header">
        <i class="fas fa-cube demo-icon"></i>
        <h3>‚≠ê WebGPU Ray Tracer</h3>
      </div>
      <div class="demo-content">
        <p>Real-time 3D rendering with ray tracing, reflections, shadows, and physics simulation. GPU-accelerated graphics at 60+ FPS!</p>
        <a href="webgpu-renderer.html" target="_blank" class="btn" style="width: 100%; justify-content: center; text-decoration: none; margin-top: 15px;">
          <i class="fas fa-external-link-alt"></i> Launch WebGPU Renderer
        </a>
        <div style="margin-top: 20px; padding: 15px; background: rgba(0,217,255,0.05); border-left: 4px solid var(--primary-color); border-radius: 8px;">
          <div style="color: var(--primary-color); font-weight: bold; margin-bottom: 8px;">‚ö° Features:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            ‚Ä¢ Real-time ray tracing with reflections<br>
            ‚Ä¢ Dynamic lighting and shadows<br>
            ‚Ä¢ Physics simulation (gravity, collisions)<br>
            ‚Ä¢ Adjustable camera, lighting, materials<br>
            ‚Ä¢ WebGL fallback for compatibility
          </div>
        </div>
      </div>
    </div>

    <!-- Infrastructure as Code Playground -->
    <div class="demo-card" data-category="impressive advanced">
      <div class="demo-header">
        <i class="fas fa-cloud demo-icon"></i>
        <h3>‚≠ê IaC Playground</h3>
      </div>
      <div class="demo-content">
        <p>Visual Infrastructure as Code builder! Drag-and-drop AWS/Azure/GCP resources, auto-generate Terraform & CloudFormation templates.</p>
        <a href="iac-playground.html" target="_blank" class="btn" style="width: 100%; justify-content: center; text-decoration: none; margin-top: 15px;">
          <i class="fas fa-external-link-alt"></i> Launch IaC Playground
        </a>
        <div style="margin-top: 20px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 8px;">‚òÅÔ∏è Features:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            ‚Ä¢ Drag-and-drop visual designer<br>
            ‚Ä¢ Multi-cloud support (AWS, Azure, GCP)<br>
            ‚Ä¢ Auto-generate Terraform & CloudFormation<br>
            ‚Ä¢ Real-time dependency graph visualization<br>
            ‚Ä¢ 11+ resource types (EC2, Lambda, S3, RDS, etc.)
          </div>
        </div>
      </div>
    </div>

    <!-- AI Model Training Lab -->
    <div class="demo-card" data-category="impressive advanced ai">
      <div class="demo-header">
        <i class="fas fa-brain demo-icon"></i>
        <h3>‚≠ê AI Model Training Lab</h3>
      </div>
      <div class="demo-content">
        <p>Train neural networks in real-time with visual architecture builder! Includes CNN training, multi-agent AI pipeline with LangChain-style orchestration.</p>
        <a href="ai-model-training.html" target="_blank" class="btn" style="width: 100%; justify-content: center; text-decoration: none; margin-top: 15px;">
          <i class="fas fa-external-link-alt"></i> Launch AI Training Lab
        </a>
        <div style="margin-top: 20px; padding: 15px; background: rgba(0,217,255,0.05); border-left: 4px solid var(--primary-color); border-radius: 8px;">
          <div style="color: var(--primary-color); font-weight: bold; margin-bottom: 8px;">üß† Features:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            ‚Ä¢ Train custom neural networks with TensorFlow.js<br>
            ‚Ä¢ Visual network architecture builder<br>
            ‚Ä¢ Live loss/accuracy graphs during training<br>
            ‚Ä¢ MNIST digit classification with CNN<br>
            ‚Ä¢ Multi-agent AI pipeline (sentiment, summarization, NLP)<br>
            ‚Ä¢ Real-time model testing & predictions
          </div>
        </div>
      </div>
    </div>

    <!-- Natural Language to SQL Studio -->
    <div class="demo-card" data-category="impressive advanced ai">
      <div class="demo-header">
        <i class="fas fa-database demo-icon"></i>
        <h3>‚≠ê NL to SQL Studio</h3>
      </div>
      <div class="demo-content">
        <p>Convert plain English to SQL queries! Interactive database with 50K+ records, schema visualization, and real-time query execution.</p>
        <a href="nl-to-sql.html" target="_blank" class="btn" style="width: 100%; justify-content: center; text-decoration: none; margin-top: 15px;">
          <i class="fas fa-external-link-alt"></i> Launch SQL Studio
        </a>
        <div style="margin-top: 20px; padding: 15px; background: rgba(168,85,247,0.05); border-left: 4px solid var(--secondary-color); border-radius: 8px;">
          <div style="color: var(--secondary-color); font-weight: bold; margin-bottom: 8px;">üíæ Features:</div>
          <div style="color: var(--text-secondary); font-size: 0.9rem; line-height: 1.6;">
            ‚Ä¢ Natural language query parsing<br>
            ‚Ä¢ Rich e-commerce database (7 tables, 50K+ rows)<br>
            ‚Ä¢ SQL syntax highlighting & explanation<br>
            ‚Ä¢ Real-time query execution with SQL.js<br>
            ‚Ä¢ Interactive schema visualization<br>
            ‚Ä¢ Query optimization suggestions & metrics
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Matrix Rain Effect
    const canvas = document.getElementById('matrix-canvas');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()';
    const fontSize = 14;
    const columns = canvas.width / fontSize;
    const drops = Array(Math.floor(columns)).fill(1);

    function drawMatrix() {
      ctx.fillStyle = 'rgba(10, 10, 15, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#00d9ff';
      ctx.font = fontSize + 'px monospace';
      
      for (let i = 0; i < drops.length; i++) {
        const text = characters.charAt(Math.floor(Math.random() * characters.length));
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);
        
        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }
        drops[i]++;
      }
    }

    setInterval(drawMatrix, 50);

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    // Typing Speed Test
    let startTime = null;
    let typingTimer = null;
    const typingInput = document.getElementById('typingInput');
    const typingText = document.getElementById('typingText').textContent;

    typingInput.addEventListener('input', () => {
      if (!startTime) {
        startTime = new Date();
        typingTimer = setInterval(updateTypingStats, 100);
      }
      updateTypingStats();
    });

    function updateTypingStats() {
      const typed = typingInput.value;
      const timePassed = (new Date() - startTime) / 1000;
      const words = typed.trim().split(/\s+/).length;
      const wpm = Math.round((words / timePassed) * 60) || 0;
      
      let correct = 0;
      for (let i = 0; i < typed.length; i++) {
        if (typed[i] === typingText[i]) correct++;
      }
      const accuracy = typed.length ? Math.round((correct / typed.length) * 100) : 100;
      
      document.getElementById('wpm').textContent = wpm;
      document.getElementById('accuracy').textContent = accuracy + '%';
      document.getElementById('time').textContent = Math.round(timePassed) + 's';
    }

    function resetTypingTest() {
      typingInput.value = '';
      startTime = null;
      clearInterval(typingTimer);
      document.getElementById('wpm').textContent = '0';
      document.getElementById('accuracy').textContent = '100%';
      document.getElementById('time').textContent = '0s';
    }

    // Color Mixer
    function updateColor() {
      const r = document.getElementById('redInput').value;
      const g = document.getElementById('greenInput').value;
      const b = document.getElementById('blueInput').value;
      
      const hex = '#' + [r, g, b].map(x => {
        const hex = parseInt(x).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }).join('');
      
      document.getElementById('colorDisplay').style.background = `linear-gradient(135deg, rgb(${r},${g},${b}), rgb(${Math.max(0, r-50)},${Math.max(0, g-50)},${Math.max(0, b-50)}))`;
      document.getElementById('hexOutput').textContent = hex.toUpperCase();
    }

    function copyColor() {
      const hex = document.getElementById('hexOutput').textContent;
      navigator.clipboard.writeText(hex);
      alert('Color code copied: ' + hex);
    }

    updateColor();

    // Calculator
    let calcExpression = '';

    function appendToCalc(value) {
      calcExpression += value;
      document.getElementById('calcDisplay').textContent = calcExpression || '0';
    }

    function clearCalc() {
      calcExpression = '';
      document.getElementById('calcDisplay').textContent = '0';
    }

    function backspace() {
      calcExpression = calcExpression.slice(0, -1);
      document.getElementById('calcDisplay').textContent = calcExpression || '0';
    }

    function calculateResult() {
      try {
        const result = eval(calcExpression);
        document.getElementById('calcDisplay').textContent = result;
        calcExpression = result.toString();
      } catch (e) {
        document.getElementById('calcDisplay').textContent = 'Error';
        calcExpression = '';
      }
    }

    // Password Generator
    function generatePassword() {
      const length = document.getElementById('lengthSlider').value;
      const upper = document.getElementById('includeUpper').checked;
      const lower = document.getElementById('includeLower').checked;
      const numbers = document.getElementById('includeNumbers').checked;
      const symbols = document.getElementById('includeSymbols').checked;
      
      let chars = '';
      if (upper) chars += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      if (lower) chars += 'abcdefghijklmnopqrstuvwxyz';
      if (numbers) chars += '0123456789';
      if (symbols) chars += '!@#$%^&*()_+-=[]{}|;:,.<>?';
      
      if (!chars) {
        alert('Please select at least one character type!');
        return;
      }
      
      let password = '';
      for (let i = 0; i < length; i++) {
        password += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      
      document.getElementById('passwordDisplay').textContent = password;
    }

    function copyPassword() {
      const password = document.getElementById('passwordDisplay').textContent;
      if (password === 'Click generate to create a password') {
        alert('Generate a password first!');
        return;
      }
      navigator.clipboard.writeText(password);
      alert('Password copied to clipboard!');
    }

    // Todo List
    let todos = [];

    function addTodo() {
      const input = document.getElementById('todoInput');
      const text = input.value.trim();
      
      if (!text) return;
      
      todos.push({ id: Date.now(), text, completed: false });
      input.value = '';
      renderTodos();
    }

    function toggleTodo(id) {
      todos = todos.map(todo => 
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      );
      renderTodos();
    }

    function deleteTodo(id) {
      todos = todos.filter(todo => todo.id !== id);
      renderTodos();
    }

    function renderTodos() {
      const list = document.getElementById('todoList');
      list.innerHTML = todos.map(todo => `
        <li class="todo-item ${todo.completed ? 'completed' : ''}">
          <input type="checkbox" ${todo.completed ? 'checked' : ''} onchange="toggleTodo(${todo.id})">
          <span>${todo.text}</span>
          <button onclick="deleteTodo(${todo.id})">Delete</button>
        </li>
      `).join('');
    }

    // JSON Formatter
    function formatJSON() {
      const input = document.getElementById('jsonInput').value;
      const output = document.getElementById('jsonOutput');
      
      try {
        const parsed = JSON.parse(input);
        output.textContent = JSON.stringify(parsed, null, 2);
        output.style.color = 'var(--text-primary)';
      } catch (e) {
        output.textContent = 'Invalid JSON: ' + e.message;
        output.style.color = '#ff3b30';
      }
    }

    function minifyJSON() {
      const input = document.getElementById('jsonInput').value;
      const output = document.getElementById('jsonOutput');
      
      try {
        const parsed = JSON.parse(input);
        output.textContent = JSON.stringify(parsed);
        output.style.color = 'var(--text-primary)';
      } catch (e) {
        output.textContent = 'Invalid JSON: ' + e.message;
        output.style.color = '#ff3b30';
      }
    }

    // Enter key support for todo
    document.getElementById('todoInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') addTodo();
    });

    // ===== MEMORY GAME =====
    let memoryCards = [];
    let flippedCards = [];
    let matchedPairs = 0;
    let memoryMoves = 0;
    let memoryTimer = null;
    let memorySeconds = 0;

    const emojis = ['üöÄ', 'üíª', 'üéÆ', 'üéØ', '‚ö°', 'üî•', 'üí°', 'üåü'];
    
    function initMemoryGame() {
      const grid = document.getElementById('memoryGrid');
      memoryCards = [...emojis, ...emojis].sort(() => Math.random() - 0.5);
      
      grid.innerHTML = memoryCards.map((emoji, index) => `
        <div class="memory-card" data-index="${index}" onclick="flipCard(${index})">
          <div class="card-inner">
            <div class="card-front">?</div>
            <div class="card-back">${emoji}</div>
          </div>
        </div>
      `).join('');
      
      // Add styles for memory cards
      if (!document.getElementById('memoryStyles')) {
        const style = document.createElement('style');
        style.id = 'memoryStyles';
        style.textContent = `
          .memory-card {
            aspect-ratio: 1;
            background: rgba(0, 217, 255, 0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.3s;
            perspective: 1000px;
          }
          .memory-card:hover { transform: scale(1.05); }
          .memory-card.flipped .card-inner { transform: rotateY(180deg); }
          .memory-card.matched { opacity: 0.5; pointer-events: none; }
          .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
          }
          .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            border-radius: 12px;
          }
          .card-front {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.2), rgba(168, 85, 247, 0.2));
          }
          .card-back {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.3), rgba(168, 85, 247, 0.3));
            transform: rotateY(180deg);
          }
        `;
        document.head.appendChild(style);
      }
    }

    function flipCard(index) {
      if (flippedCards.length === 2 || flippedCards.includes(index)) return;
      
      const card = document.querySelector(`[data-index="${index}"]`);
      card.classList.add('flipped');
      flippedCards.push(index);
      
      if (!memoryTimer) {
        memoryTimer = setInterval(() => {
          memorySeconds++;
          document.getElementById('memoryTime').textContent = memorySeconds + 's';
        }, 1000);
      }
      
      if (flippedCards.length === 2) {
        memoryMoves++;
        document.getElementById('memoryMoves').textContent = memoryMoves;
        
        setTimeout(checkMatch, 800);
      }
    }

    function checkMatch() {
      const [index1, index2] = flippedCards;
      const card1 = document.querySelector(`[data-index="${index1}"]`);
      const card2 = document.querySelector(`[data-index="${index2}"]`);
      
      if (memoryCards[index1] === memoryCards[index2]) {
        card1.classList.add('matched');
        card2.classList.add('matched');
        matchedPairs++;
        document.getElementById('memoryMatches').textContent = matchedPairs + '/8';
        
        if (matchedPairs === 8) {
          clearInterval(memoryTimer);
          setTimeout(() => alert(`üéâ You won! Moves: ${memoryMoves}, Time: ${memorySeconds}s`), 300);
        }
      } else {
        card1.classList.remove('flipped');
        card2.classList.remove('flipped');
      }
      
      flippedCards = [];
    }

    function resetMemoryGame() {
      flippedCards = [];
      matchedPairs = 0;
      memoryMoves = 0;
      memorySeconds = 0;
      clearInterval(memoryTimer);
      memoryTimer = null;
      document.getElementById('memoryMoves').textContent = '0';
      document.getElementById('memoryMatches').textContent = '0/8';
      document.getElementById('memoryTime').textContent = '0s';
      initMemoryGame();
    }

    initMemoryGame();

    // ===== STOPWATCH =====
    let stopwatchRunning = false;
    let stopwatchStartTime = 0;
    let stopwatchElapsed = 0;
    let stopwatchInterval = null;
    let lapCounter = 0;

    function startStopwatch() {
      if (stopwatchRunning) return;
      stopwatchRunning = true;
      stopwatchStartTime = Date.now() - stopwatchElapsed;
      
      stopwatchInterval = setInterval(() => {
        stopwatchElapsed = Date.now() - stopwatchStartTime;
        updateStopwatchDisplay();
      }, 10);
    }

    function stopStopwatch() {
      stopwatchRunning = false;
      clearInterval(stopwatchInterval);
    }

    function resetStopwatch() {
      stopwatchRunning = false;
      clearInterval(stopwatchInterval);
      stopwatchElapsed = 0;
      lapCounter = 0;
      updateStopwatchDisplay();
      document.getElementById('lapsContainer').innerHTML = '';
    }

    function lapStopwatch() {
      if (!stopwatchRunning) return;
      lapCounter++;
      const lapTime = formatStopwatchTime(stopwatchElapsed);
      const lapsContainer = document.getElementById('lapsContainer');
      
      const lapElement = document.createElement('div');
      lapElement.style.cssText = 'padding: 8px; margin: 5px 0; background: rgba(0,217,255,0.1); border-radius: 5px; display: flex; justify-content: space-between;';
      lapElement.innerHTML = `<span>Lap ${lapCounter}</span><span style="color: var(--primary-color); font-weight: bold;">${lapTime}</span>`;
      
      lapsContainer.insertBefore(lapElement, lapsContainer.firstChild);
    }

    function updateStopwatchDisplay() {
      document.getElementById('stopwatchDisplay').textContent = formatStopwatchTime(stopwatchElapsed);
    }

    function formatStopwatchTime(ms) {
      const hours = Math.floor(ms / 3600000);
      const minutes = Math.floor((ms % 3600000) / 60000);
      const seconds = Math.floor((ms % 60000) / 1000);
      const milliseconds = ms % 1000;
      
      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
    }

    // ===== UNIT CONVERTER =====
    const conversionData = {
      length: {
        units: ['Meters', 'Kilometers', 'Miles', 'Feet', 'Inches', 'Centimeters'],
        toBase: { Meters: 1, Kilometers: 1000, Miles: 1609.34, Feet: 0.3048, Inches: 0.0254, Centimeters: 0.01 }
      },
      weight: {
        units: ['Kilograms', 'Grams', 'Pounds', 'Ounces', 'Tons'],
        toBase: { Kilograms: 1, Grams: 0.001, Pounds: 0.453592, Ounces: 0.0283495, Tons: 1000 }
      },
      temperature: {
        units: ['Celsius', 'Fahrenheit', 'Kelvin'],
        convert: (value, from, to) => {
          let celsius = from === 'Celsius' ? value : from === 'Fahrenheit' ? (value - 32) * 5/9 : value - 273.15;
          if (to === 'Celsius') return celsius;
          if (to === 'Fahrenheit') return celsius * 9/5 + 32;
          return celsius + 273.15;
        }
      },
      data: {
        units: ['Bytes', 'Kilobytes', 'Megabytes', 'Gigabytes', 'Terabytes'],
        toBase: { Bytes: 1, Kilobytes: 1024, Megabytes: 1048576, Gigabytes: 1073741824, Terabytes: 1099511627776 }
      }
    };

    function updateConverterUnits() {
      const category = document.getElementById('converterCategory').value;
      const units = conversionData[category].units;
      
      const fromSelect = document.getElementById('converterFromUnit');
      const toSelect = document.getElementById('converterToUnit');
      
      fromSelect.innerHTML = units.map(u => `<option value="${u}" style="background: #0a0a0f; color: white;">${u}</option>`).join('');
      toSelect.innerHTML = units.map(u => `<option value="${u}" style="background: #0a0a0f; color: white;">${u}</option>`).join('');
      toSelect.selectedIndex = 1;
      
      convertUnits();
    }

    function convertUnits() {
      const category = document.getElementById('converterCategory').value;
      const value = parseFloat(document.getElementById('converterInput').value);
      const fromUnit = document.getElementById('converterFromUnit').value;
      const toUnit = document.getElementById('converterToUnit').value;
      const output = document.getElementById('converterOutput');
      
      if (isNaN(value)) {
        output.value = '';
        return;
      }
      
      let result;
      if (category === 'temperature') {
        result = conversionData.temperature.convert(value, fromUnit, toUnit);
      } else {
        const data = conversionData[category];
        const baseValue = value * data.toBase[fromUnit];
        result = baseValue / data.toBase[toUnit];
      }
      
      output.value = result.toFixed(6).replace(/\.?0+$/, '');
    }

    updateConverterUnits();

    // ===== DRAWING CANVAS =====
    const drawCanvas = document.getElementById('drawingCanvas');
    const drawCtx = drawCanvas.getContext('2d');
    let isDrawing = false;
    let eraserMode = false;
    let lastX = 0;
    let lastY = 0;

    // Set canvas size
    drawCanvas.width = drawCanvas.offsetWidth;
    drawCanvas.height = drawCanvas.offsetHeight;

    // Brush size control
    document.getElementById('brushSize').addEventListener('input', (e) => {
      document.getElementById('brushSizeValue').textContent = e.target.value + 'px';
    });

    function getCanvasCoordinates(e) {
      const rect = drawCanvas.getBoundingClientRect();
      const scaleX = drawCanvas.width / rect.width;
      const scaleY = drawCanvas.height / rect.height;
      
      let clientX, clientY;
      if (e.type.includes('touch')) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    function startDrawing(e) {
      isDrawing = true;
      const coords = getCanvasCoordinates(e);
      lastX = coords.x;
      lastY = coords.y;
    }

    function draw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      
      const coords = getCanvasCoordinates(e);
      const brushSize = document.getElementById('brushSize').value;
      const brushColor = document.getElementById('brushColor').value;
      
      drawCtx.beginPath();
      drawCtx.moveTo(lastX, lastY);
      drawCtx.lineTo(coords.x, coords.y);
      drawCtx.strokeStyle = eraserMode ? 'white' : brushColor;
      drawCtx.lineWidth = brushSize;
      drawCtx.lineCap = 'round';
      drawCtx.stroke();
      
      lastX = coords.x;
      lastY = coords.y;
    }

    function stopDrawing() {
      isDrawing = false;
    }

    // Mouse events
    drawCanvas.addEventListener('mousedown', startDrawing);
    drawCanvas.addEventListener('mousemove', draw);
    drawCanvas.addEventListener('mouseup', stopDrawing);
    drawCanvas.addEventListener('mouseout', stopDrawing);

    // Touch events
    drawCanvas.addEventListener('touchstart', startDrawing);
    drawCanvas.addEventListener('touchmove', draw);
    drawCanvas.addEventListener('touchend', stopDrawing);

    function clearCanvas() {
      drawCtx.fillStyle = 'white';
      drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
    }

    function downloadDrawing() {
      const link = document.createElement('a');
      link.download = 'my-drawing.png';
      link.href = drawCanvas.toDataURL();
      link.click();
    }

    function toggleEraser() {
      eraserMode = !eraserMode;
      const btn = document.getElementById('eraserBtn');
      btn.textContent = eraserMode ? 'Draw Mode' : 'Eraser Mode';
      btn.style.background = eraserMode ? '#ff3b30' : 'var(--accent-color)';
    }

    // Initialize canvas with white background
    clearCanvas();

    // ===== CATEGORY FILTERING =====
    function filterCategory(category) {
      const cards = document.querySelectorAll('.demo-card');
      const buttons = document.querySelectorAll('.category-btn');
      
      // Update active button
      buttons.forEach(btn => btn.classList.remove('active'));
      document.querySelector(`[data-category="${category}"]`).classList.add('active');
      
      if (category === 'all') {
        // Show grouped view for "all"
        showGroupedDemos();
      } else {
        // Show filtered cards normally
        removeGroupedDemos();
        cards.forEach(card => {
          const cardCategories = card.dataset.category.split(' ');
          if (cardCategories.includes(category)) {
            card.style.display = 'block';
            card.style.animation = 'fadeInUp 0.5s ease';
          } else {
            card.style.display = 'none';
          }
        });
        
        updateDemoCounter();
      }
    }

    function showGroupedDemos() {
      const container = document.querySelector('.showcase-grid');
      if (!container) return;
      
      const cards = Array.from(document.querySelectorAll('.demo-card[data-original]'));
      
      // Remove any existing groups
      removeGroupedDemos();
      
      // Define category groups with modern styling
      const groups = {
        'impressive': { 
          title: 'Featured & Impressive', 
          icon: '‚≠ê', 
          gradient: 'linear-gradient(135deg, #f59e0b, #ef4444)'
        },
        'games': { 
          title: 'Games & Entertainment', 
          icon: 'ÔøΩ', 
          gradient: 'linear-gradient(135deg, #8b5cf6, #ec4899)'
        },
        'utilities': { 
          title: 'Utilities & Tools', 
          icon: 'üõ†Ô∏è', 
          gradient: 'linear-gradient(135deg, #10b981, #059669)'
        },
        'creative': { 
          title: 'Creative & Visual', 
          icon: 'üé®', 
          gradient: 'linear-gradient(135deg, #06b6d4, #0891b2)'
        },
        'data-viz': { 
          title: 'Data & Visualization', 
          icon: 'ÔøΩ', 
          gradient: 'linear-gradient(135deg, #6366f1, #4f46e5)'
        },
        'ai-ml': { 
          title: 'AI & Machine Learning', 
          icon: 'ÔøΩ', 
          gradient: 'linear-gradient(135deg, #a855f7, #9333ea)'
        }
      };
      
      // Group cards by primary category (but keep them in their original DOM position!)
      const groupedCards = {};
      cards.forEach(card => {
        const categories = card.dataset.category.split(' ');
        const primaryCat = categories[0] || 'utilities';
        if (!groupedCards[primaryCat]) groupedCards[primaryCat] = [];
        groupedCards[primaryCat].push(card);
      });
      
      // Track where to insert headers (before first card of each group)
      const insertPoints = {};
      Object.keys(groups).forEach(groupKey => {
        if (groupedCards[groupKey] && groupedCards[groupKey].length > 0) {
          insertPoints[groupKey] = groupedCards[groupKey][0];
        }
      });
      
      // Create and insert category headers BEFORE first card of each group
      Object.keys(groups).forEach(groupKey => {
        if (!insertPoints[groupKey]) return;
        
        const group = groups[groupKey];
        const header = document.createElement('div');
        header.className = 'demo-group-header';
        header.style.cssText = 'grid-column: 1 / -1; margin: 40px 0 25px 0;';
        header.innerHTML = `
          <div class="category-header">
            <div class="category-icon">${group.icon}</div>
            <h2 class="category-title">${group.title}</h2>
            <div class="category-count">
              ${groupedCards[groupKey].length} ${groupedCards[groupKey].length === 1 ? 'Demo' : 'Demos'}
            </div>
          </div>
        `;
        
        // Insert header BEFORE the first card of this group (keeps cards in original position)
        container.insertBefore(header, insertPoints[groupKey]);
      });
      
      // Show all cards (they stay in their original position)
      cards.forEach(card => {
        card.style.display = 'block';
        card.style.animation = 'cardFadeIn 0.6s ease forwards';
      });
      
      updateDemoCounter();
    }

    function removeGroupedDemos() {
      const headers = document.querySelectorAll('.demo-group-header');
      headers.forEach(h => h.remove());
      
      // Show all original cards
      const cards = document.querySelectorAll('.demo-card[data-original]');
      cards.forEach(card => {
        card.style.display = 'block';
      });
      
      updateDemoCounter();
    }

    function updateDemoCounter() {
      const counter = document.getElementById('demoCounter');
      if (!counter) return;
      
      setTimeout(() => {
        const visibleCards = Array.from(document.querySelectorAll('.demo-card[data-original]'))
          .filter(card => card.style.display !== 'none');
        const totalCards = document.querySelectorAll('.demo-card[data-original]').length;
        
        if (visibleCards.length === totalCards) {
          counter.textContent = `${totalCards} Interactive Demos`;
        } else {
          counter.textContent = `${visibleCards.length} of ${totalCards} Demos`;
        }
      }, 100);
    }

    function attachCardListeners(card) {
      const expandBtn = card.querySelector('.expand-btn');
      if (expandBtn) {
        expandBtn.onclick = (e) => {
          e.stopPropagation();
          openFullscreen(card);
        };
      }
    }

    let originalCardLocation = null;
    let originalParent = null;

    function openFullscreen(card) {
      const overlay = document.getElementById('fullscreenOverlay');
      const content = document.getElementById('fullscreenContent');
      
      if (!overlay || !content) return;
      
      // Store original location
      originalCardLocation = card;
      originalParent = card.parentElement;
      
      // Move the actual card content (don't clone - preserves canvas contexts!)
      const demoContent = card.querySelector('.demo-content');
      const demoTitle = card.querySelector('h3').textContent;
      
      content.innerHTML = '';
      document.getElementById('fullscreenTitle').textContent = demoTitle;
      
      // Move (not clone) the demo content
      content.appendChild(demoContent);
      
      overlay.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeFullscreen() {
      const overlay = document.getElementById('fullscreenOverlay');
      const content = document.getElementById('fullscreenContent');
      
      // Move content back to original card
      if (originalCardLocation && content.firstChild) {
        originalCardLocation.appendChild(content.firstChild);
      }
      
      overlay.classList.remove('active');
      document.body.style.overflow = '';
    }

    // Initialize expand buttons on page load
    document.addEventListener('DOMContentLoaded', () => {
      const cards = document.querySelectorAll('.demo-card');
      cards.forEach(card => {
        card.setAttribute('data-original', 'true');
        attachCardListeners(card);
      });
      
      // Start with grouped view for a modern, organized look
      showGroupedDemos();
      
      // Update demo counter
      updateDemoCounter();
      
      // Add fullscreen overlay to DOM
      const overlay = document.createElement('div');
      overlay.id = 'fullscreenOverlay';
      overlay.className = 'fullscreen-overlay';
      overlay.innerHTML = `
        <div class="fullscreen-content">
          <div class="fullscreen-header">
            <h1 id="fullscreenTitle" class="fullscreen-title"></h1>
            <button class="close-fullscreen-btn" onclick="closeFullscreen()">
              <i class="fas fa-times"></i> Close
            </button>
          </div>
          <div id="fullscreenContent"></div>
        </div>
      `;
      document.body.appendChild(overlay);

      // Add expand buttons to all demo cards
      document.querySelectorAll('.demo-card').forEach(card => {
        const expandBtn = document.createElement('button');
        expandBtn.className = 'expand-btn';
        expandBtn.title = 'Open Fullscreen';
        expandBtn.innerHTML = '<i class="fas fa-expand"></i>';
        expandBtn.onclick = (e) => {
          e.stopPropagation();
          openFullscreen(card);
        };
        card.style.position = 'relative';
        card.insertBefore(expandBtn, card.firstChild);
      });

      // Add Back to Top button
      const backToTopBtn = document.createElement('button');
      backToTopBtn.className = 'back-to-top';
      backToTopBtn.innerHTML = '<i class="fas fa-arrow-up"></i>';
      backToTopBtn.title = 'Back to Top';
      backToTopBtn.onclick = () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      };
      document.body.appendChild(backToTopBtn);

      // Show/hide back to top button on scroll
      window.addEventListener('scroll', () => {
        if (window.scrollY > 500) {
          backToTopBtn.classList.add('visible');
        } else {
          backToTopBtn.classList.remove('visible');
        }
      });

      // Add keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // ESC to close fullscreen
        if (e.key === 'Escape' && document.getElementById('fullscreenOverlay').classList.contains('active')) {
          closeFullscreen();
        }
        // Home key to go to top
        if (e.key === 'Home') {
          e.preventDefault();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
      });

      // Add loading completion indicator
      setTimeout(() => {
        document.body.style.opacity = '1';
        console.log('üöÄ Portfolio loaded successfully!');
      }, 100);

      // Search functionality
      const searchInput = document.getElementById('demoSearch');
      const clearSearchBtn = document.getElementById('clearSearch');
      
      searchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase().trim();
        
        // Show/hide clear button
        if (searchTerm) {
          clearSearchBtn.classList.add('visible');
        } else {
          clearSearchBtn.classList.remove('visible');
        }
        
        // If searching, switch to normal view and filter
        if (searchTerm) {
          removeGroupedDemos();
          const cards = document.querySelectorAll('.demo-card[data-original]');
          let visibleCount = 0;
          
          cards.forEach(card => {
            const title = card.querySelector('h3')?.textContent.toLowerCase() || '';
            const description = card.querySelector('p')?.textContent.toLowerCase() || '';
            const categories = card.dataset.category.toLowerCase();
            
            if (title.includes(searchTerm) || description.includes(searchTerm) || categories.includes(searchTerm)) {
              card.style.display = 'block';
              card.style.animation = 'cardFadeIn 0.5s ease forwards';
              visibleCount++;
            } else {
              card.style.display = 'none';
            }
          });
          
          // Show no results message if needed
          let noResultsMsg = document.getElementById('noResultsMessage');
          if (visibleCount === 0) {
            if (!noResultsMsg) {
              noResultsMsg = document.createElement('div');
              noResultsMsg.id = 'noResultsMessage';
              noResultsMsg.style.cssText = 'grid-column: 1 / -1; text-align: center; padding: 60px 20px; font-size: 1.5rem; color: rgba(255,255,255,0.5);';
              noResultsMsg.innerHTML = `
                <i class="fas fa-search" style="font-size: 3rem; margin-bottom: 20px; opacity: 0.3;"></i>
                <p>No demos found matching "<strong>${searchTerm}</strong>"</p>
                <p style="font-size: 1rem; margin-top: 10px;">Try different keywords or <span style="color: var(--primary-color); cursor: pointer;" onclick="document.getElementById('demoSearch').value=''; document.getElementById('demoSearch').dispatchEvent(new Event('input'));">clear your search</span></p>
              `;
              document.querySelector('.showcase-grid').appendChild(noResultsMsg);
            }
          } else if (noResultsMsg) {
            noResultsMsg.remove();
          }
          
          updateDemoCounter();
        } else {
          // Clear search - return to grouped view
          const noResultsMsg = document.getElementById('noResultsMessage');
          if (noResultsMsg) noResultsMsg.remove();
          
          // Re-enable grouped view for "all" category
          const activeBtn = document.querySelector('.category-btn.active');
          if (activeBtn && activeBtn.dataset.category === 'all') {
            showGroupedDemos();
          } else {
            // Show filtered category
            filterCategory(activeBtn?.dataset.category || 'all');
          }
        }
      });
      
      clearSearchBtn.addEventListener('click', () => {
        searchInput.value = '';
        searchInput.dispatchEvent(new Event('input'));
        searchInput.focus();
      });
    });

    // ===== 3D PARTICLE SYSTEM =====
    const partCanvas = document.getElementById('particleCanvas');
    const partCtx = partCanvas.getContext('2d');
    let particles = [];
    let mouseX = 0;
    let mouseY = 0;

    partCanvas.width = partCanvas.offsetWidth;
    partCanvas.height = 400;

    class Particle {
      constructor() {
        this.x = Math.random() * partCanvas.width;
        this.y = Math.random() * partCanvas.height;
        this.z = Math.random() * 1000;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.vz = (Math.random() - 0.5) * 2;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.z += this.vz;

        // Mouse attraction
        const dx = mouseX - this.x;
        const dy = mouseY - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 100) {
          this.x += dx * 0.01;
          this.y += dy * 0.01;
        }

        // Wrap around edges
        if (this.x < 0) this.x = partCanvas.width;
        if (this.x > partCanvas.width) this.x = 0;
        if (this.y < 0) this.y = partCanvas.height;
        if (this.y > partCanvas.height) this.y = 0;
        if (this.z < 0) this.z = 1000;
        if (this.z > 1000) this.z = 0;
      }

      draw() {
        const scale = 1000 / (1000 - this.z);
        const x2d = (this.x - partCanvas.width / 2) * scale + partCanvas.width / 2;
        const y2d = (this.y - partCanvas.height / 2) * scale + partCanvas.height / 2;
        const size = 2 * scale;

        partCtx.fillStyle = `hsla(${(this.z / 1000) * 180 + 180}, 100%, 60%, ${scale / 2})`;
        partCtx.beginPath();
        partCtx.arc(x2d, y2d, size, 0, Math.PI * 2);
        partCtx.fill();
      }
    }

    function resetParticles() {
      const count = parseInt(document.getElementById('particleCount').value);
      document.getElementById('particleCountValue').textContent = count;
      particles = [];
      for (let i = 0; i < count; i++) {
        particles.push(new Particle());
      }
    }

    function animateParticles() {
      partCtx.fillStyle = 'rgba(10, 10, 15, 0.1)';
      partCtx.fillRect(0, 0, partCanvas.width, partCanvas.height);

      particles.forEach(p => {
        p.update();
        p.draw();
      });

      requestAnimationFrame(animateParticles);
    }

    partCanvas.addEventListener('mousemove', (e) => {
      const rect = partCanvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    resetParticles();
    animateParticles();

    // ===== LIVE CODE EDITOR =====
    function runCode() {
      const html = document.getElementById('htmlCode').value;
      const css = document.getElementById('cssCode').value;
      const js = document.getElementById('jsCode').value;
      const iframe = document.getElementById('codePreview');
      
      const code = `
        <!DOCTYPE html>
        <html>
        <head><style>${css}</style></head>
        <body>${html}<script>${js}<\/script></body>
        </html>
      `;
      
      iframe.srcdoc = code;
    }
    runCode();

    // ===== CHART BUILDER =====
    const chartCanvas = document.getElementById('dataChart');
    const chartCtx = chartCanvas.getContext('2d');
    chartCanvas.width = chartCanvas.offsetWidth;
    chartCanvas.height = 300;

    function updateChart() {
      const data = document.getElementById('chartData').value.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
      const type = document.getElementById('chartType').value;
      
      chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
      
      if (type === 'bar') drawBarChart(data);
      else if (type === 'line') drawLineChart(data);
      else if (type === 'pie') drawPieChart(data);
    }

    function drawBarChart(data) {
      const max = Math.max(...data);
      const barWidth = chartCanvas.width / data.length - 10;
      const colors = ['#00d9ff', '#a855f7', '#f59e0b', '#10b981', '#ef4444', '#8b5cf6', '#06b6d4'];
      
      data.forEach((value, i) => {
        const height = (value / max) * (chartCanvas.height - 40);
        const x = i * (barWidth + 10) + 5;
        const y = chartCanvas.height - height - 20;
        
        chartCtx.fillStyle = colors[i % colors.length];
        chartCtx.fillRect(x, y, barWidth, height);
        
        chartCtx.fillStyle = '#fff';
        chartCtx.font = '12px Inter';
        chartCtx.textAlign = 'center';
        chartCtx.fillText(value, x + barWidth / 2, chartCanvas.height - 5);
      });
    }

    function drawLineChart(data) {
      const max = Math.max(...data);
      const stepX = chartCanvas.width / (data.length - 1);
      
      chartCtx.strokeStyle = '#00d9ff';
      chartCtx.lineWidth = 3;
      chartCtx.beginPath();
      
      data.forEach((value, i) => {
        const x = i * stepX;
        const y = chartCanvas.height - (value / max) * (chartCanvas.height - 40) - 20;
        
        if (i === 0) chartCtx.moveTo(x, y);
        else chartCtx.lineTo(x, y);
        
        // Draw points
        chartCtx.fillStyle = '#a855f7';
        chartCtx.beginPath();
        chartCtx.arc(x, y, 5, 0, Math.PI * 2);
        chartCtx.fill();
      });
      
      chartCtx.stroke();
    }

    function drawPieChart(data) {
      const total = data.reduce((a, b) => a + b, 0);
      const colors = ['#00d9ff', '#a855f7', '#f59e0b', '#10b981', '#ef4444', '#8b5cf6', '#06b6d4'];
      const centerX = chartCanvas.width / 2;
      const centerY = chartCanvas.height / 2;
      const radius = Math.min(centerX, centerY) - 20;
      
      let currentAngle = -Math.PI / 2;
      
      data.forEach((value, i) => {
        const sliceAngle = (value / total) * Math.PI * 2;
        
        chartCtx.fillStyle = colors[i % colors.length];
        chartCtx.beginPath();
        chartCtx.moveTo(centerX, centerY);
        chartCtx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
        chartCtx.closePath();
        chartCtx.fill();
        
        // Labels
        const labelAngle = currentAngle + sliceAngle / 2;
        const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
        const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
        
        chartCtx.fillStyle = '#fff';
        chartCtx.font = 'bold 14px Inter';
        chartCtx.textAlign = 'center';
        chartCtx.fillText(`${Math.round((value / total) * 100)}%`, labelX, labelY);
        
        currentAngle += sliceAngle;
      });
    }

    updateChart();

    // ===== SNAKE GAME =====
    const snakeCanvas = document.getElementById('snakeCanvas');
    const snakeCtx = snakeCanvas.getContext('2d');
    snakeCanvas.width = 400;
    snakeCanvas.height = 400;
    
    let snake = [{x: 10, y: 10}];
    let food = {x: 15, y: 15};
    let dx = 0, dy = 0;
    let score = 0;
    let highScore = localStorage.getItem('snakeHigh') || 0;
    let gameLoop = null;
    
    document.getElementById('snakeHigh').textContent = highScore;

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' && dy === 0) { dx = 0; dy = -1; }
      if (e.key === 'ArrowDown' && dy === 0) { dx = 0; dy = 1; }
      if (e.key === 'ArrowLeft' && dx === 0) { dx = -1; dy = 0; }
      if (e.key === 'ArrowRight' && dx === 0) { dx = 1; dy = 0; }
    });

    // Global function to stop all games when a new one starts
    function stopAllGames() {
      // Stop snake game
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Stop space invaders
      if (spaceGame && spaceGame.gameLoop) {
        cancelAnimationFrame(spaceGame.gameLoop);
        spaceGame.gameLoop = null;
        spaceGame.gameOver = true;
      }
      if (spaceGame && spaceGame.spawnTimer) {
        clearTimeout(spaceGame.spawnTimer);
        spaceGame.spawnTimer = null;
      }
      
      // Stop zombie game
      if (zombieGame && zombieGame.gameLoop) {
        cancelAnimationFrame(zombieGame.gameLoop);
        zombieGame.gameLoop = null;
        zombieGame.gameActive = false;
      }
      
      // Stop hide and seek
      if (hideSeekGame && hideSeekGame.gameLoop) {
        cancelAnimationFrame(hideSeekGame.gameLoop);
        hideSeekGame.gameLoop = null;
        hideSeekGame.gameActive = false;
      }
      if (hideSeekGame && hideSeekGame.timer) {
        clearInterval(hideSeekGame.timer);
        hideSeekGame.timer = null;
      }
    }

    function startSnakeGame() {
      stopAllGames();
      snake = [{x: 10, y: 10}];
      dx = 1; dy = 0;
      score = 0;
      document.getElementById('snakeScore').textContent = score;
      spawnFood();
      if (gameLoop) clearInterval(gameLoop);
      gameLoop = setInterval(updateSnake, 100);
    }

    function updateSnake() {
      const head = {x: snake[0].x + dx, y: snake[0].y + dy};
      
      // Check collision with walls
      if (head.x < 0 || head.x >= 20 || head.y < 0 || head.y >= 20) {
        endGame();
        return;
      }
      
      // Check collision with self
      if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        endGame();
        return;
      }
      
      snake.unshift(head);
      
      // Check food
      if (head.x === food.x && head.y === food.y) {
        score++;
        document.getElementById('snakeScore').textContent = score;
        spawnFood();
      } else {
        snake.pop();
      }
      
      drawSnake();
    }

    function drawSnake() {
      snakeCtx.fillStyle = '#0a0a0f';
      snakeCtx.fillRect(0, 0, snakeCanvas.width, snakeCanvas.height);
      
      // Draw snake
      snake.forEach((segment, i) => {
        snakeCtx.fillStyle = i === 0 ? '#00d9ff' : '#a855f7';
        snakeCtx.fillRect(segment.x * 20, segment.y * 20, 18, 18);
      });
      
      // Draw food
      snakeCtx.fillStyle = '#f59e0b';
      snakeCtx.fillRect(food.x * 20, food.y * 20, 18, 18);
    }

    function spawnFood() {
      food = {
        x: Math.floor(Math.random() * 20),
        y: Math.floor(Math.random() * 20)
      };
    }

    function endGame() {
      clearInterval(gameLoop);
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('snakeHigh', highScore);
        document.getElementById('snakeHigh').textContent = highScore;
      }
      
      // Create professional modal
      const modal = document.createElement('div');
      modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;';
      modal.innerHTML = `
        <div style="background: linear-gradient(135deg, #1a1a2e, #0a0a0f); padding: 40px; border-radius: 20px; border: 2px solid #00d9ff; box-shadow: 0 0 40px rgba(0,217,255,0.3); text-align: center; max-width: 400px;">
          <h2 style="color: #00d9ff; font-size: 2rem; margin-bottom: 20px;">üéÆ Game Over!</h2>
          <p style="color: white; font-size: 1.5rem; margin: 20px 0;">Score: <span style="color: #f59e0b; font-weight: bold;">${score}</span></p>
          ${score > highScore ? '<p style="color: #10b981; font-size: 1.2rem; margin: 10px 0;">üèÜ New High Score!</p>' : `<p style="color: #a0aec0; font-size: 1rem;">High Score: ${highScore}</p>`}
          <button onclick="this.parentElement.parentElement.remove()" style="margin-top: 20px; padding: 12px 30px; background: linear-gradient(135deg, #00d9ff, #a855f7); border: none; border-radius: 10px; color: white; font-size: 1.1rem; font-weight: bold; cursor: pointer; transition: transform 0.2s;">Play Again</button>
        </div>
      `;
      document.body.appendChild(modal);
      modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
    }

    drawSnake();

    // ===== SENTIMENT ANALYZER =====
    function analyzeSentiment() {
      const text = document.getElementById('sentimentText').value.toLowerCase();
      const resultDiv = document.getElementById('sentimentResult');
      
      // Simple keyword-based sentiment analysis
      const positiveWords = ['love', 'amazing', 'great', 'excellent', 'wonderful', 'fantastic', 'good', 'best', 'awesome', 'incredible', 'perfect', 'beautiful'];
      const negativeWords = ['hate', 'terrible', 'awful', 'bad', 'worst', 'horrible', 'poor', 'disappointing', 'sad', 'angry', 'frustrating'];
      
      let positiveCount = 0;
      let negativeCount = 0;
      
      positiveWords.forEach(word => {
        const regex = new RegExp(word, 'gi');
        const matches = text.match(regex);
        if (matches) positiveCount += matches.length;
      });
      
      negativeWords.forEach(word => {
        const regex = new RegExp(word, 'gi');
        const matches = text.match(regex);
        if (matches) negativeCount += matches.length;
      });
      
      const total = positiveCount + negativeCount || 1;
      const positivePercent = (positiveCount / total) * 100;
      const negativePercent = (negativeCount / total) * 100;
      
      let sentiment, emoji, score;
      if (positiveCount > negativeCount) {
        sentiment = 'Positive';
        emoji = 'üòä';
        score = Math.min(Math.round(positivePercent), 95);
      } else if (negativeCount > positiveCount) {
        sentiment = 'Negative';
        emoji = 'üòî';
        score = Math.min(Math.round(negativePercent), 95);
      } else {
        sentiment = 'Neutral';
        emoji = 'üòê';
        score = 50;
      }
      
      document.getElementById('sentimentEmoji').textContent = emoji;
      document.getElementById('sentimentLabel').textContent = sentiment;
      document.getElementById('sentimentScore').textContent = score + '%';
      document.getElementById('positiveBar').style.width = positivePercent + '%';
      document.getElementById('negativeBar').style.width = negativePercent + '%';
      
      resultDiv.style.display = 'block';
    }

    // ===== MAZE GENERATOR & SOLVER =====
    const mazeCanvas = document.getElementById('mazeCanvas');
    const mazeCtx = mazeCanvas.getContext('2d');
    mazeCanvas.width = 500;
    mazeCanvas.height = 500;
    
    const mazeSize = 20;
    const cellSize = mazeCanvas.width / mazeSize;
    let maze = [];
    let mazePath = [];

    function generateMaze() {
      // Create maze with all walls
      maze = Array(mazeSize).fill().map(() => Array(mazeSize).fill(1));
      
      // Start from (0,0) and use recursive backtracking
      const stack = [];
      const visited = Array(mazeSize).fill().map(() => Array(mazeSize).fill(false));
      
      let current = {x: 0, y: 0};
      maze[0][0] = 0;
      visited[0][0] = true;
      stack.push(current);
      
      while (stack.length > 0) {
        current = stack[stack.length - 1];
        const neighbors = [];
        
        // Check all 4 directions (move by 2 to leave walls between)
        const directions = [
          {dx: 2, dy: 0},
          {dx: -2, dy: 0},
          {dx: 0, dy: 2},
          {dx: 0, dy: -2}
        ];
        
        directions.forEach(dir => {
          const nx = current.x + dir.dx;
          const ny = current.y + dir.dy;
          
          if (nx >= 0 && nx < mazeSize && ny >= 0 && ny < mazeSize && !visited[ny][nx]) {
            neighbors.push({x: nx, y: ny, dx: dir.dx, dy: dir.dy});
          }
        });
        
        if (neighbors.length > 0) {
          // Choose random neighbor
          const next = neighbors[Math.floor(Math.random() * neighbors.length)];
          
          // Mark as visited and carve path
          visited[next.y][next.x] = true;
          maze[next.y][next.x] = 0;
          
          // Carve the wall between current and next
          const wallX = current.x + next.dx / 2;
          const wallY = current.y + next.dy / 2;
          maze[wallY][wallX] = 0;
          
          stack.push({x: next.x, y: next.y});
        } else {
          stack.pop();
        }
      }
      
      // Ensure start and end are open
      maze[0][0] = 0;
      maze[mazeSize - 1][mazeSize - 1] = 0;
      
      // Clear path around exit to ensure it's reachable
      if (mazeSize > 2) {
        maze[mazeSize - 1][mazeSize - 2] = 0; // Left of exit
        maze[mazeSize - 2][mazeSize - 1] = 0; // Above exit
      }
      
      mazePath = [];
      drawMaze();
    }

    function drawMaze() {
      mazeCtx.fillStyle = '#0a0a0f';
      mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);
      
      for (let y = 0; y < mazeSize; y++) {
        for (let x = 0; x < mazeSize; x++) {
          if (maze[y][x] === 1) {
            mazeCtx.fillStyle = '#00d9ff';
            mazeCtx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
          }
        }
      }
      
      // Draw start
      mazeCtx.fillStyle = '#10b981';
      mazeCtx.fillRect(0, 0, cellSize - 1, cellSize - 1);
      
      // Draw end
      mazeCtx.fillStyle = '#ef4444';
      mazeCtx.fillRect((mazeSize - 1) * cellSize, (mazeSize - 1) * cellSize, cellSize - 1, cellSize - 1);
      
      // Draw path
      mazeCtx.fillStyle = '#f59e0b';
      mazePath.forEach(({x, y}) => {
        mazeCtx.fillRect(x * cellSize + 2, y * cellSize + 2, cellSize - 5, cellSize - 5);
      });
    }

    function solveMaze() {
      if (!maze || maze.length === 0) {
        console.error('Maze not initialized');
        generateMaze();
        return;
      }
      
      // Reset previous path
      mazePath = [];
      
      const visited = Array(mazeSize).fill().map(() => Array(mazeSize).fill(false));
      const explorationSteps = []; // Track exploration for visualization
      const finalPath = [];
      
      function dfs(x, y) {
        if (x < 0 || x >= mazeSize || y < 0 || y >= mazeSize || visited[y][x] || maze[y][x] === 1) {
          return false;
        }
        
        visited[y][x] = true;
        finalPath.push({x, y});
        explorationSteps.push({x, y, isPath: true}); // Add to visualization
        
        if (x === mazeSize - 1 && y === mazeSize - 1) {
          return true;
        }
        
        if (dfs(x + 1, y) || dfs(x, y + 1) || dfs(x - 1, y) || dfs(x, y - 1)) {
          return true;
        }
        
        explorationSteps.push({x, y, isPath: false}); // Mark backtrack
        finalPath.pop();
        return false;
      }
      
      if (dfs(0, 0)) {
        // Animate the exploration process step-by-step
        let stepIndex = 0;
        const animationInterval = setInterval(() => {
          if (stepIndex < explorationSteps.length) {
            const step = explorationSteps[stepIndex];
            
            // Redraw maze
            mazeCtx.fillStyle = '#0a0a0f';
            mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);
            
            for (let y = 0; y < mazeSize; y++) {
              for (let x = 0; x < mazeSize; x++) {
                if (maze[y][x] === 1) {
                  mazeCtx.fillStyle = '#00d9ff';
                  mazeCtx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
                }
              }
            }
            
            // Draw exploration trail (visited cells in gray)
            for (let i = 0; i <= stepIndex; i++) {
              const s = explorationSteps[i];
              if (!s.isPath) {
                mazeCtx.fillStyle = 'rgba(128, 128, 128, 0.3)'; // Backtracked cells
                mazeCtx.fillRect(s.x * cellSize + 2, s.y * cellSize + 2, cellSize - 5, cellSize - 5);
              }
            }
            
            // Draw current exploration path in yellow
            for (let i = 0; i <= stepIndex; i++) {
              const s = explorationSteps[i];
              if (s.isPath && finalPath.some(p => p.x === s.x && p.y === s.y)) {
                mazeCtx.fillStyle = '#f59e0b';
                mazeCtx.fillRect(s.x * cellSize + 2, s.y * cellSize + 2, cellSize - 5, cellSize - 5);
              }
            }
            
            // Draw current position (animated dot)
            mazeCtx.fillStyle = '#ffffff';
            mazeCtx.beginPath();
            mazeCtx.arc(step.x * cellSize + cellSize/2, step.y * cellSize + cellSize/2, cellSize/4, 0, Math.PI * 2);
            mazeCtx.fill();
            
            // Draw start
            mazeCtx.fillStyle = '#10b981';
            mazeCtx.fillRect(0, 0, cellSize - 1, cellSize - 1);
            
            // Draw end
            mazeCtx.fillStyle = '#ef4444';
            mazeCtx.fillRect((mazeSize - 1) * cellSize, (mazeSize - 1) * cellSize, cellSize - 1, cellSize - 1);
            
            stepIndex++;
          } else {
            clearInterval(animationInterval);
            mazePath = [...finalPath];
            drawMaze(); // Final draw with complete path
          }
        }, 20); // 20ms per step for smooth visualization
      } else {
        alert('No solution found! Generating new maze...');
        generateMaze();
      }
    }

    function resetMaze() {
      mazePath = [];
      generateMaze();
    }

    generateMaze();

    // ===== IMAGE FILTER STUDIO =====
    const imgCanvas = document.getElementById('imageCanvas');
    const imgCtx = imgCanvas.getContext('2d');
    let originalImage = null;
    let currentImageData = null;

    function loadImage(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          imgCanvas.width = img.width;
          imgCanvas.height = img.height;
          imgCtx.drawImage(img, 0, 0);
          originalImage = imgCtx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
          currentImageData = imgCtx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function applyFilter(filterType) {
      if (!originalImage) {
        alert('Please upload an image first!');
        return;
      }
      
      if (filterType === 'reset') {
        imgCtx.putImageData(originalImage, 0, 0);
        currentImageData = imgCtx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
        return;
      }
      
      const imageData = imgCtx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        
        switch(filterType) {
          case 'grayscale':
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            data[i] = data[i + 1] = data[i + 2] = gray;
            break;
          case 'sepia':
            data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
            data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
            data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
            break;
          case 'invert':
            data[i] = 255 - r;
            data[i + 1] = 255 - g;
            data[i + 2] = 255 - b;
            break;
          case 'brightness':
            data[i] = Math.min(255, r * 1.2);
            data[i + 1] = Math.min(255, g * 1.2);
            data[i + 2] = Math.min(255, b * 1.2);
            break;
          case 'contrast':
            const factor = 1.5;
            data[i] = Math.min(255, Math.max(0, factor * (r - 128) + 128));
            data[i + 1] = Math.min(255, Math.max(0, factor * (g - 128) + 128));
            data[i + 2] = Math.min(255, Math.max(0, factor * (b - 128) + 128));
            break;
        }
      }
      
      if (filterType === 'blur') {
        // Simple box blur
        const tempData = new Uint8ClampedArray(data);
        const width = imgCanvas.width;
        const radius = 2;
        
        for (let y = radius; y < imgCanvas.height - radius; y++) {
          for (let x = radius; x < width - radius; x++) {
            let r = 0, g = 0, b = 0, count = 0;
            
            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const idx = ((y + dy) * width + (x + dx)) * 4;
                r += tempData[idx];
                g += tempData[idx + 1];
                b += tempData[idx + 2];
                count++;
              }
            }
            
            const idx = (y * width + x) * 4;
            data[idx] = r / count;
            data[idx + 1] = g / count;
            data[idx + 2] = b / count;
          }
        }
      }
      
      imgCtx.putImageData(imageData, 0, 0);
    }

    // ===== PHYSICS SIMULATOR =====
    const physCanvas = document.getElementById('physicsCanvas');
    const physCtx = physCanvas ? physCanvas.getContext('2d') : null;
    let physicsBalls = [];
    let physicsObjects = []; // All objects including balls, boxes, magnets
    let gravityStrength = 0.3;
    let bounceCoeff = 0.8;
    let timeScale = 1.0;
    let physicsPaused = false;
    let physicsAnimationId;

    class Ball {
      constructor(x, y) {
        this.type = 'ball';
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 15 + 10;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
        this.mass = this.radius;
      }

      update() {
        this.vy += gravityStrength * timeScale;
        
        this.x += this.vx * timeScale;
        this.y += this.vy * timeScale;
        
        // Magnet and Black Hole attraction
        physicsObjects.forEach(obj => {
          if (obj.type === 'magnet') {
            const dx = obj.x - this.x;
            const dy = obj.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 200 && dist > 0) {
              const force = (obj.strength / (dist * dist)) * 100;
              this.vx += (dx / dist) * force * timeScale;
              this.vy += (dy / dist) * force * timeScale;
            }
          } else if (obj.type === 'blackhole') {
            const dx = obj.x - this.x;
            const dy = obj.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 250 && dist > 0) {
              const force = (obj.strength / (dist * dist)) * 150;
              this.vx += (dx / dist) * force * timeScale;
              this.vy += (dy / dist) * force * timeScale;
            }
          }
        });
        
        // Wall collisions with bounce
        if (this.x + this.radius > physCanvas.width) {
          this.x = physCanvas.width - this.radius;
          this.vx *= -bounceCoeff;
        }
        if (this.x - this.radius < 0) {
          this.x = this.radius;
          this.vx *= -bounceCoeff;
        }
        if (this.y + this.radius > physCanvas.height) {
          this.y = physCanvas.height - this.radius;
          this.vy *= -bounceCoeff;
          this.vx *= 0.98; // Friction
        }
        if (this.y - this.radius < 0) {
          this.y = this.radius;
          this.vy *= -bounceCoeff;
        }
      }

      draw() {
        physCtx.beginPath();
        physCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        physCtx.fillStyle = this.color;
        physCtx.fill();
        physCtx.strokeStyle = 'rgba(255,255,255,0.3)';
        physCtx.lineWidth = 2;
        physCtx.stroke();
      }
    }

    class Box {
      constructor(x, y) {
        this.type = 'box';
        this.x = x;
        this.y = y;
        this.width = Math.random() * 30 + 20;
        this.height = Math.random() * 30 + 20;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6;
        this.rotation = 0;
        this.angularVel = (Math.random() - 0.5) * 0.2;
        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
        this.mass = this.width * this.height / 100;
      }

      update() {
        this.vy += gravityStrength * timeScale;
        
        this.x += this.vx * timeScale;
        this.y += this.vy * timeScale;
        this.rotation += this.angularVel * timeScale;
        
        const halfW = this.width / 2;
        const halfH = this.height / 2;
        
        // Wall collisions
        if (this.x + halfW > physCanvas.width) {
          this.x = physCanvas.width - halfW;
          this.vx *= -bounceCoeff;
          this.angularVel *= bounceCoeff;
        }
        if (this.x - halfW < 0) {
          this.x = halfW;
          this.vx *= -bounceCoeff;
          this.angularVel *= bounceCoeff;
        }
        if (this.y + halfH > physCanvas.height) {
          this.y = physCanvas.height - halfH;
          this.vy *= -bounceCoeff;
          this.vx *= 0.98;
          this.angularVel *= 0.95;
        }
        if (this.y - halfH < 0) {
          this.y = halfH;
          this.vy *= -bounceCoeff;
        }
      }

      draw() {
        physCtx.save();
        physCtx.translate(this.x, this.y);
        physCtx.rotate(this.rotation);
        physCtx.fillStyle = this.color;
        physCtx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        physCtx.strokeStyle = 'rgba(255,255,255,0.3)';
        physCtx.lineWidth = 2;
        physCtx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
        physCtx.restore();
      }
    }

    class Magnet {
      constructor(x, y) {
        this.type = 'magnet';
        this.x = x;
        this.y = y;
        this.radius = 20;
        this.strength = 10;
        this.pulse = 0;
      }

      update() {
        this.pulse += 0.1 * timeScale;
      }

      draw() {
        // Magnetic field visualization (stronger, more visible)
        physCtx.strokeStyle = `rgba(255, 0, 0, ${0.3 + Math.sin(this.pulse) * 0.15})`;
        physCtx.lineWidth = 3;
        for (let r = 40; r < 200; r += 40) {
          physCtx.beginPath();
          physCtx.arc(this.x, this.y, r, 0, Math.PI * 2);
          physCtx.stroke();
        }
        
        // Magnet body
        physCtx.fillStyle = '#ef4444';
        physCtx.beginPath();
        physCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        physCtx.fill();
        physCtx.strokeStyle = 'white';
        physCtx.lineWidth = 3;
        physCtx.stroke();
        
        // N/S poles
        physCtx.fillStyle = 'white';
        physCtx.font = 'bold 12px Arial';
        physCtx.textAlign = 'center';
        physCtx.textBaseline = 'middle';
        physCtx.fillText('N', this.x, this.y - 5);
        physCtx.fillText('S', this.x, this.y + 7);
      }
    }

    class BlackHole {
      constructor(x, y) {
        this.type = 'blackhole';
        this.x = x;
        this.y = y;
        this.radius = 25;
        this.eventHorizon = 35;
        this.strength = 15;
        this.rotation = 0;
        this.particles = [];
        for (let i = 0; i < 20; i++) {
          this.particles.push({
            angle: (i / 20) * Math.PI * 2,
            distance: 40 + Math.random() * 60,
            speed: 0.02 + Math.random() * 0.03
          });
        }
      }

      update() {
        this.rotation += 0.05 * timeScale;
        this.particles.forEach(p => {
          p.angle += p.speed * timeScale;
          p.distance -= 0.3 * timeScale;
          if (p.distance < this.eventHorizon) {
            p.distance = 100;
          }
        });
        
        // Absorb close balls
        physicsObjects.forEach((obj, index) => {
          if (obj.type === 'ball') {
            const dx = this.x - obj.x;
            const dy = this.y - obj.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < this.eventHorizon) {
              physicsObjects.splice(index, 1);
              updateObjectCount();
            }
          }
        });
      }

      draw() {
        // Accretion disk particles
        this.particles.forEach(p => {
          const x = this.x + Math.cos(p.angle + this.rotation) * p.distance;
          const y = this.y + Math.sin(p.angle + this.rotation) * p.distance;
          const alpha = 1 - (p.distance - this.eventHorizon) / 65;
          physCtx.fillStyle = `rgba(168, 85, 247, ${alpha * 0.8})`;
          physCtx.beginPath();
          physCtx.arc(x, y, 3, 0, Math.PI * 2);
          physCtx.fill();
        });
        
        // Event horizon glow
        const gradient = physCtx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.eventHorizon);
        gradient.addColorStop(0, 'rgba(75, 0, 130, 1)');
        gradient.addColorStop(0.6, 'rgba(138, 43, 226, 0.5)');
        gradient.addColorStop(1, 'rgba(168, 85, 247, 0)');
        physCtx.fillStyle = gradient;
        physCtx.beginPath();
        physCtx.arc(this.x, this.y, this.eventHorizon, 0, Math.PI * 2);
        physCtx.fill();
        
        // Black hole core
        physCtx.fillStyle = '#000000';
        physCtx.beginPath();
        physCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        physCtx.fill();
        physCtx.strokeStyle = '#a855f7';
        physCtx.lineWidth = 3;
        physCtx.stroke();
      }
    }

    class Spring {
      constructor(x, y) {
        this.type = 'spring';
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.stiffness = 0.05;
        this.damping = 0.9;
        this.restLength = 100;
        this.connectedBall = null;
        this.color = '#f59e0b';
      }

      update() {
        // Find nearest ball if not connected
        if (!this.connectedBall || !physicsObjects.includes(this.connectedBall)) {
          let nearest = null;
          let minDist = Infinity;
          physicsObjects.forEach(obj => {
            if (obj.type === 'ball') {
              const dx = obj.x - this.x;
              const dy = obj.y - this.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < minDist && dist < 150) {
                minDist = dist;
                nearest = obj;
              }
            }
          });
          this.connectedBall = nearest;
        }
        
        // Apply spring force to connected ball
        if (this.connectedBall) {
          const dx = this.x - this.connectedBall.x;
          const dy = this.y - this.connectedBall.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const displacement = dist - this.restLength;
          const force = displacement * this.stiffness;
          
          this.connectedBall.vx += (dx / dist) * force * timeScale;
          this.connectedBall.vy += (dy / dist) * force * timeScale;
          this.connectedBall.vx *= this.damping;
          this.connectedBall.vy *= this.damping;
        }
      }

      draw() {
        // Draw spring connection
        if (this.connectedBall) {
          physCtx.strokeStyle = this.color;
          physCtx.lineWidth = 3;
          physCtx.setLineDash([5, 5]);
          physCtx.beginPath();
          physCtx.moveTo(this.x, this.y);
          
          // Draw zigzag spring
          const dx = this.connectedBall.x - this.x;
          const dy = this.connectedBall.y - this.y;
          const steps = 10;
          for (let i = 1; i < steps; i++) {
            const t = i / steps;
            const px = this.x + dx * t;
            const py = this.y + dy * t;
            const offset = (i % 2 === 0 ? 5 : -5);
            const perpX = -dy / Math.sqrt(dx*dx + dy*dy) * offset;
            const perpY = dx / Math.sqrt(dx*dx + dy*dy) * offset;
            physCtx.lineTo(px + perpX, py + perpY);
          }
          
          physCtx.lineTo(this.connectedBall.x, this.connectedBall.y);
          physCtx.stroke();
          physCtx.setLineDash([]);
        }
        
        // Draw spring anchor
        physCtx.fillStyle = this.color;
        physCtx.beginPath();
        physCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        physCtx.fill();
        physCtx.strokeStyle = 'white';
        physCtx.lineWidth = 2;
        physCtx.stroke();
        
        physCtx.fillStyle = 'white';
        physCtx.font = 'bold 16px Arial';
        physCtx.textAlign = 'center';
        physCtx.textBaseline = 'middle';
        physCtx.fillText('üîó', this.x, this.y);
      }
    }

    function animatePhysics() {
      if (!physicsPaused) {
        physCtx.clearRect(0, 0, physCanvas.width, physCanvas.height);
        
        // Update and draw black holes, magnets, springs first (background)
        physicsObjects.forEach(obj => {
          if (obj.type === 'blackhole' || obj.type === 'magnet' || obj.type === 'spring') {
            obj.update();
            obj.draw();
          }
        });
        
        // Update and draw balls and boxes
        physicsObjects.forEach((obj, index) => {
          if (obj.type === 'ball' || obj.type === 'box') {
            obj.update();
            
            // Ball-to-ball collisions
            if (obj.type === 'ball') {
              for (let i = index + 1; i < physicsObjects.length; i++) {
                const other = physicsObjects[i];
                if (other.type === 'ball') {
                  const dx = other.x - obj.x;
                  const dy = other.y - obj.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  if (distance < obj.radius + other.radius) {
                    const angle = Math.atan2(dy, dx);
                    const sin = Math.sin(angle);
                    const cos = Math.cos(angle);
                    
                    // Rotate velocities
                    const vx1 = obj.vx * cos + obj.vy * sin;
                    const vy1 = obj.vy * cos - obj.vx * sin;
                    const vx2 = other.vx * cos + other.vy * sin;
                    const vy2 = other.vy * cos - other.vx * sin;
                    
                    // Collision response
                    const totalMass = obj.mass + other.mass;
                    const vx1Final = ((obj.mass - other.mass) * vx1 + 2 * other.mass * vx2) / totalMass;
                    const vx2Final = ((other.mass - obj.mass) * vx2 + 2 * obj.mass * vx1) / totalMass;
                    
                    // Rotate back
                    obj.vx = vx1Final * cos - vy1 * sin;
                    obj.vy = vy1 * cos + vx1Final * sin;
                    other.vx = vx2Final * cos - vy2 * sin;
                    other.vy = vy2 * cos + vx2Final * sin;
                    
                    // Separate balls
                    const overlap = obj.radius + other.radius - distance;
                    obj.x -= overlap * cos * 0.5;
                    obj.y -= overlap * sin * 0.5;
                    other.x += overlap * cos * 0.5;
                    other.y += overlap * sin * 0.5;
                  }
                }
              }
            }
            
            obj.draw();
          }
        });
        
        updateObjectCount();
      }
      
      physicsAnimationId = requestAnimationFrame(animatePhysics);
    }

    function addPhysicsBall() {
      const x = Math.random() * (physCanvas.width - 50) + 25;
      const y = Math.random() * 100 + 50;
      physicsObjects.push(new Ball(x, y));
      updateObjectCount();
    }

    function addPhysicsBox() {
      const x = Math.random() * (physCanvas.width - 50) + 25;
      const y = Math.random() * 100 + 50;
      physicsObjects.push(new Box(x, y));
      updateObjectCount();
    }

    function addMagnet() {
      const x = Math.random() * (physCanvas.width - 100) + 50;
      const y = Math.random() * (physCanvas.height - 100) + 50;
      physicsObjects.push(new Magnet(x, y));
      updateObjectCount();
    }

    function addBlackHole() {
      const x = Math.random() * (physCanvas.width - 100) + 50;
      const y = Math.random() * (physCanvas.height - 100) + 50;
      physicsObjects.push(new BlackHole(x, y));
      updateObjectCount();
    }

    function addSpring() {
      const x = Math.random() * (physCanvas.width - 100) + 50;
      const y = Math.random() * (physCanvas.height - 100) + 50;
      physicsObjects.push(new Spring(x, y));
      updateObjectCount();
    }

    function updateGravity(value) {
      gravityStrength = value / 10;
      document.getElementById('gravityValue').textContent = gravityStrength.toFixed(1);
    }

    function updateBounce(value) {
      bounceCoeff = value / 10;
      document.getElementById('bounceValue').textContent = bounceCoeff.toFixed(1);
    }

    function updateTimeScale(value) {
      timeScale = value / 10;
      document.getElementById('timeScaleValue').textContent = timeScale.toFixed(1) + 'x';
    }

    function togglePhysicsPause() {
      physicsPaused = !physicsPaused;
      const btn = document.getElementById('physicsPlayBtn');
      btn.textContent = physicsPaused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pause';
    }

    function clearPhysicsBalls() {
      physicsObjects = [];
      updateObjectCount();
    }

    function updateObjectCount() {
      const count = document.getElementById('objectCount');
      if (count) count.textContent = physicsObjects.length;
    }

    if (physCanvas) {
      physCanvas.addEventListener('click', (e) => {
        const rect = physCanvas.getBoundingClientRect();
        const scaleX = physCanvas.width / rect.width;
        const scaleY = physCanvas.height / rect.height;
        const x = (e.clientX - rect.left) * scaleX;
        const y = (e.clientY - rect.top) * scaleY;
        physicsObjects.push(new Ball(x, y));
        updateObjectCount();
      });
      
      animatePhysics();
    }

    physCanvas.addEventListener('click', (e) => {
      const rect = physCanvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (physCanvas.width / rect.width);
      const y = (e.clientY - rect.top) * (physCanvas.height / rect.height);
      physicsBalls.push(new Ball(x, y));
    });

    // Start with a few balls
    for (let i = 0; i < 5; i++) addPhysicsBall();
    animatePhysics();

    // ===== AUDIO VISUALIZER =====
    const audioCanvas = document.getElementById('audioCanvas');
    const audioCtx = audioCanvas.getContext('2d');
    let audioContext, analyser, microphone, dataArray;
    let visualizerStyle = 'bars';
    let audioAnimationId;
    let audioSensitivity = 1.0;
    let audioPaused = false;

    async function startAudioVisualizer() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        microphone = audioContext.createMediaStreamSource(stream);
        microphone.connect(analyser);
        analyser.fftSize = 256;
        
        const bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        
        document.getElementById('audioStartBtn').textContent = '‚úÖ Listening...';
        document.getElementById('audioStartBtn').style.background = 'var(--accent-color)';
        document.getElementById('audioStartBtn').disabled = true;
        document.getElementById('visualizerPauseBtn').disabled = false;
        
        animateAudio();
      } catch (err) {
        alert('Microphone access denied. Please allow microphone access.');
      }
    }

    function animateAudio() {
      if (!audioPaused) {
        analyser.getByteFrequencyData(dataArray);
        
        audioCtx.clearRect(0, 0, audioCanvas.width, audioCanvas.height);
        
        if (visualizerStyle === 'bars') {
          const barWidth = (audioCanvas.width / dataArray.length) * 2.5;
          let x = 0;
          
          for (let i = 0; i < dataArray.length; i++) {
            const barHeight = (dataArray[i] / 255) * audioCanvas.height * audioSensitivity;
            const hue = (i / dataArray.length) * 360;
            
            const gradient = audioCtx.createLinearGradient(0, audioCanvas.height, 0, audioCanvas.height - barHeight);
            gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.8)`);
            gradient.addColorStop(1, `hsla(${hue + 60}, 100%, 60%, 0.9)`);
            
            audioCtx.fillStyle = gradient;
            audioCtx.fillRect(x, audioCanvas.height - barHeight, barWidth - 2, barHeight);
            
            x += barWidth;
          }
        } else {
          // Circular waveform
          audioCtx.beginPath();
          audioCtx.arc(audioCanvas.width / 2, audioCanvas.height / 2, 50, 0, Math.PI * 2);
          audioCtx.strokeStyle = 'rgba(0,217,255,0.3)';
          audioCtx.lineWidth = 2;
          audioCtx.stroke();
          
          for (let i = 0; i < dataArray.length; i++) {
            const angle = (i / dataArray.length) * Math.PI * 2;
            const radius = 50 + (dataArray[i] / 255) * 100 * audioSensitivity;
            const x = audioCanvas.width / 2 + Math.cos(angle) * radius;
            const y = audioCanvas.height / 2 + Math.sin(angle) * radius;
            const hue = (i / dataArray.length) * 360;
            
            audioCtx.beginPath();
            audioCtx.arc(x, y, 3, 0, Math.PI * 2);
            audioCtx.fillStyle = `hsl(${hue}, 100%, 60%)`;
            audioCtx.fill();
          }
        }
      }
      
      audioAnimationId = requestAnimationFrame(animateAudio);
    }

    function toggleVisualizerStyle() {
      visualizerStyle = visualizerStyle === 'bars' ? 'circular' : 'bars';
      document.getElementById('visualizerStyleBtn').textContent = `üé® Style: ${visualizerStyle === 'bars' ? 'Bars' : 'Circular'}`;
    }

    function updateSensitivity(value) {
      audioSensitivity = value / 10;
      document.getElementById('sensitivityValue').textContent = audioSensitivity.toFixed(1) + 'x';
    }

    function toggleVisualizerPause() {
      audioPaused = !audioPaused;
      const btn = document.getElementById('visualizerPauseBtn');
      btn.textContent = audioPaused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
    }

    // ===== NEURAL NETWORK VISUALIZER =====
    const neuralCanvas = document.getElementById('neuralCanvas');
    const neuralCtx = neuralCanvas ? neuralCanvas.getContext('2d') : null;
    
    let nn = {
      epoch: 0,
      loss: 1.0,
      accuracy: 0,
      training: false,
      weights1: [], // 2x4 (input to hidden)
      weights2: [], // 4x1 (hidden to output)
      bias1: [],
      bias2: 0,
      learningRate: 0.5,
      trainingData: [
        { input: [0, 0], output: 0 },  // XOR problem
        { input: [0, 1], output: 1 },
        { input: [1, 0], output: 1 },
        { input: [1, 1], output: 0 }
      ]
    };

    function sigmoid(x) {
      return 1 / (1 + Math.exp(-x));
    }

    function sigmoidDerivative(x) {
      return x * (1 - x);
    }

    function initNeuralNetwork() {
      // Initialize weights randomly
      nn.weights1 = Array(2).fill().map(() => Array(4).fill().map(() => Math.random() * 2 - 1));
      nn.weights2 = Array(4).fill().map(() => Math.random() * 2 - 1);
      nn.bias1 = Array(4).fill().map(() => Math.random() * 2 - 1);
      nn.bias2 = Math.random() * 2 - 1;
      nn.epoch = 0;
      nn.loss = 1.0;
      nn.accuracy = 0;
      drawNeuralNetwork();
    }

    function forwardPass(input) {
      // Hidden layer
      const hidden = nn.bias1.map((bias, i) => {
        const sum = input[0] * nn.weights1[0][i] + input[1] * nn.weights1[1][i] + bias;
        return sigmoid(sum);
      });
      
      // Output layer
      const outputSum = hidden.reduce((sum, h, i) => sum + h * nn.weights2[i], 0) + nn.bias2;
      const output = sigmoid(outputSum);
      
      return { hidden, output };
    }

    function trainStep() {
      let totalLoss = 0;
      let correct = 0;
      
      // Train on each data point
      nn.trainingData.forEach(data => {
        const { hidden, output } = forwardPass(data.input);
        
        // Calculate error
        const error = data.output - output;
        totalLoss += error * error;
        if (Math.abs(error) < 0.5) correct++;
        
        // Backpropagation
        const outputDelta = error * sigmoidDerivative(output);
        
        // Update output weights
        hidden.forEach((h, i) => {
          nn.weights2[i] += nn.learningRate * outputDelta * h;
        });
        nn.bias2 += nn.learningRate * outputDelta;
        
        // Hidden layer deltas
        const hiddenDeltas = hidden.map((h, i) => 
          sigmoidDerivative(h) * outputDelta * nn.weights2[i]
        );
        
        // Update hidden weights
        for (let i = 0; i < 2; i++) {
          for (let j = 0; j < 4; j++) {
            nn.weights1[i][j] += nn.learningRate * hiddenDeltas[j] * data.input[i];
          }
        }
        
        hiddenDeltas.forEach((delta, i) => {
          nn.bias1[i] += nn.learningRate * delta;
        });
      });
      
      nn.epoch++;
      nn.loss = totalLoss / nn.trainingData.length;
      nn.accuracy = (correct / nn.trainingData.length) * 100;
      
      // Update display
      if (document.getElementById('nnEpoch')) document.getElementById('nnEpoch').textContent = nn.epoch;
      if (document.getElementById('nnLoss')) document.getElementById('nnLoss').textContent = nn.loss.toFixed(3);
      if (document.getElementById('nnAccuracy')) document.getElementById('nnAccuracy').textContent = nn.accuracy.toFixed(0) + '%';
      if (document.getElementById('nnCorrect')) document.getElementById('nnCorrect').textContent = correct + '/4';
    }

    function drawNeuralNetwork() {
      if (!neuralCtx) return;
      
      neuralCtx.clearRect(0, 0, neuralCanvas.width, neuralCanvas.height);
      
      const width = neuralCanvas.width;
      const height = neuralCanvas.height;
      const networkWidth = width * 0.3;
      const decisionWidth = width * 0.35;
      const predictionWidth = width * 0.35;
      
      // Draw network structure (left third)
      const layerX = [networkWidth * 0.2, networkWidth * 0.8];
      const inputY = [height * 0.35, height * 0.65];
      const hiddenY = [height * 0.2, height * 0.4, height * 0.6, height * 0.8];
      const outputY = height * 0.5;
      
      // Draw connections with weights
      for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 4; j++) {
          const weight = nn.weights1[i][j];
          const opacity = Math.min(Math.abs(weight), 1);
          neuralCtx.beginPath();
          neuralCtx.moveTo(layerX[0], inputY[i]);
          neuralCtx.lineTo(layerX[1] - 50, hiddenY[j]);
          neuralCtx.strokeStyle = weight > 0 ? `rgba(0,217,255,${opacity})` : `rgba(255,68,68,${opacity})`;
          neuralCtx.lineWidth = Math.abs(weight) * 2 + 1;
          neuralCtx.stroke();
        }
      }
      
      for (let j = 0; j < 4; j++) {
        const weight = nn.weights2[j];
        const opacity = Math.min(Math.abs(weight), 1);
        neuralCtx.beginPath();
        neuralCtx.moveTo(layerX[1] - 50, hiddenY[j]);
        neuralCtx.lineTo(layerX[1] + 50, outputY);
        neuralCtx.strokeStyle = weight > 0 ? `rgba(0,217,255,${opacity})` : `rgba(255,68,68,${opacity})`;
        neuralCtx.lineWidth = Math.abs(weight) * 2 + 1;
        neuralCtx.stroke();
      }
      
      // Draw neurons
      [[layerX[0], inputY[0]], [layerX[0], inputY[1]]].forEach(([x, y]) => {
        neuralCtx.beginPath();
        neuralCtx.arc(x, y, 15, 0, Math.PI * 2);
        neuralCtx.fillStyle = 'rgba(0,217,255,0.5)';
        neuralCtx.fill();
        neuralCtx.strokeStyle = 'white';
        neuralCtx.lineWidth = 2;
        neuralCtx.stroke();
      });
      
      hiddenY.forEach(y => {
        neuralCtx.beginPath();
        neuralCtx.arc(layerX[1] - 50, y, 12, 0, Math.PI * 2);
        neuralCtx.fillStyle = 'rgba(168,85,247,0.5)';
        neuralCtx.fill();
        neuralCtx.strokeStyle = 'white';
        neuralCtx.lineWidth = 2;
        neuralCtx.stroke();
      });
      
      neuralCtx.beginPath();
      neuralCtx.arc(layerX[1] + 50, outputY, 15, 0, Math.PI * 2);
      neuralCtx.fillStyle = 'rgba(0,255,136,0.5)';
      neuralCtx.fill();
      neuralCtx.strokeStyle = 'white';
      neuralCtx.lineWidth = 2;
      neuralCtx.stroke();
      
      // Draw decision boundary (middle third)
      const dbLeft = networkWidth;
      const dbWidth = decisionWidth;
      const resolution = 40;
      
      for (let i = 0; i < resolution; i++) {
        for (let j = 0; j < resolution; j++) {
          const x = i / resolution;
          const y = j / resolution;
          const prediction = forwardPass([x, y]).output;
          
          const screenX = dbLeft + x * dbWidth;
          const screenY = j * (height / resolution);
          const rectSize = Math.ceil(dbWidth / resolution);
          
          neuralCtx.fillStyle = prediction > 0.5 ? 
            `rgba(255,68,68,${prediction * 0.3})` : 
            `rgba(0,217,255,${(1-prediction) * 0.3})`;
          neuralCtx.fillRect(screenX, screenY, rectSize, rectSize);
        }
      }
      
      // Draw training data points
      nn.trainingData.forEach(data => {
        const x = dbLeft + data.input[0] * dbWidth;
        const y = data.input[1] * height;
        const prediction = forwardPass(data.input).output;
        const correct = Math.abs(prediction - data.output) < 0.5;
        
        neuralCtx.beginPath();
        neuralCtx.arc(x, y, 10, 0, Math.PI * 2);
        neuralCtx.fillStyle = data.output === 1 ? '#ff4444' : '#00d9ff';
        neuralCtx.fill();
        neuralCtx.strokeStyle = correct ? '#00ff88' : '#ffaa00';
        neuralCtx.lineWidth = 3;
        neuralCtx.stroke();
      });
      
      // Draw predictions (right third)
      const predLeft = networkWidth + decisionWidth;
      neuralCtx.fillStyle = 'white';
      neuralCtx.font = 'bold 14px Arial';
      neuralCtx.textAlign = 'left';
      
      nn.trainingData.forEach((data, idx) => {
        const y = height * 0.2 + idx * (height * 0.2);
        const prediction = forwardPass(data.input).output;
        const correct = Math.abs(prediction - data.output) < 0.5;
        
        neuralCtx.fillStyle = 'white';
        neuralCtx.fillText(`[${data.input.join(',')}] ‚Üí ${data.output}`, predLeft + 20, y);
        neuralCtx.fillStyle = correct ? '#00ff88' : '#ff4444';
        neuralCtx.fillText(`Pred: ${prediction.toFixed(2)}`, predLeft + 20, y + 20);
        neuralCtx.fillText(correct ? '‚úì' : '‚úó', predLeft + 160, y + 10);
      });
    }

    function startNeuralTraining() {
      if (nn.training) {
        stopNeuralTraining();
        return;
      }
      nn.training = true;
      const btn = document.getElementById('nnTrainBtn');
      if (btn) {
        btn.textContent = '‚è∏Ô∏è Pause';
        btn.style.background = 'var(--accent-color)';
      }
      
      function animate() {
        if (!nn.training) return;
        
        trainStep();
        drawNeuralNetwork();
        
        if (nn.epoch < 2000) {
          setTimeout(animate, 50);
        } else {
          stopNeuralTraining();
        }
      }
      
      animate();
    }

    function stopNeuralTraining() {
      nn.training = false;
      const btn = document.getElementById('nnTrainBtn');
      if (btn) {
        btn.textContent = '‚ñ∂Ô∏è Start Training';
        btn.style.background = '';
      }
    }

    function resetNeuralNetwork() {
      stopNeuralTraining();
      initNeuralNetwork();
      if (document.getElementById('nnEpoch')) document.getElementById('nnEpoch').textContent = '0';
      if (document.getElementById('nnLoss')) document.getElementById('nnLoss').textContent = '1.000';
      if (document.getElementById('nnAccuracy')) document.getElementById('nnAccuracy').textContent = '0%';
      if (document.getElementById('nnCorrect')) document.getElementById('nnCorrect').textContent = '0/4';
    }

    if (neuralCanvas) {
      initNeuralNetwork();
    }

    // ===== WEATHER DASHBOARD =====
    async function getWeather() {
      const city = document.getElementById('weatherCity').value.trim();
      const display = document.getElementById('weatherDisplay');
      
      if (!city) {
        display.innerHTML = '<p style="color: var(--accent-color);">Please enter a city name</p>';
        return;
      }
      
      display.innerHTML = '<p style="color: var(--primary-color);">Loading weather data...</p>';
      
      try {
        // Using Open-Meteo API (no API key required)
        const geoResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1`);
        const geoData = await geoResponse.json();
        
        if (!geoData.results || geoData.results.length === 0) {
          throw new Error('City not found');
        }
        
        const { latitude, longitude, name, country } = geoData.results[0];
        
        const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true&temperature_unit=fahrenheit`);
        const weatherData = await weatherResponse.json();
        
        const { temperature, windspeed, weathercode } = weatherData.current_weather;
        
        const weatherDescriptions = {
          0: '‚òÄÔ∏è Clear sky',
          1: 'üå§Ô∏è Mainly clear',
          2: '‚õÖ Partly cloudy',
          3: '‚òÅÔ∏è Overcast',
          45: 'üå´Ô∏è Foggy',
          48: 'üå´Ô∏è Foggy',
          51: 'üå¶Ô∏è Light drizzle',
          61: 'üåßÔ∏è Light rain',
          63: 'üåßÔ∏è Moderate rain',
          65: 'üåßÔ∏è Heavy rain',
          71: 'üå®Ô∏è Light snow',
          73: 'üå®Ô∏è Moderate snow',
          75: 'üå®Ô∏è Heavy snow',
          95: '‚õàÔ∏è Thunderstorm'
        };
        
        const description = weatherDescriptions[weathercode] || 'üåç Weather';
        
        display.innerHTML = `
          <div style="text-align: center;">
            <h2 style="font-size: 2.5rem; margin: 0 0 10px 0; color: var(--primary-color);">${name}, ${country}</h2>
            <div style="font-size: 4rem; margin: 20px 0;">${description.split(' ')[0]}</div>
            <div style="font-size: 3rem; font-weight: bold; color: var(--secondary-color); margin: 15px 0;">${temperature}¬∞F</div>
            <div style="font-size: 1.2rem; color: var(--text-secondary); margin: 10px 0;">${description.substring(2)}</div>
            <div style="display: flex; gap: 30px; justify-content: center; margin-top: 20px; font-size: 1.1rem;">
              <div>
                <div style="color: var(--text-secondary);">Wind Speed</div>
                <div style="color: var(--primary-color); font-weight: bold;">${windspeed} mph</div>
              </div>
              <div>
                <div style="color: var(--text-secondary);">Coordinates</div>
                <div style="color: var(--primary-color); font-weight: bold; font-size: 0.9rem;">${latitude.toFixed(2)}¬∞, ${longitude.toFixed(2)}¬∞</div>
              </div>
            </div>
          </div>
        `;
      } catch (error) {
        display.innerHTML = `<p style="color: var(--accent-color);">‚ùå Could not fetch weather data. Please try another city.</p>`;
        console.error('Weather error:', error);
      }
    }

    // ===== CODE SYNTAX HIGHLIGHTER =====
    function highlightCode() {
      const code = document.getElementById('codeInput').value;
      const lang = document.getElementById('syntaxLang').value;
      const output = document.getElementById('highlightedCode');
      
      if (!code.trim()) {
        output.style.display = 'none';
        return;
      }
      
      let highlighted = code;
      
      // Simple syntax highlighting patterns
      const patterns = {
        javascript: [
          { regex: /(const|let|var|function|return|if|else|for|while|class|async|await|import|export)\b/g, color: '#ff79c6' },
          { regex: /'([^']+)'/g, color: '#50fa7b' },
          { regex: /"([^"]+)"/g, color: '#50fa7b' },
          { regex: /\b(\d+)\b/g, color: '#bd93f9' },
          { regex: /(\/\/.*$)/gm, color: '#6272a4' },
        ],
        python: [
          { regex: /(def|class|import|from|if|elif|else|for|while|return|async|await)\b/g, color: '#ff79c6' },
          { regex: /'([^']+)'/g, color: '#50fa7b' },
          { regex: /"([^"]+)"/g, color: '#50fa7b' },
          { regex: /\b(\d+)\b/g, color: '#bd93f9' },
          { regex: /(#.*$)/gm, color: '#6272a4' },
        ],
        html: [
          { regex: /(&lt;\/?[a-z]+[^&]*&gt;)/gi, color: '#ff79c6' },
          { regex: /([a-z-]+)=/gi, color: '#50fa7b' },
          { regex: /"([^"]+)"/g, color: '#f1fa8c' },
        ],
        css: [
          { regex: /([.#][a-z-]+)/gi, color: '#50fa7b' },
          { regex: /([a-z-]+):/gi, color: '#8be9fd' },
          { regex: /"([^"]+)"/g, color: '#f1fa8c' },
          { regex: /(\/\*.*?\*\/)/gs, color: '#6272a4' },
        ],
        sql: [
          { regex: /(SELECT|FROM|WHERE|INSERT|UPDATE|DELETE|JOIN|ON|GROUP BY|ORDER BY|HAVING|CREATE|TABLE|DATABASE)\b/gi, color: '#ff79c6' },
          { regex: /'([^']+)'/g, color: '#50fa7b' },
          { regex: /\b(\d+)\b/g, color: '#bd93f9' },
          { regex: /(--.*$)/gm, color: '#6272a4' },
        ]
      };
      
      highlighted = highlighted
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      if (patterns[lang]) {
        patterns[lang].forEach(pattern => {
          highlighted = highlighted.replace(pattern.regex, `<span style="color: ${pattern.color}">$&</span>`);
        });
      }
      
      output.innerHTML = `<pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">${highlighted}</pre>`;
      output.style.display = 'block';
    }

    // ===== MARKDOWN EDITOR =====
    function updateMarkdown() {
      const input = document.getElementById('markdownInput').value;
      const preview = document.getElementById('markdownPreview');
      
      let html = input
        // Headers
        .replace(/^### (.*$)/gim, '<h3 style="color: var(--primary-color); margin: 15px 0 10px 0;">$1</h3>')
        .replace(/^## (.*$)/gim, '<h2 style="color: var(--primary-color); margin: 20px 0 15px 0;">$1</h2>')
        .replace(/^# (.*$)/gim, '<h1 style="color: var(--primary-color); margin: 25px 0 20px 0;">$1</h1>')
        // Bold
        .replace(/\*\*(.+?)\*\*/g, '<strong style="color: var(--text-primary);">$1</strong>')
        // Italic
        .replace(/\*(.+?)\*/g, '<em style="color: var(--secondary-color);">$1</em>')
        // Code blocks
        .replace(/```(\w+)?\n([\s\S]+?)```/g, '<pre style="background: rgba(10,10,20,0.9); padding: 15px; border-radius: 8px; overflow-x: auto; margin: 15px 0;"><code>$2</code></pre>')
        // Inline code
        .replace(/`(.+?)`/g, '<code style="background: rgba(0,217,255,0.1); padding: 2px 6px; border-radius: 4px; color: var(--primary-color); font-family: monospace;">$1</code>')
        // Links
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color: var(--primary-color); text-decoration: underline;">$1</a>')
        // Lists
        .replace(/^\- (.+)$/gim, '<li style="margin: 5px 0;">$1</li>')
        .replace(/(<li.*<\/li>)/s, '<ul style="margin: 10px 0; padding-left: 25px;">$1</ul>')
        // Line breaks
        .replace(/\n\n/g, '</p><p style="margin: 15px 0;">')
        .replace(/\n/g, '<br>');
      
      preview.innerHTML = '<div style="margin: 0;">' + html + '</div>';
    }

    // ===== JSON FORMATTER =====
    function formatJSON() {
      const input = document.getElementById('jsonInput').value;
      const output = document.getElementById('jsonOutput');
      const error = document.getElementById('jsonError');
      
      try {
        const parsed = JSON.parse(input);
        const formatted = JSON.stringify(parsed, null, 2);
        output.innerHTML = `<pre style="margin: 0; color: white; font-family: 'Courier New', monospace;">${escapeHtml(formatted)}</pre>`;
        output.style.display = 'block';
        error.style.display = 'none';
      } catch (e) {
        error.textContent = '‚ùå Invalid JSON: ' + e.message;
        error.style.display = 'block';
        output.style.display = 'none';
      }
    }

    function minifyJSON() {
      const input = document.getElementById('jsonInput').value;
      const output = document.getElementById('jsonOutput');
      const error = document.getElementById('jsonError');
      
      try {
        const parsed = JSON.parse(input);
        const minified = JSON.stringify(parsed);
        output.innerHTML = `<pre style="margin: 0; color: white; font-family: 'Courier New', monospace; word-break: break-all;">${escapeHtml(minified)}</pre>`;
        output.style.display = 'block';
        error.style.display = 'none';
      } catch (e) {
        error.textContent = '‚ùå Invalid JSON: ' + e.message;
        error.style.display = 'block';
        output.style.display = 'none';
      }
    }

    function validateJSON() {
      const input = document.getElementById('jsonInput').value;
      const output = document.getElementById('jsonOutput');
      const error = document.getElementById('jsonError');
      
      try {
        JSON.parse(input);
        output.innerHTML = '<div style="color: #34c759; font-size: 1.2rem; text-align: center; padding: 20px;"><div style="font-size: 3rem;">‚úÖ</div><div style="margin-top: 10px;">Valid JSON!</div></div>';
        output.style.display = 'block';
        error.style.display = 'none';
      } catch (e) {
        error.textContent = '‚ùå Invalid JSON: ' + e.message;
        error.style.display = 'block';
        output.style.display = 'none';
      }
    }

    function escapeHtml(text) {
      return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // ===== REGEX TESTER =====
    function testRegex() {
      const pattern = document.getElementById('regexPattern').value;
      const testString = document.getElementById('regexTestString').value;
      const results = document.getElementById('regexResults');
      const error = document.getElementById('regexError');
      const matchCount = document.getElementById('regexMatchCount');
      const matchesDiv = document.getElementById('regexMatches');
      
      if (!pattern) {
        results.style.display = 'none';
        error.style.display = 'none';
        return;
      }
      
      try {
        let flags = '';
        if (document.getElementById('regexGlobal').checked) flags += 'g';
        if (document.getElementById('regexCaseInsensitive').checked) flags += 'i';
        if (document.getElementById('regexMultiline').checked) flags += 'm';
        
        const regex = new RegExp(pattern, flags);
        const matches = testString.match(regex);
        
        if (matches) {
          matchCount.textContent = matches.length;
          matchesDiv.innerHTML = matches.map((match, i) => 
            `<div style="margin: 8px 0; padding: 8px; background: rgba(0,217,255,0.1); border-left: 3px solid var(--primary-color); border-radius: 4px;">
              <span style="color: var(--primary-color); font-weight: bold;">Match ${i + 1}:</span> 
              <code style="color: white; font-family: monospace;">${escapeHtml(match)}</code>
            </div>`
          ).join('');
          results.style.display = 'block';
          error.style.display = 'none';
        } else {
          matchCount.textContent = '0';
          matchesDiv.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 15px;">No matches found</div>';
          results.style.display = 'block';
          error.style.display = 'none';
        }
      } catch (e) {
        error.textContent = '‚ùå Invalid regex: ' + e.message;
        error.style.display = 'block';
        results.style.display = 'none';
      }
    }

    // ===== PASSWORD STRENGTH ANALYZER =====
    function analyzePassword() {
      const password = document.getElementById('passwordInput').value;
      const feedback = document.getElementById('passwordFeedback');
      const score = document.getElementById('passwordScore');
      const strengthText = document.getElementById('passwordStrengthText');
      const emoji = document.getElementById('passwordEmoji');
      const crackTime = document.getElementById('passwordCrackTime');
      const strengthFill = document.getElementById('passwordStrengthFill');
      const suggestions = document.getElementById('passwordSuggestions');
      const suggestionsList = document.getElementById('passwordSuggestionsList');
      
      if (!password) {
        score.style.display = 'none';
        feedback.innerHTML = '';
        suggestions.style.display = 'none';
        strengthFill.style.width = '0%';
        return;
      }
      
      let strength = 0;
      const checks = {
        length: password.length >= 12,
        uppercase: /[A-Z]/.test(password),
        lowercase: /[a-z]/.test(password),
        numbers: /\d/.test(password),
        special: /[!@#$%^&*(),.?":{}|<>]/.test(password),
        noCommon: !['password', '123456', 'qwerty', 'admin'].some(common => password.toLowerCase().includes(common))
      };
      
      strength = Object.values(checks).filter(Boolean).length;
      const percentage = (strength / 6) * 100;
      strengthFill.style.width = percentage + '%';
      
      feedback.innerHTML = `
        <div style="padding: 10px; background: ${checks.length ? 'rgba(52,199,89,0.1)' : 'rgba(255,59,48,0.1)'}; border-radius: 8px; text-align: center;">
          <div style="color: ${checks.length ? '#34c759' : '#ff3b30'};">${checks.length ? '‚úì' : '‚úó'}</div>
          <div style="font-size: 0.9rem; margin-top: 5px;">Length ‚â• 12</div>
        </div>
        <div style="padding: 10px; background: ${checks.uppercase ? 'rgba(52,199,89,0.1)' : 'rgba(255,59,48,0.1)'}; border-radius: 8px; text-align: center;">
          <div style="color: ${checks.uppercase ? '#34c759' : '#ff3b30'};">${checks.uppercase ? '‚úì' : '‚úó'}</div>
          <div style="font-size: 0.9rem; margin-top: 5px;">Uppercase</div>
        </div>
        <div style="padding: 10px; background: ${checks.lowercase ? 'rgba(52,199,89,0.1)' : 'rgba(255,59,48,0.1)'}; border-radius: 8px; text-align: center;">
          <div style="color: ${checks.lowercase ? '#34c759' : '#ff3b30'};">${checks.lowercase ? '‚úì' : '‚úó'}</div>
          <div style="font-size: 0.9rem; margin-top: 5px;">Lowercase</div>
        </div>
        <div style="padding: 10px; background: ${checks.numbers ? 'rgba(52,199,89,0.1)' : 'rgba(255,59,48,0.1)'}; border-radius: 8px; text-align: center;">
          <div style="color: ${checks.numbers ? '#34c759' : '#ff3b30'};">${checks.numbers ? '‚úì' : '‚úó'}</div>
          <div style="font-size: 0.9rem; margin-top: 5px;">Numbers</div>
        </div>
        <div style="padding: 10px; background: ${checks.special ? 'rgba(52,199,89,0.1)' : 'rgba(255,59,48,0.1)'}; border-radius: 8px; text-align: center;">
          <div style="color: ${checks.special ? '#34c759' : '#ff3b30'};">${checks.special ? '‚úì' : '‚úó'}</div>
          <div style="font-size: 0.9rem; margin-top: 5px;">Special Chars</div>
        </div>
        <div style="padding: 10px; background: ${checks.noCommon ? 'rgba(52,199,89,0.1)' : 'rgba(255,59,48,0.1)'}; border-radius: 8px; text-align: center;">
          <div style="color: ${checks.noCommon ? '#34c759' : '#ff3b30'};">${checks.noCommon ? '‚úì' : '‚úó'}</div>
          <div style="font-size: 0.9rem; margin-top: 5px;">Not Common</div>
        </div>
      `;
      
      const strengthLevels = [
        { emoji: 'üîì', text: 'Very Weak', time: 'Instant', color: '#ff3b30' },
        { emoji: 'üîê', text: 'Weak', time: '< 1 minute', color: '#ff9500' },
        { emoji: 'üîê', text: 'Fair', time: '~ 1 hour', color: '#ffcc00' },
        { emoji: 'üîí', text: 'Good', time: '~ 1 month', color: '#32d74b' },
        { emoji: 'üîí', text: 'Strong', time: '~ 5 years', color: '#00d9ff' },
        { emoji: 'üõ°Ô∏è', text: 'Very Strong', time: '100+ years', color: '#a855f7' }
      ];
      
      const level = strengthLevels[strength];
      emoji.textContent = level.emoji;
      strengthText.textContent = level.text;
      strengthText.style.color = level.color;
      crackTime.textContent = `Estimated crack time: ${level.time}`;
      score.style.display = 'block';
      
      const tips = [];
      if (!checks.length) tips.push('Use at least 12 characters');
      if (!checks.uppercase) tips.push('Add uppercase letters (A-Z)');
      if (!checks.lowercase) tips.push('Add lowercase letters (a-z)');
      if (!checks.numbers) tips.push('Include numbers (0-9)');
      if (!checks.special) tips.push('Add special characters (!@#$%...)');
      if (!checks.noCommon) tips.push('Avoid common passwords');
      
      if (tips.length > 0) {
        suggestionsList.innerHTML = tips.map(tip => `<li>${tip}</li>`).join('');
        suggestions.style.display = 'block';
      } else {
        suggestions.style.display = 'none';
      }
    }

    // ===== TEXT DIFF CHECKER =====
    function calculateDiff() {
      const text1 = document.getElementById('diffText1').value;
      const text2 = document.getElementById('diffText2').value;
      const results = document.getElementById('diffResults');
      const output = document.getElementById('diffOutput');
      
      const lines1 = text1.split('\n');
      const lines2 = text2.split('\n');
      
      let same = 0, changed = 0, removed = 0, added = 0;
      let html = '';
      
      const maxLines = Math.max(lines1.length, lines2.length);
      
      for (let i = 0; i < maxLines; i++) {
        const line1 = lines1[i];
        const line2 = lines2[i];
        
        if (line1 === line2 && line1 !== undefined) {
          same++;
          html += `<div style="padding: 5px; background: rgba(52,199,89,0.05); border-left: 3px solid #34c759; margin: 2px 0;"><span style="color: #666; margin-right: 10px;">${i + 1}</span>${escapeHtml(line1)}</div>`;
        } else if (line1 !== undefined && line2 !== undefined) {
          changed++;
          html += `<div style="padding: 5px; background: rgba(255,149,0,0.05); border-left: 3px solid #ff9500; margin: 2px 0;"><span style="color: #666; margin-right: 10px;">${i + 1}</span><span style="background: rgba(255,59,48,0.2); text-decoration: line-through;">${escapeHtml(line1)}</span> ‚Üí <span style="background: rgba(0,217,255,0.2);">${escapeHtml(line2)}</span></div>`;
        } else if (line1 !== undefined) {
          removed++;
          html += `<div style="padding: 5px; background: rgba(255,59,48,0.05); border-left: 3px solid #ff3b30; margin: 2px 0;"><span style="color: #666; margin-right: 10px;">${i + 1}</span><span style="background: rgba(255,59,48,0.2); text-decoration: line-through;">- ${escapeHtml(line1)}</span></div>`;
        } else if (line2 !== undefined) {
          added++;
          html += `<div style="padding: 5px; background: rgba(0,217,255,0.05); border-left: 3px solid #00d9ff; margin: 2px 0;"><span style="color: #666; margin-right: 10px;">${i + 1}</span><span style="background: rgba(0,217,255,0.2);">+ ${escapeHtml(line2)}</span></div>`;
        }
      }
      
      document.getElementById('diffSame').textContent = same;
      document.getElementById('diffChanged').textContent = changed;
      document.getElementById('diffRemoved').textContent = removed;
      document.getElementById('diffAdded').textContent = added;
      output.innerHTML = html;
      results.style.display = 'block';
    }

    // ===== BASE64 ENCODER/DECODER =====
    let base64Mode = 'encode';

    function setBase64Mode(mode) {
      base64Mode = mode;
      document.getElementById('base64EncodeBtn').style.background = mode === 'encode' ? '' : 'var(--secondary-color)';
      document.getElementById('base64DecodeBtn').style.background = mode === 'decode' ? '' : 'var(--secondary-color)';
      document.getElementById('base64Input').placeholder = mode === 'encode' ? 'Enter text to encode...' : 'Enter Base64 to decode...';
      document.getElementById('base64Output').style.display = 'none';
      document.getElementById('base64CopyBtn').style.display = 'none';
    }

    function handleBase64File(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        const base64 = e.target.result;
        document.getElementById('base64Input').value = base64;
        processBase64();
      };
      reader.readAsDataURL(file);
    }

    function processBase64() {
      const input = document.getElementById('base64Input').value;
      const output = document.getElementById('base64Output');
      const copyBtn = document.getElementById('base64CopyBtn');
      
      if (!input) return;
      
      try {
        let result;
        if (base64Mode === 'encode') {
          result = btoa(unescape(encodeURIComponent(input)));
        } else {
          result = decodeURIComponent(escape(atob(input)));
        }
        
        output.innerHTML = `<div style="color: white; word-break: break-all;">${escapeHtml(result)}</div>`;
        output.style.display = 'block';
        copyBtn.style.display = 'block';
      } catch (e) {
        output.innerHTML = `<div style="color: #ff3b30;">‚ùå Error: ${e.message}</div>`;
        output.style.display = 'block';
        copyBtn.style.display = 'none';
      }
    }

    function copyBase64() {
      const output = document.getElementById('base64Output').textContent;
      navigator.clipboard.writeText(output).then(() => {
        const btn = document.getElementById('base64CopyBtn');
        const originalText = btn.textContent;
        btn.textContent = '‚úÖ Copied!';
        setTimeout(() => btn.textContent = originalText, 2000);
      });
    }

    // Drag and drop for Base64 file upload
    const dropZone = document.getElementById('base64FileUpload');
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = 'var(--primary-color)';
      dropZone.style.background = 'rgba(0,217,255,0.05)';
    });
    
    dropZone.addEventListener('dragleave', () => {
      dropZone.style.borderColor = 'rgba(0,217,255,0.3)';
      dropZone.style.background = '';
    });
    
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.style.borderColor = 'rgba(0,217,255,0.3)';
      dropZone.style.background = '';
      
      const file = e.dataTransfer.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
          const base64 = event.target.result;
          document.getElementById('base64Input').value = base64;
          processBase64();
        };
        reader.readAsDataURL(file);
      }
    });
  </script>

  <!-- 3D Block Builder (Mini Minecraft) -->
  <script>
    // Initialize THREE.js 3D Minecraft
    let minecraft3D = {
      scene: null,
      camera: null,
      renderer: null,
      world: new Map(), // Map of "x,y,z" -> blockType
      worldSize: { x: 200, y: 25, z: 200 }, // Increased from 100x20x100 to 200x25x200
      player: {
        position: new THREE.Vector3(100, 15, 100), // Adjusted spawn to new center
        velocity: new THREE.Vector3(0, 0, 0),
        yaw: 0,
        pitch: 0,
        onGround: false,
        height: 1.8,
        width: 0.6
      },
      controls: {
        forward: false,
        backward: false,
        left: false,
        right: false,
        jump: false,
        sprint: false
      },
      inventory: [],
      hotbar: [null, null, null, null, null],
      selectedSlot: 0,
      targetBlock: null,
      miningBlock: null,
      miningProgress: 0,
      mouseDown: { left: false, right: false },
      pointerLocked: false,
      paused: false,
      music: null, // Background music
      blockMeshes: new Map(),
      materialCache: new Map(), // Cache materials for performance
      geometryCache: null, // Reuse geometry for all blocks
      renderDistance: 40, // Only render blocks within 40 blocks (30+ visible with fog at 50)
      lastPlayerChunk: { x: -999, z: -999 }, // Track player chunk for optimization
      timeOfDay: 0, // 0-1, where 0=dawn, 0.5=dusk, 1=dawn again
      dayNightCycleDuration: 300, // 5 minutes in seconds
      ambientLight: null, // Will store the ambient light reference
      directionalLight: null, // Will store the directional light reference
      animals: [],
      villages: [], // New: village structures
      villagers: [], // New: wandering villagers
      recipes: {
        'wooden_pickaxe': { requires: { 'wood': 3, 'stick': 2 }, result: 'wooden_pickaxe', name: 'Wooden Pickaxe', emoji: '‚õèÔ∏è' },
        'stick': { requires: { 'wood': 2 }, result: 'stick', count: 4, name: 'Stick', emoji: 'ü™µ' },
        'crafting_table': { requires: { 'wood': 4 }, result: 'crafting_table', name: 'Crafting Table', emoji: 'üî®' },
        'stone_pickaxe': { requires: { 'stone': 3, 'stick': 2 }, result: 'stone_pickaxe', name: 'Stone Pickaxe', emoji: '‚õèÔ∏è' }
      },
      blockInfo: {
        grass: { 
          color: 0x7cfc00, 
          topColor: 0x90ee90, 
          sideColor: 0x7cfc00, 
          bottomColor: 0x8b4513,
          mineTime: 0.5, 
          tool: null, 
          emoji: 'üü©' 
        },
        dirt: { 
          color: 0x8b4513, 
          mineTime: 0.5, 
          tool: null, 
          emoji: 'üü´' 
        },
        stone: { 
          color: 0x9ca0a3, 
          mineTime: 2, 
          tool: 'wooden_pickaxe', 
          emoji: '‚¨ú' 
        },
        wood: { 
          color: 0xd2691e,
          topColor: 0xa0522d,
          sideColor: 0xd2691e,
          mineTime: 1, 
          tool: null, 
          emoji: 'ü™µ' 
        },
        oak_wood: { 
          color: 0x8b6914,
          topColor: 0x6b5214,
          sideColor: 0x8b6914,
          mineTime: 1, 
          tool: null, 
          emoji: 'üü´' 
        },
        birch_wood: { 
          color: 0xf5deb3,
          topColor: 0xd2b48c,
          sideColor: 0xf5deb3,
          mineTime: 1, 
          tool: null, 
          emoji: 'üü®' 
        },
        spruce_wood: { 
          color: 0x654321,
          topColor: 0x4a2f17,
          sideColor: 0x654321,
          mineTime: 1, 
          tool: null, 
          emoji: 'üü§' 
        },
        jungle_wood: { 
          color: 0x9b6e3d,
          topColor: 0x7d5830,
          sideColor: 0x9b6e3d,
          mineTime: 1, 
          tool: null, 
          emoji: 'üüß' 
        },
        leaves: { 
          color: 0x228b22, 
          mineTime: 0.3, 
          tool: null, 
          emoji: 'üçÉ',
          transparent: true,
          opacity: 0.7
        },
        dark_leaves: { 
          color: 0x0d5016, 
          mineTime: 0.3, 
          tool: null, 
          emoji: 'üåø',
          transparent: true,
          opacity: 0.7
        },
        birch_leaves: { 
          color: 0x80c34d, 
          mineTime: 0.3, 
          tool: null, 
          emoji: 'üçÄ',
          transparent: true,
          opacity: 0.7
        },
        water: { 
          color: 0x4da6ff, 
          mineTime: -1, 
          tool: null, 
          emoji: 'üíß', 
          transparent: true,
          opacity: 0.6
        },
        crafting_table: { 
          color: 0xdaa520,
          topColor: 0xcd853f,
          sideColor: 0xd2691e,
          mineTime: 1, 
          tool: null, 
          emoji: 'üî®' 
        },
        coal_ore: { 
          color: 0x4a4a4a,
          mineTime: 3, 
          tool: 'wooden_pickaxe', 
          emoji: '‚ö´' 
        },
        iron_ore: { 
          color: 0xc9b8a0,
          mineTime: 4, 
          tool: 'stone_pickaxe', 
          emoji: 'üî∂' 
        },
        planks: {
          color: 0xdeb887,
          mineTime: 0.8,
          tool: null,
          emoji: 'üü´'
        },
        cobblestone: {
          color: 0x808080,
          mineTime: 2,
          tool: 'wooden_pickaxe',
          emoji: 'üî≤'
        },
        glass: {
          color: 0xadd8e6,
          mineTime: 0.5,
          tool: null,
          emoji: 'üî∑',
          transparent: true,
          opacity: 0.4
        },
        wool: {
          color: 0xffffff,
          mineTime: 0.5,
          tool: null,
          emoji: '‚¨ú'
        },
        leather: { emoji: 'üü§', nonBlock: true },
        meat: { emoji: 'üçñ', nonBlock: true },
        feather: { emoji: 'ü™∂', nonBlock: true }
      }
    };

    function initMinecraft3D() {
      const container = document.getElementById('minecraftContainer');
      if (!container || !THREE) return;

      // Add background music - peaceful Minecraft-style ambience
      if (!minecraft3D.music) {
        minecraft3D.music = new Audio();
        // Using a royalty-free ambient music URL (you can replace with your own)
        minecraft3D.music.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA='; // Placeholder
        minecraft3D.music.loop = true;
        minecraft3D.music.volume = 0.3;
        
        // Try to play (might be blocked by browser autoplay policy)
        minecraft3D.music.play().catch(() => {
          console.log('Music autoplay blocked - will play on first interaction');
          // Play on first user interaction
          document.addEventListener('click', () => {
            if (minecraft3D.music && minecraft3D.music.paused) {
              minecraft3D.music.play();
            }
          }, { once: true });
        });
      }

      // Create scene with prettier sky gradient
      minecraft3D.scene = new THREE.Scene();
      minecraft3D.scene.background = new THREE.Color(0x87CEEB);
      minecraft3D.scene.fog = new THREE.Fog(0x87CEEB, 25, 50); // Reduced from 20,90 to 25,50 for performance

      // Create camera
      minecraft3D.camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 60); // Reduced far plane from 1000 to 60
      minecraft3D.camera.position.copy(minecraft3D.player.position);
      minecraft3D.camera.position.y += minecraft3D.player.height;

      // Create renderer optimized for performance
      minecraft3D.renderer = new THREE.WebGLRenderer({ 
        antialias: false, // Disabled for performance
        powerPreference: "high-performance"
      });
      minecraft3D.renderer.setSize(container.clientWidth, container.clientHeight);
      minecraft3D.renderer.shadowMap.enabled = false; // Disabled shadows for performance
      container.innerHTML = '';
      container.appendChild(minecraft3D.renderer.domElement);

      // Add balanced lighting - store references for day/night cycle
      minecraft3D.ambientLight = new THREE.AmbientLight(0xffffff, 0.65);
      minecraft3D.scene.add(minecraft3D.ambientLight);
      
      // Main sun light - shadows disabled for performance
      minecraft3D.directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
      minecraft3D.directionalLight.position.set(50, 100, 50);
      minecraft3D.directionalLight.castShadow = false; // Disabled for performance
      minecraft3D.scene.add(minecraft3D.directionalLight);

      // Generate world
      generateWorld3D();

      // Setup pointer lock
      container.addEventListener('click', () => {
        container.requestPointerLock();
      });

      document.addEventListener('pointerlockchange', () => {
        minecraft3D.pointerLocked = document.pointerLockElement === container;
      });

      // Mouse movement for camera
      document.addEventListener('mousemove', onMouseMove3D);
      
      // Mouse buttons
      container.addEventListener('mousedown', (e) => {
        if (!minecraft3D.pointerLocked) return;
        if (e.button === 0) minecraft3D.mouseDown.left = true; // Left click - mine
        if (e.button === 2) minecraft3D.mouseDown.right = true; // Right click - place
        e.preventDefault();
      });
      
      container.addEventListener('mouseup', (e) => {
        if (e.button === 0) {
          minecraft3D.mouseDown.left = false;
          minecraft3D.miningBlock = null;
          minecraft3D.miningProgress = 0;
          updateMiningProgressUI();
        }
        if (e.button === 2) minecraft3D.mouseDown.right = false;
      });

      container.addEventListener('contextmenu', (e) => e.preventDefault());

      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          minecraft3D.paused = !minecraft3D.paused;
          if (minecraft3D.paused) {
            document.exitPointerLock();
          }
          return;
        }
        if (minecraft3D.paused) return;
        
        if (e.key === 'w' || e.key === 'W') minecraft3D.controls.forward = true;
        if (e.key === 's' || e.key === 'S') minecraft3D.controls.backward = true;
        if (e.key === 'a' || e.key === 'A') minecraft3D.controls.left = true;
        if (e.key === 'd' || e.key === 'D') minecraft3D.controls.right = true;
        if (e.key === ' ') minecraft3D.controls.jump = true;
        if (e.key === 'Shift') minecraft3D.controls.sprint = true;
        if (e.key === 'c' || e.key === 'C') openMcCrafting();
        if (e.key >= '1' && e.key <= '5') selectHotbarSlot(parseInt(e.key) - 1);
      });

      document.addEventListener('keyup', (e) => {
        if (e.key === 'w' || e.key === 'W') minecraft3D.controls.forward = false;
        if (e.key === 's' || e.key === 'S') minecraft3D.controls.backward = false;
        if (e.key === 'a' || e.key === 'A') minecraft3D.controls.left = false;
        if (e.key === 'd' || e.key === 'D') minecraft3D.controls.right = false;
        if (e.key === ' ') minecraft3D.controls.jump = false;
        if (e.key === 'Shift') minecraft3D.controls.sprint = false;
      });

      // Start game loop
      updateInventoryUI();
      animate3D();
    }

    function generateWorld3D() {
      minecraft3D.world.clear();
      minecraft3D.blockMeshes.forEach(mesh => minecraft3D.scene.remove(mesh));
      minecraft3D.blockMeshes.clear();
      minecraft3D.animals = [];

      const size = minecraft3D.worldSize;
      
      // Generate terrain with mountains and varied height
      for (let x = 0; x < size.x; x++) {
        for (let z = 0; z < size.z; z++) {
          // Create mountain ranges with multiple noise layers
          const mountain1 = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 6;
          const mountain2 = Math.sin(x * 0.1 + 20) * Math.cos(z * 0.1 + 20) * 4;
          const hills = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 2;
          const height = Math.floor(6 + mountain1 + mountain2 + hills);
          
          // Build terrain layers with caves
          for (let y = 0; y < Math.min(height, size.y - 1); y++) {
            // Cave generation using 3D noise
            const caveNoise = Math.sin(x * 0.2 + y * 0.3) * Math.cos(z * 0.2 + y * 0.3);
            const isCave = y > 2 && y < height - 3 && caveNoise > 0.5;
            
            if (!isCave) {
              if (y === height - 1) {
                setBlock3D(x, y, z, 'grass');
              } else if (y > height - 4) {
                setBlock3D(x, y, z, 'dirt');
              } else {
                setBlock3D(x, y, z, 'stone');
                
                // Add ores in stone layers
                if (Math.random() < 0.02) {
                  if (y < 5) {
                    setBlock3D(x, y, z, 'iron_ore'); // Iron deeper down
                  } else {
                    setBlock3D(x, y, z, 'coal_ore'); // Coal higher up
                  }
                }
              }
            }
          }

          // Add trees on flat-ish areas - now with variety!
          if (Math.random() < 0.02 && height < size.y - 7 && height > 5) {
            // Choose tree type based on biome/height
            let woodType, leafType;
            if (height > 10) {
              // High areas: Spruce trees (dark)
              woodType = 'spruce_wood';
              leafType = 'dark_leaves';
            } else if (Math.random() < 0.3) {
              // 30% chance: Birch trees (light)
              woodType = 'birch_wood';
              leafType = 'birch_leaves';
            } else if (Math.random() < 0.2) {
              // 20% chance: Jungle trees
              woodType = 'jungle_wood';
              leafType = 'leaves';
            } else if (Math.random() < 0.3) {
              // 30% chance: Oak trees
              woodType = 'oak_wood';
              leafType = 'leaves';
            } else {
              // Regular wood
              woodType = 'wood';
              leafType = 'leaves';
            }
            
            const treeHeight = 4 + Math.floor(Math.random() * 3);
            // Tree trunk
            for (let y = 0; y < treeHeight; y++) {
              setBlock3D(x, height + y, z, woodType);
            }
            // Tree leaves (spherical crown)
            const crownY = height + treeHeight;
            for (let dx = -2; dx <= 2; dx++) {
              for (let dz = -2; dz <= 2; dz++) {
                for (let dy = -2; dy <= 1; dy++) {
                  if (dx === 0 && dz === 0 && dy < 0) continue;
                  if (Math.abs(dx) === 2 && Math.abs(dz) === 2 && Math.abs(dy) === 2) continue;
                  if (Math.random() < 0.8) {
                    const lx = x + dx, ly = crownY + dy, lz = z + dz;
                    if (lx >= 0 && lx < size.x && ly >= 0 && ly < size.y && lz >= 0 && lz < size.z) {
                      setBlock3D(lx, ly, lz, leafType);
                    }
                  }
                }
              }
            }
          }
        }
      }

      // Add water sources that flow realistically
      const waterSources = [];
      for (let i = 0; i < 3; i++) {
        const x = Math.floor(Math.random() * (size.x - 10)) + 5;
        const z = Math.floor(Math.random() * (size.z - 10)) + 5;
        const y = getTopBlockAt(x, z);
        
        // Only place water on solid ground (valleys)
        if (y > 0 && y < 8 && getBlock3D(x, y, z)) {
          waterSources.push({ x, y: y + 1, z, level: 5 });
        }
      }

      // Simulate water flow - flows downhill and spreads
      waterSources.forEach(source => {
        const queue = [{ x: source.x, y: source.y, z: source.z, level: source.level }];
        const visited = new Set();
        
        while (queue.length > 0) {
          const current = queue.shift();
          const key = `${current.x},${current.y},${current.z}`;
          
          if (visited.has(key) || current.level <= 0) continue;
          visited.add(key);
          
          // Check if this position is valid (air above solid block)
          const below = getBlock3D(current.x, current.y - 1, current.z);
          const here = getBlock3D(current.x, current.y, current.z);
          
          if (below && below !== 'water' && !here) {
            // Place water here
            setBlock3D(current.x, current.y, current.z, 'water');
            
            // Water flows to adjacent blocks at same or lower level
            const directions = [
              { dx: 1, dz: 0 },
              { dx: -1, dz: 0 },
              { dx: 0, dz: 1 },
              { dx: 0, dz: -1 }
            ];
            
            directions.forEach(dir => {
              const nx = current.x + dir.dx;
              const nz = current.z + dir.dz;
              
              if (nx >= 0 && nx < size.x && nz >= 0 && nz < size.z) {
                // Check if we can flow here
                const neighborY = getTopBlockAt(nx, nz);
                
                // Flow downward if there's a drop
                if (neighborY < current.y - 1) {
                  queue.push({ x: nx, y: neighborY + 1, z: nz, level: current.level - 0.5 });
                }
                // Flow sideways at same level with reduced strength
                else if (neighborY <= current.y) {
                  queue.push({ x: nx, y: current.y, z: nz, level: current.level - 1 });
                }
              }
            });
          }
        }
      });

      // Generate villages in suitable flat areas
      generateVillages();

      // Spawn animals on grass (reduced from 30 to 20 for performance)
      for (let i = 0; i < 20; i++) {
        const x = Math.floor(Math.random() * (size.x - 10)) + 5;
        const z = Math.floor(Math.random() * (size.z - 10)) + 5;
        const y = getTopBlockAt(x, z);
        
        if (y > 0 && getBlock3D(x, y, z) === 'grass') {
          const types = ['cow', 'pig', 'chicken'];
          const type = types[Math.floor(Math.random() * types.length)];
          spawnAnimal(x, y + 1, z, type);
        }
      }

      // Set player spawn on high ground
      let spawnX = 50, spawnZ = 50;
      let maxHeight = 0;
      for (let sx = 40; sx < 60; sx++) {
        for (let sz = 40; sz < 60; sz++) {
          const h = getTopBlockAt(sx, sz);
          if (h > maxHeight && h < 15) {
            maxHeight = h;
            spawnX = sx;
            spawnZ = sz;
          }
        }
      }
      minecraft3D.player.position.set(spawnX, maxHeight + 2, spawnZ);
    }

    function spawnAnimal(x, y, z, type) {
      const colors = { cow: 0x000000, pig: 0xffc0cb, chicken: 0xffffff };
      
      // Create animal body
      const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.6);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: colors[type] });
      const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
      
      // Create a group to hold all parts
      const animalGroup = new THREE.Group();
      animalGroup.add(bodyMesh);
      
      // Add realistic face with eyes
      const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
      const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
      const pupilMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
      
      // Left eye
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.15, 0.2, 0.3);
      animalGroup.add(leftEye);
      
      const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), pupilMaterial);
      leftPupil.position.set(-0.15, 0.2, 0.35);
      animalGroup.add(leftPupil);
      
      // Right eye
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.15, 0.2, 0.3);
      animalGroup.add(rightEye);
      
      const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), pupilMaterial);
      rightPupil.position.set(0.15, 0.2, 0.35);
      animalGroup.add(rightPupil);
      
      // Add snout/beak based on animal type
      if (type === 'pig') {
        // Pig snout
        const snoutGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.15, 8);
        const snoutMaterial = new THREE.MeshLambertMaterial({ color: 0xffb6c1 });
        const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
        snout.rotation.x = Math.PI / 2;
        snout.position.set(0, 0, 0.4);
        animalGroup.add(snout);
        
        // Nostrils
        const nostrilGeometry = new THREE.SphereGeometry(0.03, 8, 8);
        const nostrilMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const nostril1 = new THREE.Mesh(nostrilGeometry, nostrilMaterial);
        nostril1.position.set(-0.05, 0, 0.45);
        animalGroup.add(nostril1);
        const nostril2 = new THREE.Mesh(nostrilGeometry, nostrilMaterial);
        nostril2.position.set(0.05, 0, 0.45);
        animalGroup.add(nostril2);
        
        // Pig ears
        const earGeometry = new THREE.BoxGeometry(0.15, 0.2, 0.05);
        const earMaterial = new THREE.MeshLambertMaterial({ color: 0xffc0cb });
        const leftEar = new THREE.Mesh(earGeometry, earMaterial);
        leftEar.position.set(-0.25, 0.4, 0);
        leftEar.rotation.z = -0.3;
        animalGroup.add(leftEar);
        const rightEar = new THREE.Mesh(earGeometry, earMaterial);
        rightEar.position.set(0.25, 0.4, 0);
        rightEar.rotation.z = 0.3;
        animalGroup.add(rightEar);
      } else if (type === 'chicken') {
        // Chicken beak
        const beakGeometry = new THREE.ConeGeometry(0.08, 0.15, 4);
        const beakMaterial = new THREE.MeshLambertMaterial({ color: 0xffa500 });
        const beak = new THREE.Mesh(beakGeometry, beakMaterial);
        beak.rotation.x = Math.PI / 2;
        beak.position.set(0, 0, 0.4);
        animalGroup.add(beak);
        
        // Chicken comb (red thing on head)
        const combGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.05);
        const combMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const comb = new THREE.Mesh(combGeometry, combMaterial);
        comb.position.set(0, 0.5, 0.1);
        animalGroup.add(comb);
      } else if (type === 'cow') {
        // Cow snout
        const snoutGeometry = new THREE.BoxGeometry(0.25, 0.2, 0.2);
        const snoutMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
        snout.position.set(0, -0.1, 0.4);
        animalGroup.add(snout);
        
        // Cow horns
        const hornGeometry = new THREE.ConeGeometry(0.05, 0.2, 8);
        const hornMaterial = new THREE.MeshLambertMaterial({ color: 0xdddddd });
        const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
        leftHorn.position.set(-0.2, 0.5, 0);
        leftHorn.rotation.z = -0.3;
        animalGroup.add(leftHorn);
        const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
        rightHorn.position.set(0.2, 0.5, 0);
        rightHorn.rotation.z = 0.3;
        animalGroup.add(rightHorn);
        
        // Cow spots
        const spotGeometry = new THREE.CircleGeometry(0.1, 8);
        const spotMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
        for (let i = 0; i < 3; i++) {
          const spot = new THREE.Mesh(spotGeometry, spotMaterial);
          spot.position.set(
            (Math.random() - 0.5) * 0.4,
            (Math.random() - 0.5) * 0.6,
            0.31
          );
          animalGroup.add(spot);
        }
      }
      
      animalGroup.position.set(x, y, z);
      animalGroup.castShadow = true;
      
      minecraft3D.scene.add(animalGroup);
      minecraft3D.animals.push({
        mesh: animalGroup,
        type,
        health: 10,
        position: new THREE.Vector3(x, y, z),
        velocity: new THREE.Vector3(0, 0, 0),
        wander: Math.random() * Math.PI * 2
      });
    }

    function generateVillages() {
      // Clear old villages and villagers
      minecraft3D.villages = [];
      minecraft3D.villagers.forEach(v => minecraft3D.scene.remove(v.mesh));
      minecraft3D.villagers = [];
      
      const size = minecraft3D.worldSize;
      const numVillages = 6 + Math.floor(Math.random() * 5); // 6-10 villages (increased from 3-5)
      
      for (let v = 0; v < numVillages; v++) {
        // Find area for village (can be on hills now)
        let villageX, villageZ, villageY;
        let attempts = 0;
        let foundSpot = false;
        
        while (!foundSpot && attempts < 150) {
          villageX = Math.floor(Math.random() * (size.x - 30)) + 15;
          villageZ = Math.floor(Math.random() * (size.z - 30)) + 15;
          villageY = getTopBlockAt(villageX, villageZ);
          
          // Can be on hills now, just needs to be above water
          if (villageY > 4 && villageY < size.y - 8) {
            foundSpot = true;
          }
          attempts++;
        }
        
        if (!foundSpot) continue;
        
        // DON'T flatten the whole area - let villages adapt to terrain!
        // Instead, we'll flatten individual house spots
        
        const village = {
          x: villageX,
          y: villageY,
          z: villageZ,
          radius: 10,
          buildings: []
        };
        
        // Generate 4-6 buildings in village
        const numBuildings = 4 + Math.floor(Math.random() * 3);
        const buildingPositions = [
          { x: -6, z: -6 },
          { x: 6, z: -6 },
          { x: -6, z: 6 },
          { x: 6, z: 6 },
          { x: 0, z: -8 },
          { x: -8, z: 0 },
          { x: 8, z: 0 },
          { x: 0, z: 8 }
        ];
        
        // Create paths between village center and houses (cobblestone)
        for (let b = 0; b < Math.min(numBuildings, buildingPositions.length); b++) {
          const pos = buildingPositions[b];
          
          // Path from center to building
          const steps = 10;
          for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const px = Math.floor(villageX + pos.x * t);
            const pz = Math.floor(villageZ + pos.z * t);
            const py = getTopBlockAt(px, pz);
            setBlock3D(px, py, pz, 'cobblestone');
          }
        }
        
        for (let b = 0; b < Math.min(numBuildings, buildingPositions.length); b++) {
          const pos = buildingPositions[b];
          const bx = villageX + pos.x;
          const bz = villageZ + pos.z;
          
          // Build house structure
          buildHouse(bx, villageY, bz);
          village.buildings.push({ x: bx, z: bz });
        }
        
        // Add a central well or gathering point
        buildWell(villageX, villageY, villageZ);
        
        minecraft3D.villages.push(village);
        
        // Spawn 3-5 villagers per village
        const numVillagers = 3 + Math.floor(Math.random() * 3);
        for (let i = 0; i < numVillagers; i++) {
          const vx = villageX + (Math.random() - 0.5) * 8;
          const vz = villageZ + (Math.random() - 0.5) * 8;
          const vy = villageY + 1;
          spawnVillager(vx, vy, vz, village);
        }
      }
    }

    function buildHouse(x, y, z) {
      const width = 4;
      const height = 4;
      const depth = 4;
      
      // First, flatten the ground for the house (5x5 area)
      for (let dx = -1; dx < width + 1; dx++) {
        for (let dz = -1; dz < depth + 1; dz++) {
          const wx = x + dx;
          const wz = z + dz;
          const currentY = getTopBlockAt(wx, wz);
          
          // Clear above
          for (let clearY = y + 1; clearY < y + 10; clearY++) {
            if (getBlock3D(wx, clearY, wz)) {
              setBlock3D(wx, clearY, wz, null);
            }
          }
          
          // Fill below or remove above to match house level
          if (currentY < y) {
            for (let fillY = currentY; fillY < y; fillY++) {
              setBlock3D(wx, fillY, wz, 'dirt');
            }
          } else if (currentY > y) {
            for (let removeY = y + 1; removeY <= currentY; removeY++) {
              setBlock3D(wx, removeY, wz, null);
            }
          }
          
          // Set grass on top
          setBlock3D(wx, y, wz, 'grass');
        }
      }
      
      // Build walls with planks
      for (let dx = 0; dx < width; dx++) {
        for (let dz = 0; dz < depth; dz++) {
          // Floor
          setBlock3D(x + dx, y, z + dz, 'planks');
          
          for (let dy = 1; dy < height; dy++) {
            // Walls (hollow inside)
            if (dx === 0 || dx === width - 1 || dz === 0 || dz === depth - 1) {
              // Door opening on front wall
              if (dz === 0 && dx === Math.floor(width / 2) && dy < 3) {
                continue; // Leave door space
              }
              // Windows
              else if (dy === 2 && ((dx === 1 && dz === 0) || (dx === width - 2 && dz === 0))) {
                setBlock3D(x + dx, y + dy, z + dz, 'glass');
              } else {
                setBlock3D(x + dx, y + dy, z + dz, 'planks');
              }
            }
          }
          
          // Roof (cobblestone)
          if (dx === 0 || dx === width - 1 || dz === 0 || dz === depth - 1) {
            setBlock3D(x + dx, y + height, z + dz, 'cobblestone');
          }
          // Peaked roof
          if (dx === 1 || dx === width - 2) {
            setBlock3D(x + dx, y + height + 1, z + dz, 'cobblestone');
          }
        }
      }
      
      // Add interior light source (wool block)
      setBlock3D(x + Math.floor(width / 2), y + height - 1, z + Math.floor(depth / 2), 'wool');
    }

    function buildWell(x, y, z) {
      // Build well structure (3x3 cobblestone ring)
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          if (dx === 0 && dz === 0) {
            // Water in center, dig down 2 blocks
            setBlock3D(x, y, z, 'water');
            setBlock3D(x, y - 1, z, 'water');
            setBlock3D(x, y - 2, z, 'cobblestone');
          } else if (Math.abs(dx) + Math.abs(dz) <= 1) {
            // Inner ring
            setBlock3D(x + dx, y + 1, z + dz, 'cobblestone');
          } else {
            // Outer corners
            setBlock3D(x + dx, y + 1, z + dz, 'cobblestone');
          }
        }
      }
    }

    function spawnVillager(x, y, z, village) {
      // Create villager body (like Steve but with different colors)
      const bodyGeometry = new THREE.BoxGeometry(0.5, 1.2, 0.3);
      const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); // Brown robe
      const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
      bodyMesh.position.y = 0.6;
      
      // Create head
      const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac }); // Skin tone
      const headMesh = new THREE.Mesh(headGeometry, headMaterial);
      headMesh.position.y = 1.5;
      
      // Create villager group
      const villagerGroup = new THREE.Group();
      villagerGroup.add(bodyMesh);
      villagerGroup.add(headMesh);
      
      // Add simple face features
      const eyeGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.02);
      const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
      
      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.12, 1.55, 0.26);
      villagerGroup.add(leftEye);
      
      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.12, 1.55, 0.26);
      villagerGroup.add(rightEye);
      
      // Add nose (signature villager feature)
      const noseGeometry = new THREE.BoxGeometry(0.12, 0.2, 0.12);
      const noseMaterial = new THREE.MeshLambertMaterial({ color: 0xffc0a0 });
      const nose = new THREE.Mesh(noseGeometry, noseMaterial);
      nose.position.set(0, 1.5, 0.32);
      villagerGroup.add(nose);
      
      // Add arms
      const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
      const armMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
      
      const leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-0.35, 0.6, 0);
      villagerGroup.add(leftArm);
      
      const rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(0.35, 0.6, 0);
      villagerGroup.add(rightArm);
      
      villagerGroup.position.set(x, y, z);
      villagerGroup.castShadow = true;
      
      minecraft3D.scene.add(villagerGroup);
      minecraft3D.villagers.push({
        mesh: villagerGroup,
        health: 20,
        position: new THREE.Vector3(x, y, z),
        velocity: new THREE.Vector3(0, 0, 0),
        village: village,
        wander: Math.random() * Math.PI * 2,
        idleTime: 0
      });
    }

    function setBlock3D(x, y, z, blockType) {
      const key = `${x},${y},${z}`;
      const oldType = minecraft3D.world.get(key);
      
      if (oldType) {
        const oldMesh = minecraft3D.blockMeshes.get(key);
        if (oldMesh) {
          minecraft3D.scene.remove(oldMesh);
          // Don't dispose geometry or materials - they're shared/cached!
          minecraft3D.blockMeshes.delete(key);
        }
      }

      if (!blockType) {
        minecraft3D.world.delete(key);
        return;
      }

      minecraft3D.world.set(key, blockType);
      
      const info = minecraft3D.blockInfo[blockType];
      if (!info) return;

      // Reuse geometry for all blocks (huge performance gain)
      if (!minecraft3D.geometryCache) {
        minecraft3D.geometryCache = new THREE.BoxGeometry(1, 1, 1);
      }
      const geometry = minecraft3D.geometryCache;
      
      // Create or reuse materials for better performance
      let materials;
      const materialKey = blockType;
      
      if (minecraft3D.materialCache.has(materialKey)) {
        materials = minecraft3D.materialCache.get(materialKey);
      } else {
        if (info.topColor && info.sideColor) {
          // Multi-textured block (grass, wood, crafting table)
          const topMaterial = new THREE.MeshLambertMaterial({ 
            color: info.topColor,
            transparent: info.transparent || false,
            opacity: info.opacity || 1
          });
          const sideMaterial = new THREE.MeshLambertMaterial({ 
            color: info.sideColor,
            transparent: info.transparent || false,
            opacity: info.opacity || 1
          });
          const bottomMaterial = new THREE.MeshLambertMaterial({ 
            color: info.bottomColor || info.color,
            transparent: info.transparent || false,
            opacity: info.opacity || 1
          });
          
          // Order: right, left, top, bottom, front, back
          materials = [
            sideMaterial, // right
            sideMaterial, // left
            topMaterial,  // top
            bottomMaterial, // bottom
            sideMaterial, // front
            sideMaterial  // back
          ];
        } else {
          // Single color block
          materials = new THREE.MeshLambertMaterial({ 
            color: info.color,
            transparent: info.transparent || false,
            opacity: info.opacity || 1
          });
        }
        minecraft3D.materialCache.set(materialKey, materials);
      }
      
      const mesh = new THREE.Mesh(geometry, materials);
      mesh.position.set(x, y, z);
      mesh.castShadow = false; // Disabled for performance
      mesh.receiveShadow = false; // Disabled for performance
      mesh.userData = { x, y, z, blockType };
      
      // Check if block should be visible based on render distance
      const player = minecraft3D.player;
      const dx = x - player.position.x;
      const dz = z - player.position.z;
      const distSq = dx * dx + dz * dz;
      mesh.visible = distSq < minecraft3D.renderDistance * minecraft3D.renderDistance;
      
      minecraft3D.scene.add(mesh);
      minecraft3D.blockMeshes.set(key, mesh);
    }

    function updateBlockCrack(x, y, z, progress) {
      const key = `${x},${y},${z}`;
      const mesh = minecraft3D.blockMeshes.get(key);
      if (!mesh) return;

      const blockType = mesh.userData.blockType;
      const info = minecraft3D.blockInfo[blockType];

      // Create crack overlay based on mining progress
      if (progress > 0 && progress < 1) {
        const crackColor = new THREE.Color(0x000000);
        
        // Handle multi-textured blocks (material is an array) and single-texture blocks
        if (Array.isArray(mesh.material)) {
          mesh.material.forEach((mat, i) => {
            // Use appropriate original color for each face
            let originalColor;
            if (i === 2 && info.topColor) originalColor = new THREE.Color(info.topColor);
            else if (i === 3 && info.bottomColor) originalColor = new THREE.Color(info.bottomColor);
            else if (info.sideColor) originalColor = new THREE.Color(info.sideColor);
            else originalColor = new THREE.Color(info.color);
            
            mat.color.lerpColors(originalColor, crackColor, progress * 0.3);
            mat.emissive = new THREE.Color(0x000000);
            mat.emissiveIntensity = progress * 0.2;
          });
        } else {
          const originalColor = new THREE.Color(info.color);
          mesh.material.color.lerpColors(originalColor, crackColor, progress * 0.3);
          mesh.material.emissive = new THREE.Color(0x000000);
          mesh.material.emissiveIntensity = progress * 0.2;
        }
      } else {
        // Reset to original color
        if (Array.isArray(mesh.material)) {
          mesh.material.forEach((mat, i) => {
            let originalColor;
            if (i === 2 && info.topColor) originalColor = new THREE.Color(info.topColor);
            else if (i === 3 && info.bottomColor) originalColor = new THREE.Color(info.bottomColor);
            else if (info.sideColor) originalColor = new THREE.Color(info.sideColor);
            else originalColor = new THREE.Color(info.color);
            
            mat.color.copy(originalColor);
            mat.emissiveIntensity = 0;
          });
        } else {
          const originalColor = new THREE.Color(info.color);
          mesh.material.color.copy(originalColor);
          mesh.material.emissiveIntensity = 0;
        }
      }
    }

    function getBlock3D(x, y, z) {
      return minecraft3D.world.get(`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`);
    }

    function getTopBlockAt(x, z) {
      for (let y = minecraft3D.worldSize.y - 1; y >= 0; y--) {
        if (getBlock3D(x, y, z)) return y;
      }
      return 0;
    }

    function onMouseMove3D(e) {
      if (!minecraft3D.pointerLocked) return;

      const sensitivity = 0.002;
      minecraft3D.player.yaw -= e.movementX * sensitivity;
      minecraft3D.player.pitch -= e.movementY * sensitivity;
      minecraft3D.player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, minecraft3D.player.pitch));
    }

    function checkCollision3D(x, y, z) {
      const r = minecraft3D.player.width / 2;
      const h = minecraft3D.player.height;
      
      // Check all blocks the player might intersect
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = 0; dy < 3; dy++) { // Check from feet to head
          for (let dz = -1; dz <= 1; dz++) {
            const block = getBlock3D(Math.floor(x + dx * r), Math.floor(y + dy), Math.floor(z + dz * r));
            if (block && block !== 'water') return true;
          }
        }
      }
      return false;
    }

    function updatePhysics3D(delta) {
      const player = minecraft3D.player;
      const controls = minecraft3D.controls;
      
      // Stronger gravity for less floaty feel
      if (!player.onGround) {
        player.velocity.y -= 70 * delta; // Increased from 50 to 70
      }

      // Faster movement speeds
      const speed = controls.sprint ? 20 : 13; // Increased from 15:10 to 20:13
      const moveVector = new THREE.Vector3();
      
      if (controls.forward) moveVector.z -= 1;
      if (controls.backward) moveVector.z += 1;
      if (controls.left) moveVector.x -= 1;
      if (controls.right) moveVector.x += 1;
      
      if (moveVector.length() > 0) {
        moveVector.normalize();
        moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.yaw);
        moveVector.multiplyScalar(speed * delta);
        
        // Check X collision
        const newX = player.position.x + moveVector.x;
        if (!checkCollision3D(newX, player.position.y, player.position.z)) {
          player.position.x = newX;
        }
        
        // Check Z collision
        const newZ = player.position.z + moveVector.z;
        if (!checkCollision3D(player.position.x, player.position.y, newZ)) {
          player.position.z = newZ;
        }
      }

      // Jumping - higher jump to clear 1 block
      if (controls.jump && player.onGround) {
        player.velocity.y = 12; // Increased from 8 to 12
        player.onGround = false;
        controls.jump = false; // Reset jump to prevent continuous jumping
      }

      // Apply vertical velocity
      const newY = player.position.y + player.velocity.y * delta;
      
      // Check ground collision
      if (player.velocity.y <= 0) {
        const groundY = Math.floor(newY - 0.1);
        if (checkCollision3D(player.position.x, groundY, player.position.z)) {
          player.position.y = groundY + 1;
          player.velocity.y = 0;
          player.onGround = true;
        } else {
          player.position.y = newY;
          player.onGround = false;
        }
      } else {
        // Check ceiling collision
        const ceilingY = Math.floor(newY + player.height);
        if (checkCollision3D(player.position.x, ceilingY, player.position.z)) {
          player.velocity.y = 0;
        } else {
          player.position.y = newY;
          player.onGround = false;
        }
      }

      // Clamp to world bounds
      player.position.x = Math.max(0, Math.min(minecraft3D.worldSize.x - 1, player.position.x));
      player.position.z = Math.max(0, Math.min(minecraft3D.worldSize.z - 1, player.position.z));
      player.position.y = Math.max(0, player.position.y);
    }

    function getTargetBlock3D() {
      const raycaster = new THREE.Raycaster();
      const camera = minecraft3D.camera;
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      
      const intersects = raycaster.intersectObjects(Array.from(minecraft3D.blockMeshes.values()));
      
      if (intersects.length > 0 && intersects[0].distance < 5) {
        return {
          mesh: intersects[0].object,
          face: intersects[0].face,
          point: intersects[0].point
        };
      }
      return null;
    }

    function handleMining3D(delta) {
      if (!minecraft3D.mouseDown.left) {
        // Reset any crack overlay when not mining
        if (minecraft3D.miningBlock) {
          const [x, y, z] = minecraft3D.miningBlock.split(',').map(Number);
          updateBlockCrack(x, y, z, 0);
        }
        minecraft3D.miningBlock = null;
        minecraft3D.miningProgress = 0;
        updateMiningProgressUI();
        return;
      }

      const target = getTargetBlock3D();
      if (!target) {
        if (minecraft3D.miningBlock) {
          const [x, y, z] = minecraft3D.miningBlock.split(',').map(Number);
          updateBlockCrack(x, y, z, 0);
        }
        minecraft3D.miningBlock = null;
        minecraft3D.miningProgress = 0;
        updateMiningProgressUI();
        return;
      }

      const blockData = target.mesh.userData;
      const key = `${blockData.x},${blockData.y},${blockData.z}`;
      
      // If targeting new block, reset progress and clear old cracks
      if (minecraft3D.miningBlock !== key) {
        if (minecraft3D.miningBlock) {
          const [ox, oy, oz] = minecraft3D.miningBlock.split(',').map(Number);
          updateBlockCrack(ox, oy, oz, 0);
        }
        minecraft3D.miningBlock = key;
        minecraft3D.miningProgress = 0;
      }

      const blockType = blockData.blockType;
      const info = minecraft3D.blockInfo[blockType];
      
      if (info.mineTime === -1) return; // Can't mine (water)

      // Check tool requirement
      const selected = minecraft3D.hotbar[minecraft3D.selectedSlot];
      if (info.tool && selected !== info.tool) {
        minecraft3D.miningProgress = 0;
        updateMiningProgressUI();
        updateBlockCrack(blockData.x, blockData.y, blockData.z, 0);
        return;
      }

      // Increase mining progress
      minecraft3D.miningProgress += delta / info.mineTime;
      updateMiningProgressUI();
      updateBlockCrack(blockData.x, blockData.y, blockData.z, minecraft3D.miningProgress);

      // Block mined!
      if (minecraft3D.miningProgress >= 1) {
        setBlock3D(blockData.x, blockData.y, blockData.z, null);
        addToInventory(blockType);
        minecraft3D.miningBlock = null;
        minecraft3D.miningProgress = 0;
        updateMiningProgressUI();
      }
    }

    function handlePlacing3D() {
      if (!minecraft3D.mouseDown.right) return;
      minecraft3D.mouseDown.right = false; // Single click

      const target = getTargetBlock3D();
      if (!target) return;

      const selected = minecraft3D.hotbar[minecraft3D.selectedSlot];
      if (!selected) return;

      const invItem = minecraft3D.inventory.find(i => i.type === selected);
      if (!invItem || invItem.count <= 0) return;

      // Calculate placement position
      const normal = target.face.normal;
      const blockData = target.mesh.userData;
      const placeX = blockData.x + Math.round(normal.x);
      const placeY = blockData.y + Math.round(normal.y);
      const placeZ = blockData.z + Math.round(normal.z);

      // Check if position is empty and not in player
      if (getBlock3D(placeX, placeY, placeZ)) return;
      
      const playerBox = new THREE.Box3(
        new THREE.Vector3(
          minecraft3D.player.position.x - 0.3,
          minecraft3D.player.position.y - 0.1,
          minecraft3D.player.position.z - 0.3
        ),
        new THREE.Vector3(
          minecraft3D.player.position.x + 0.3,
          minecraft3D.player.position.y + minecraft3D.player.height,
          minecraft3D.player.position.z + 0.3
        )
      );
      
      const blockBox = new THREE.Box3(
        new THREE.Vector3(placeX - 0.5, placeY - 0.5, placeZ - 0.5),
        new THREE.Vector3(placeX + 0.5, placeY + 0.5, placeZ + 0.5)
      );
      
      if (playerBox.intersectsBox(blockBox)) return;

      // Place block
      setBlock3D(placeX, placeY, placeZ, selected);
      removeFromInventory(selected);
    }

    function updateMiningProgressUI() {
      const progressEl = document.getElementById('mcMiningProgress');
      if (progressEl) {
        progressEl.textContent = Math.floor(minecraft3D.miningProgress * 100) + '%';
      }
    }

    function animate3D() {
      requestAnimationFrame(animate3D);

      if (minecraft3D.paused) {
        // Show pause overlay
        const ctx = minecraft3D.renderer.domElement.getContext('2d');
        if (ctx) {
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(0, 0, minecraft3D.renderer.domElement.width, minecraft3D.renderer.domElement.height);
          ctx.fillStyle = 'white';
          ctx.font = 'bold 48px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('PAUSED', minecraft3D.renderer.domElement.width / 2, minecraft3D.renderer.domElement.height / 2);
          ctx.font = '24px Arial';
          ctx.fillText('Press ESC to resume', minecraft3D.renderer.domElement.width / 2, minecraft3D.renderer.domElement.height / 2 + 50);
        }
        return;
      }

      const delta = 0.016; // ~60 FPS

      // Update physics
      updatePhysics3D(delta);

      // Update camera
      minecraft3D.camera.position.copy(minecraft3D.player.position);
      minecraft3D.camera.position.y += minecraft3D.player.height - 0.2;
      minecraft3D.camera.rotation.set(minecraft3D.player.pitch, minecraft3D.player.yaw, 0, 'YXZ');

      // Handle mining/placing
      handleMining3D(delta);
      handlePlacing3D();
      
      // Update animals
      updateAnimals3D(delta);
      
      // Update villagers
      updateVillagers3D(delta);

      // Update day/night cycle
      updateDayNightCycle(delta);

      // Performance optimization: Only render blocks near player
      updateBlockVisibility();

      // Render
      minecraft3D.renderer.render(minecraft3D.scene, minecraft3D.camera);
    }

    function updateBlockVisibility() {
      const player = minecraft3D.player;
      const px = Math.floor(player.position.x);
      const pz = Math.floor(player.position.z);
      const renderDist = minecraft3D.renderDistance;
      
      // Only update visibility if player moved to a new chunk (every 8 blocks)
      const chunkX = Math.floor(px / 8);
      const chunkZ = Math.floor(pz / 8);
      
      if (chunkX === minecraft3D.lastPlayerChunk.x && chunkZ === minecraft3D.lastPlayerChunk.z) {
        return; // Player still in same chunk, no need to update
      }
      
      minecraft3D.lastPlayerChunk = { x: chunkX, z: chunkZ };
      
      // Update visibility of all block meshes
      minecraft3D.blockMeshes.forEach((mesh, key) => {
        const data = mesh.userData;
        const dx = data.x - px;
        const dz = data.z - pz;
        const distSq = dx * dx + dz * dz;
        
        // Only show blocks within render distance
        mesh.visible = distSq < renderDist * renderDist;
      });
    }

    function updateDayNightCycle(delta) {
      // Progress time of day (0 to 1, then loops)
      minecraft3D.timeOfDay += delta / minecraft3D.dayNightCycleDuration;
      if (minecraft3D.timeOfDay > 1) minecraft3D.timeOfDay -= 1;
      
      // Calculate light intensity based on time (sine wave for smooth transition)
      // 0 = dawn, 0.25 = noon, 0.5 = dusk, 0.75 = midnight
      const angle = minecraft3D.timeOfDay * Math.PI * 2;
      const sunHeight = Math.sin(angle); // -1 (night) to 1 (day)
      
      // Map sun height to light intensity
      // Day: 0.65 ambient, 0.6 directional
      // Night: 0.15 ambient, 0.1 directional (still visible but darker)
      const dayAmbient = 0.65;
      const nightAmbient = 0.15;
      const dayDirectional = 0.6;
      const nightDirectional = 0.1;
      
      const t = (sunHeight + 1) / 2; // 0 (night) to 1 (day)
      minecraft3D.ambientLight.intensity = nightAmbient + (dayAmbient - nightAmbient) * t;
      minecraft3D.directionalLight.intensity = nightDirectional + (dayDirectional - nightDirectional) * t;
      
      // Update sky and fog color
      const daySkyColor = new THREE.Color(0x87CEEB); // Light blue
      const nightSkyColor = new THREE.Color(0x0a0a2e); // Dark blue/purple
      const skyColor = new THREE.Color().lerpColors(nightSkyColor, daySkyColor, t);
      
      minecraft3D.scene.background = skyColor;
      minecraft3D.scene.fog.color = skyColor;
      
      // Move sun position across sky
      const sunAngle = minecraft3D.timeOfDay * Math.PI * 2 - Math.PI / 2;
      minecraft3D.directionalLight.position.set(
        Math.cos(sunAngle) * 50,
        Math.sin(sunAngle) * 100,
        50
      );
      
      // Tint directional light to be warmer at sunrise/sunset
      if (t < 0.3 || t > 0.7) {
        // Sunrise/sunset - orange tint
        minecraft3D.directionalLight.color = new THREE.Color(0xffaa66);
      } else {
        // Day/night - white light
        minecraft3D.directionalLight.color = new THREE.Color(0xffffff);
      }
    }

    function updateAnimals3D(delta) {
      minecraft3D.animals.forEach((animal, index) => {
        // Simple wandering AI
        animal.wander += (Math.random() - 0.5) * 0.1;
        const speed = 0.02;
        animal.position.x += Math.cos(animal.wander) * speed;
        animal.position.z += Math.sin(animal.wander) * speed;
        
        // Keep on ground
        const groundY = getTopBlockAt(Math.floor(animal.position.x), Math.floor(animal.position.z));
        animal.position.y = groundY + 1;
        
        // Update mesh
        animal.mesh.position.copy(animal.position);
        
        // Check if player attacked (left click on animal)
        if (minecraft3D.mouseDown.left) {
          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(new THREE.Vector2(0, 0), minecraft3D.camera);
          const intersects = raycaster.intersectObject(animal.mesh, true); // Check all children
          
          if (intersects.length > 0 && intersects[0].distance < 5) {
            animal.health -= 5;
            if (animal.health <= 0) {
              // Animal killed - drop loot
              minecraft3D.scene.remove(animal.mesh);
              const loot = { cow: 'leather', pig: 'meat', chicken: 'feather' };
              addToInventory(loot[animal.type] || 'meat', 1 + Math.floor(Math.random() * 2));
              minecraft3D.animals.splice(index, 1);
              
              // Respawn a new animal to maintain population of 30
              const animalTypes = ['cow', 'pig', 'chicken'];
              const newType = animalTypes[Math.floor(Math.random() * animalTypes.length)];
              const spawnX = 20 + Math.floor(Math.random() * 60);
              const spawnZ = 20 + Math.floor(Math.random() * 60);
              const spawnY = getTopBlockAt(spawnX, spawnZ);
              spawnAnimal(spawnX, spawnY + 1, spawnZ, newType);
            }
          }
        }
      });
    }

    function updateVillagers3D(delta) {
      minecraft3D.villagers.forEach((villager, index) => {
        const village = villager.village;
        if (!village) return;
        
        // Villager AI: wander within village boundaries
        villager.idleTime += delta;
        
        if (villager.idleTime > 3) {
          // Change direction every 3 seconds
          villager.wander = Math.random() * Math.PI * 2;
          villager.idleTime = 0;
        }
        
        const speed = 0.015; // Slower than animals
        const newX = villager.position.x + Math.cos(villager.wander) * speed;
        const newZ = villager.position.z + Math.sin(villager.wander) * speed;
        
        // Check if new position is within village boundaries (10 blocks from center)
        const distFromVillage = Math.sqrt(
          Math.pow(newX - village.x, 2) + Math.pow(newZ - village.z, 2)
        );
        
        if (distFromVillage < village.radius) {
          villager.position.x = newX;
          villager.position.z = newZ;
        } else {
          // Turn around if reaching village edge
          villager.wander += Math.PI;
        }
        
        // Keep on ground
        const groundY = getTopBlockAt(Math.floor(villager.position.x), Math.floor(villager.position.z));
        villager.position.y = groundY + 1;
        
        // Face direction of movement
        villager.mesh.rotation.y = villager.wander + Math.PI;
        
        // Update mesh position
        villager.mesh.position.copy(villager.position);
      });
    }

    function addToInventory(item, count = 1) {
      const existing = minecraft3D.inventory.find(i => i.type === item);
      if (existing) {
        existing.count += count;
      } else {
        minecraft3D.inventory.push({ type: item, count: count });
      }
      
      // Remove item from hotbar if count reaches 0
      minecraft3D.hotbar.forEach((hotbarItem, idx) => {
        if (hotbarItem === item) {
          const invItem = minecraft3D.inventory.find(i => i.type === item);
          if (!invItem || invItem.count <= 0) {
            minecraft3D.hotbar[idx] = null;
          }
        }
      });
      
      updateInventoryUI();
    }

    function removeFromInventory(item, count = 1) {
      const existing = minecraft3D.inventory.find(i => i.type === item);
      if (existing) {
        existing.count -= count;
        if (existing.count <= 0) {
          minecraft3D.inventory = minecraft3D.inventory.filter(i => i.type !== item);
          
          // Remove item from hotbar if it's there
          minecraft3D.hotbar.forEach((hotbarItem, idx) => {
            if (hotbarItem === item) {
              minecraft3D.hotbar[idx] = null;
            }
          });
        }
      }
      updateInventoryUI();
    }

    function updateInventoryUI() {
      // Update inventory grid
      const invGrid = document.getElementById('mcInventory');
      if (invGrid) {
        invGrid.innerHTML = '';
        minecraft3D.inventory.forEach((item, index) => {
          const slot = document.createElement('div');
          slot.style.cssText = 'padding: 8px; background: rgba(0,0,0,0.3); border: 2px solid rgba(0,217,255,0.5); border-radius: 5px; text-align: center; font-size: 1.2rem; cursor: pointer;';
          const info = minecraft3D.blockInfo[item.type] || minecraft3D.recipes[item.type] || { emoji: '‚ùì' };
          slot.innerHTML = `${info.emoji}<br><span style="font-size: 0.7rem; color: white;">${item.count}</span>`;
          slot.onclick = () => moveToHotbar(item.type, index);
          invGrid.appendChild(slot);
        });
      }
      
      // Update hotbar
      const hotbar = document.getElementById('mcHotbar');
      if (hotbar) {
        hotbar.innerHTML = '';
        for (let i = 0; i < 5; i++) {
          const slot = document.createElement('div');
          slot.style.cssText = `padding: 10px; background: ${i === minecraft3D.selectedSlot ? 'rgba(0,217,255,0.3)' : 'rgba(0,0,0,0.3)'}; border: 3px solid ${i === minecraft3D.selectedSlot ? 'var(--primary-color)' : 'rgba(0,217,255,0.5)'}; border-radius: 8px; text-align: center; font-size: 1.5rem; cursor: pointer;`;
          if (minecraft3D.hotbar[i]) {
            const info = minecraft3D.blockInfo[minecraft3D.hotbar[i]] || minecraft3D.recipes[minecraft3D.hotbar[i]] || { emoji: '‚ùì' };
            slot.textContent = info.emoji;
          } else {
            slot.textContent = '‚Äî';
          }
          slot.onclick = () => selectHotbarSlot(i);
          hotbar.appendChild(slot);
        }
      }
      
      // Update selected item display
      const selected = minecraft3D.hotbar[minecraft3D.selectedSlot];
      const selDisplay = document.getElementById('mcSelected');
      if (selDisplay) {
        selDisplay.textContent = selected || 'Fist';
      }
      
      // Update count
      const countDisplay = document.getElementById('mcInvCount');
      if (countDisplay) {
        countDisplay.textContent = minecraft3D.inventory.reduce((sum, item) => sum + item.count, 0);
      }
    }

    function moveToHotbar(itemType, invIndex) {
      // Check if item already in hotbar
      if (minecraft3D.hotbar.includes(itemType)) return;
      
      const emptySlot = minecraft3D.hotbar.findIndex(slot => slot === null);
      if (emptySlot !== -1) {
        minecraft3D.hotbar[emptySlot] = itemType;
        updateInventoryUI();
      }
    }

    function selectHotbarSlot(index) {
      minecraft3D.selectedSlot = index;
      updateInventoryUI();
    }

    function openMcCrafting() {
      const menu = document.getElementById('mcCraftingMenu');
      const recipes = document.getElementById('mcRecipes');
      if (!menu || !recipes) return;
      
      // Release pointer lock so user can click crafting buttons
      document.exitPointerLock();
      minecraft3D.paused = true;
      
      menu.style.display = 'block';
      recipes.innerHTML = '';
      
      Object.keys(minecraft3D.recipes).forEach(key => {
        const recipe = minecraft3D.recipes[key];
        
        // Check if can craft - handle "any wood type" logic
        const canCraft = Object.keys(recipe.requires).every(req => {
          if (req === 'wood') {
            // Accept any wood type (wood, oak_wood, birch_wood, spruce_wood, jungle_wood)
            const totalWood = minecraft3D.inventory
              .filter(i => i.type.includes('wood') && !i.type.includes('pickaxe'))
              .reduce((sum, i) => sum + i.count, 0);
            return totalWood >= recipe.requires[req];
          } else {
            const invItem = minecraft3D.inventory.find(i => i.type === req);
            return invItem && invItem.count >= recipe.requires[req];
          }
        });
        
        const card = document.createElement('div');
        card.style.cssText = `padding: 12px; background: ${canCraft ? 'rgba(16,185,129,0.1)' : 'rgba(255,255,255,0.05)'}; border: 2px solid ${canCraft ? '#10b981' : 'rgba(255,255,255,0.1)'}; border-radius: 8px; cursor: ${canCraft ? 'pointer' : 'not-allowed'};`;
        card.innerHTML = `
          <div style="font-size: 1.5rem; text-align: center; margin-bottom: 8px;">${recipe.emoji}</div>
          <div style="color: white; font-weight: bold; text-align: center; margin-bottom: 8px;">${recipe.name}</div>
          <div style="color: var(--text-secondary); font-size: 0.85rem;">
            ${Object.keys(recipe.requires).map(req => {
              if (req === 'wood') {
                return `any wood: ${recipe.requires[req]}`;
              }
              return `${req}: ${recipe.requires[req]}`;
            }).join('<br>')}
          </div>
        `;
        
        if (canCraft) {
          card.onclick = () => craftItem(recipe);
        }
        
        recipes.appendChild(card);
      });
    }

    function closeMcCrafting() {
      const menu = document.getElementById('mcCraftingMenu');
      if (menu) menu.style.display = 'none';
      minecraft3D.paused = false;
    }

    function craftItem(recipe) {
      // Remove required items
      Object.keys(recipe.requires).forEach(req => {
        if (req === 'wood') {
          // Remove any wood types until we have enough
          let needed = recipe.requires[req];
          const woodTypes = minecraft3D.inventory.filter(i => i.type.includes('wood') && !i.type.includes('pickaxe'));
          
          for (const woodItem of woodTypes) {
            if (needed <= 0) break;
            const toRemove = Math.min(woodItem.count, needed);
            removeFromInventory(woodItem.type, toRemove);
            needed -= toRemove;
          }
        } else {
          removeFromInventory(req, recipe.requires[req]);
        }
      });
      
      // Add crafted item
      addToInventory(recipe.result, recipe.count || 1);
      openMcCrafting(); // Refresh menu
    }

    function resetMcWorld() {
      minecraft3D.inventory = [];
      minecraft3D.hotbar = [null, null, null, null, null];
      minecraft3D.miningProgress = 0;
      minecraft3D.miningBlock = null;
      generateWorld3D();
      updateInventoryUI();
    }

    // Initialize on load
    if (document.getElementById('minecraftContainer')) {
      setTimeout(initMinecraft3D, 500); // Small delay to ensure DOM is ready
    }
  </script>

  <!-- Space Shooter Game -->
  <script>
    const spaceCanvas = document.getElementById('spaceCanvas');
    const spaceCtx = spaceCanvas ? spaceCanvas.getContext('2d') : null;
    let spaceGame = {
      player: { x: 275, y: 350, width: 40, height: 30, speed: 5, health: 100 },
      bullets: [],
      enemies: [],
      score: 0,
      highScore: parseInt(localStorage.getItem('spaceHigh')) || 0,
      gameLoop: null,
      spawnTimer: null,
      keys: {},
      gameOver: false
    };
    
    function initSpaceGame() {
      if (!spaceCanvas) {
        console.error('Space canvas not found!');
        return;
      }
      console.log('Initializing space game...');
      stopAllGames();
      
      // Reset canvas size to match its display size
      const rect = spaceCanvas.getBoundingClientRect();
      spaceCanvas.width = 800;
      spaceCanvas.height = 500;
      
      // Clear any existing spawn timer
      if (spaceGame.spawnTimer) {
        clearTimeout(spaceGame.spawnTimer);
        spaceGame.spawnTimer = null;
      }
      
      spaceGame.gameOver = false;
      spaceGame.player = { x: 375, y: 450, width: 40, height: 30, speed: 6, health: 100 };
      spaceGame.bullets = [];
      spaceGame.enemies = [];
      spaceGame.score = 0;
      spaceGame.keys = {};
      
      console.log('Game state reset, starting loops...');
      updateSpaceStats();
      
      if (spaceGame.gameLoop) cancelAnimationFrame(spaceGame.gameLoop);
      spaceGameLoop();
      spawnEnemies();
    }
    
    function updateSpaceStats() {
      if (document.getElementById('spaceScore')) {
        document.getElementById('spaceScore').textContent = spaceGame.score;
      }
      if (document.getElementById('spaceHealth')) {
        document.getElementById('spaceHealth').textContent = spaceGame.player.health;
      }
      if (document.getElementById('spaceHighScore')) {
        document.getElementById('spaceHighScore').textContent = spaceGame.highScore;
      }
    }
    
    function spaceGameLoop() {
      if (!spaceCtx || spaceGame.gameOver) return;
      
      // Clear with space background
      const gradient = spaceCtx.createLinearGradient(0, 0, 0, spaceCanvas.height);
      gradient.addColorStop(0, '#000428');
      gradient.addColorStop(1, '#004e92');
      spaceCtx.fillStyle = gradient;
      spaceCtx.fillRect(0, 0, spaceCanvas.width, spaceCanvas.height);
      
      // Stars
      spaceCtx.fillStyle = 'white';
      for (let i = 0; i < 50; i++) {
        const x = (i * 37) % spaceCanvas.width;
        const y = (i * 73) % spaceCanvas.height;
        spaceCtx.fillRect(x, y, 2, 2);
      }
      
      // Move player
      if (spaceGame.keys['ArrowLeft'] && spaceGame.player.x > 0) {
        spaceGame.player.x -= spaceGame.player.speed;
      }
      if (spaceGame.keys['ArrowRight'] && spaceGame.player.x < spaceCanvas.width - spaceGame.player.width) {
        spaceGame.player.x += spaceGame.player.speed;
      }
      if (spaceGame.keys['ArrowUp'] && spaceGame.player.y > 0) {
        spaceGame.player.y -= spaceGame.player.speed;
      }
      if (spaceGame.keys['ArrowDown'] && spaceGame.player.y < spaceCanvas.height - spaceGame.player.height) {
        spaceGame.player.y += spaceGame.player.speed;
      }
      
      // Draw player (spaceship)
      spaceCtx.fillStyle = '#00d9ff';
      spaceCtx.beginPath();
      spaceCtx.moveTo(spaceGame.player.x + spaceGame.player.width / 2, spaceGame.player.y);
      spaceCtx.lineTo(spaceGame.player.x, spaceGame.player.y + spaceGame.player.height);
      spaceCtx.lineTo(spaceGame.player.x + spaceGame.player.width, spaceGame.player.y + spaceGame.player.height);
      spaceCtx.closePath();
      spaceCtx.fill();
      
      // Update and draw bullets
      spaceGame.bullets = spaceGame.bullets.filter(bullet => {
        bullet.y -= 8;
        spaceCtx.fillStyle = '#ffff00';
        spaceCtx.fillRect(bullet.x, bullet.y, 4, 10);
        return bullet.y > 0;
      });
      
      // Update and draw enemies
      if (spaceGame.enemies.length > 0) {
        console.log('Drawing', spaceGame.enemies.length, 'enemies');
      }
      spaceGame.enemies = spaceGame.enemies.filter(enemy => {
        enemy.y += enemy.speed;
        
        // Draw enemy
        spaceCtx.fillStyle = '#ff0000';
        spaceCtx.beginPath();
        spaceCtx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
        spaceCtx.fill();
        
        // Check bullet collisions
        for (let i = spaceGame.bullets.length - 1; i >= 0; i--) {
          const bullet = spaceGame.bullets[i];
          const dx = bullet.x - enemy.x;
          const dy = bullet.y - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < enemy.size + 5) {
            spaceGame.bullets.splice(i, 1);
            spaceGame.score += 10;
            updateSpaceStats();
            return false; // Remove enemy
          }
        }
        
        // Check player collision
        if (enemy.y > spaceGame.player.y && 
            enemy.y < spaceGame.player.y + spaceGame.player.height &&
            enemy.x > spaceGame.player.x &&
            enemy.x < spaceGame.player.x + spaceGame.player.width) {
          spaceGame.player.health -= 10;
          updateSpaceStats();
          if (spaceGame.player.health <= 0) {
            endSpaceGame();
          }
          return false;
        }
        
        return enemy.y < spaceCanvas.height + 20;
      });
      
      spaceGame.gameLoop = requestAnimationFrame(spaceGameLoop);
    }
    
    function spawnEnemies() {
      if (spaceGame.gameOver) {
        console.log('SpawnEnemies stopped - game over');
        return;
      }
      
      console.log('Spawning enemy, total enemies:', spaceGame.enemies.length);
      spaceGame.enemies.push({
        x: Math.random() * (spaceCanvas.width - 40) + 20,
        y: -20,
        size: 15,
        speed: 2 + Math.random() * 2
      });
      
      spaceGame.spawnTimer = setTimeout(spawnEnemies, 1000 + Math.random() * 1000);
    }
    
    function endSpaceGame() {
      spaceGame.gameOver = true;
      
      // Clear spawn timer
      if (spaceGame.spawnTimer) {
        clearTimeout(spaceGame.spawnTimer);
        spaceGame.spawnTimer = null;
      }
      
      if (spaceGame.score > spaceGame.highScore) {
        spaceGame.highScore = spaceGame.score;
        localStorage.setItem('spaceHigh', spaceGame.highScore);
        updateSpaceStats();
      }
      
      spaceCtx.fillStyle = 'rgba(0,0,0,0.7)';
      spaceCtx.fillRect(0, 0, spaceCanvas.width, spaceCanvas.height);
      spaceCtx.fillStyle = '#00d9ff';
      spaceCtx.font = 'bold 30px Arial';
      spaceCtx.textAlign = 'center';
      spaceCtx.fillText('GAME OVER', spaceCanvas.width / 2, spaceCanvas.height / 2 - 20);
      spaceCtx.font = '20px Arial';
      spaceCtx.fillText('Score: ' + spaceGame.score, spaceCanvas.width / 2, spaceCanvas.height / 2 + 20);
      spaceCtx.fillText('Click to Restart', spaceCanvas.width / 2, spaceCanvas.height / 2 + 50);
    }
    
    // Controls
    if (spaceCanvas) {
      document.addEventListener('keydown', (e) => {
        spaceGame.keys[e.key] = true;
        if (e.key === ' ' && !spaceGame.gameOver) {
          e.preventDefault();
          spaceGame.bullets.push({
            x: spaceGame.player.x + spaceGame.player.width / 2 - 2,
            y: spaceGame.player.y
          });
        }
      });
      
      document.addEventListener('keyup', (e) => {
        spaceGame.keys[e.key] = false;
      });
      
      spaceCanvas.addEventListener('click', () => {
        if (spaceGame.gameOver) {
          initSpaceGame();
        }
      });
      
      initSpaceGame();
    }
  </script>

  <!-- Flappy Square Game -->
  <script>
    const flappyCanvas = document.getElementById('flappyCanvas');
    const flappyCtx = flappyCanvas ? flappyCanvas.getContext('2d') : null;
    let flappyGame = {
      bird: { x: 100, y: 200, size: 30, velocity: 0, gravity: 0.5, jump: -8 },
      pipes: [],
      score: 0,
      bestScore: parseInt(localStorage.getItem('flappyBest')) || 0,
      gameLoop: null,
      gameOver: false,
      frameCount: 0
    };
    
    function initFlappyGame() {
      if (!flappyCanvas) return;
      flappyGame.bird = { x: 100, y: 200, size: 30, velocity: 0, gravity: 0.5, jump: -8 };
      flappyGame.pipes = [];
      flappyGame.score = 0;
      flappyGame.gameOver = false;
      flappyGame.frameCount = 0;
      
      updateFlappyScore();
      
      if (flappyGame.gameLoop) cancelAnimationFrame(flappyGame.gameLoop);
      flappyGameLoop();
    }
    
    function updateFlappyScore() {
      if (document.getElementById('flappyScore')) {
        document.getElementById('flappyScore').textContent = flappyGame.score;
      }
      if (document.getElementById('flappyBest')) {
        document.getElementById('flappyBest').textContent = flappyGame.bestScore;
      }
    }
    
    function flappyGameLoop() {
      if (!flappyCtx || flappyGame.gameOver) return;
      
      flappyGame.frameCount++;
      
      // Clear with sky gradient
      const gradient = flappyCtx.createLinearGradient(0, 0, 0, flappyCanvas.height);
      gradient.addColorStop(0, '#87ceeb');
      gradient.addColorStop(1, '#e0f6ff');
      flappyCtx.fillStyle = gradient;
      flappyCtx.fillRect(0, 0, flappyCanvas.width, flappyCanvas.height);
      
      // Update bird physics
      flappyGame.bird.velocity += flappyGame.bird.gravity;
      flappyGame.bird.y += flappyGame.bird.velocity;
      
      // Draw bird (square)
      flappyCtx.fillStyle = '#ffd700';
      flappyCtx.fillRect(flappyGame.bird.x, flappyGame.bird.y, flappyGame.bird.size, flappyGame.bird.size);
      flappyCtx.strokeStyle = '#ff8c00';
      flappyCtx.lineWidth = 3;
      flappyCtx.strokeRect(flappyGame.bird.x, flappyGame.bird.y, flappyGame.bird.size, flappyGame.bird.size);
      
      // Spawn pipes
      if (flappyGame.frameCount % 90 === 0) {
        const gapY = Math.random() * (flappyCanvas.height - 250) + 100;
        const gapSize = 150;
        flappyGame.pipes.push({
          x: flappyCanvas.width,
          topHeight: gapY,
          bottomY: gapY + gapSize,
          width: 60,
          scored: false
        });
      }
      
      // Update and draw pipes
      flappyGame.pipes = flappyGame.pipes.filter(pipe => {
        pipe.x -= 3;
        
        // Draw top pipe
        flappyCtx.fillStyle = '#32cd32';
        flappyCtx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
        flappyCtx.strokeStyle = '#228b22';
        flappyCtx.lineWidth = 3;
        flappyCtx.strokeRect(pipe.x, 0, pipe.width, pipe.topHeight);
        
        // Draw bottom pipe
        flappyCtx.fillRect(pipe.x, pipe.bottomY, pipe.width, flappyCanvas.height - pipe.bottomY);
        flappyCtx.strokeRect(pipe.x, pipe.bottomY, pipe.width, flappyCanvas.height - pipe.bottomY);
        
        // Check collision
        if (flappyGame.bird.x + flappyGame.bird.size > pipe.x &&
            flappyGame.bird.x < pipe.x + pipe.width) {
          if (flappyGame.bird.y < pipe.topHeight || 
              flappyGame.bird.y + flappyGame.bird.size > pipe.bottomY) {
            endFlappyGame();
          }
        }
        
        // Score point when bird passes through the gap
        if (!pipe.scored && flappyGame.bird.x > pipe.x + pipe.width) {
          pipe.scored = true;
          flappyGame.score++;
          updateFlappyScore();
        }
        
        return pipe.x > -pipe.width;
      });
      
      // Check boundaries
      if (flappyGame.bird.y < 0 || flappyGame.bird.y + flappyGame.bird.size > flappyCanvas.height) {
        endFlappyGame();
      }
      
      flappyGame.gameLoop = requestAnimationFrame(flappyGameLoop);
    }
    
    function flappyJump() {
      if (!flappyGame.gameOver) {
        flappyGame.bird.velocity = flappyGame.bird.jump;
      }
    }
    
    function endFlappyGame() {
      flappyGame.gameOver = true;
      if (flappyGame.score > flappyGame.bestScore) {
        flappyGame.bestScore = flappyGame.score;
        localStorage.setItem('flappyBest', flappyGame.bestScore);
        updateFlappyScore();
      }
      
      flappyCtx.fillStyle = 'rgba(0,0,0,0.7)';
      flappyCtx.fillRect(0, 0, flappyCanvas.width, flappyCanvas.height);
      flappyCtx.fillStyle = '#ffd700';
      flappyCtx.font = 'bold 30px Arial';
      flappyCtx.textAlign = 'center';
      flappyCtx.fillText('GAME OVER', flappyCanvas.width / 2, flappyCanvas.height / 2 - 40);
      flappyCtx.font = '20px Arial';
      flappyCtx.fillText('Score: ' + flappyGame.score, flappyCanvas.width / 2, flappyCanvas.height / 2);
      flappyCtx.fillText('Best: ' + flappyGame.bestScore, flappyCanvas.width / 2, flappyCanvas.height / 2 + 30);
      flappyCtx.fillText('Click to Restart', flappyCanvas.width / 2, flappyCanvas.height / 2 + 70);
    }
    
    if (flappyCanvas) {
      flappyCanvas.addEventListener('click', () => {
        if (flappyGame.gameOver) {
          initFlappyGame();
        } else {
          flappyJump();
        }
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === ' ' && flappyCanvas.offsetParent !== null) {
          e.preventDefault();
          if (flappyGame.gameOver) {
            initFlappyGame();
          } else {
            flappyJump();
          }
        }
      });
      
      initFlappyGame();
    }
  </script>

    }
  </script>

  <!-- Tic-Tac-Toe AI -->
  <script>
    let tictactoe = {
      board: ['', '', '', '', '', '', '', '', ''],
      currentPlayer: 'X',
      gameOver: false,
      scores: {
        wins: parseInt(localStorage.getItem('tttWins')) || 0,
        losses: parseInt(localStorage.getItem('tttLosses')) || 0,
        draws: parseInt(localStorage.getItem('tttDraws')) || 0
      }
    };
    
    function initTicTacToe() {
      const grid = document.getElementById('ticTacBoard');
      if (!grid) return;
      
      grid.innerHTML = '';
      tictactoe.board = ['', '', '', '', '', '', '', '', ''];
      tictactoe.currentPlayer = 'X';
      tictactoe.gameOver = false;
      
      for (let i = 0; i < 9; i++) {
        const cell = document.createElement('div');
        cell.className = 'ttt-cell';
        cell.style.cssText = 'aspect-ratio: 1; background: rgba(0,217,255,0.1); border: 2px solid var(--primary-color); border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 3rem; cursor: pointer; transition: all 0.3s ease;';
        cell.dataset.index = i;
        cell.addEventListener('click', () => handleCellClick(i));
        cell.addEventListener('mouseenter', () => {
          if (!tictactoe.gameOver && tictactoe.board[i] === '') {
            cell.style.background = 'rgba(0,217,255,0.2)';
            cell.style.transform = 'scale(1.05)';
          }
        });
        cell.addEventListener('mouseleave', () => {
          cell.style.background = 'rgba(0,217,255,0.1)';
          cell.style.transform = 'scale(1)';
        });
        grid.appendChild(cell);
      }
      
      updateTTTScores();
    }
    
    function updateBoard() {
      const cells = document.querySelectorAll('#ticTacBoard .ttt-cell');
      cells.forEach((cell, index) => {
        cell.textContent = tictactoe.board[index];
        if (tictactoe.board[index] === 'X') {
          cell.style.color = 'var(--primary-color)';
        } else if (tictactoe.board[index] === 'O') {
          cell.style.color = 'var(--accent-color)';
        }
      });
    }
    
    function updateTTTScores() {
      if (document.getElementById('ticTacWins')) {
        document.getElementById('ticTacWins').textContent = tictactoe.scores.wins;
      }
      if (document.getElementById('ticTacLosses')) {
        document.getElementById('ticTacLosses').textContent = tictactoe.scores.losses;
      }
      if (document.getElementById('ticTacDraws')) {
        document.getElementById('ticTacDraws').textContent = tictactoe.scores.draws;
      }
    }
    
    function handleCellClick(index) {
      if (tictactoe.gameOver || tictactoe.board[index] !== '') return;
      
      // Player move
      tictactoe.board[index] = 'X';
      updateBoard();
      
      if (checkWinner('X')) {
        endTTTGame('You Win! üéâ');
        tictactoe.scores.wins++;
        localStorage.setItem('tttWins', tictactoe.scores.wins);
        updateTTTScores();
        return;
      }
      
      if (tictactoe.board.every(cell => cell !== '')) {
        endTTTGame('Draw! ü§ù');
        tictactoe.scores.draws++;
        localStorage.setItem('tttDraws', tictactoe.scores.draws);
        updateTTTScores();
        return;
      }
      
      // AI move
      setTimeout(() => {
        const aiMove = getBestMove();
        tictactoe.board[aiMove] = 'O';
        updateBoard();
        
        if (checkWinner('O')) {
          endTTTGame('AI Wins! ü§ñ');
          tictactoe.scores.losses++;
          localStorage.setItem('tttLosses', tictactoe.scores.losses);
          updateTTTScores();
          return;
        }
        
        if (tictactoe.board.every(cell => cell !== '')) {
          endTTTGame('Draw! ü§ù');
          tictactoe.scores.draws++;
          localStorage.setItem('tttDraws', tictactoe.scores.draws);
          updateTTTScores();
        }
      }, 300);
    }
    
    function updateBoard() {
      const cells = document.querySelectorAll('.ttt-cell');
      cells.forEach((cell, index) => {
        cell.textContent = tictactoe.board[index];
        cell.className = 'ttt-cell';
        if (tictactoe.board[index] === 'X') cell.classList.add('x');
        if (tictactoe.board[index] === 'O') cell.classList.add('o');
      });
    }
    
    function checkWinner(player) {
      const winPatterns = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
        [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
        [0, 4, 8], [2, 4, 6] // Diagonals
      ];
      
      return winPatterns.some(pattern => 
        pattern.every(index => tictactoe.board[index] === player)
      );
    }
    
    function getBestMove() {
      // Minimax AI algorithm
      let bestScore = -Infinity;
      let bestMove = 0;
      
      for (let i = 0; i < 9; i++) {
        if (tictactoe.board[i] === '') {
          tictactoe.board[i] = 'O';
          const score = minimax(tictactoe.board, 0, false);
          tictactoe.board[i] = '';
          
          if (score > bestScore) {
            bestScore = score;
            bestMove = i;
          }
        }
      }
      
      return bestMove;
    }
    
    function minimax(board, depth, isMaximizing) {
      if (checkWinner('O')) return 10 - depth;
      if (checkWinner('X')) return depth - 10;
      if (board.every(cell => cell !== '')) return 0;
      
      if (isMaximizing) {
        let bestScore = -Infinity;
        for (let i = 0; i < 9; i++) {
          if (board[i] === '') {
            board[i] = 'O';
            const score = minimax(board, depth + 1, false);
            board[i] = '';
            bestScore = Math.max(score, bestScore);
          }
        }
        return bestScore;
      } else {
        let bestScore = Infinity;
        for (let i = 0; i < 9; i++) {
          if (board[i] === '') {
            board[i] = 'X';
            const score = minimax(board, depth + 1, true);
            board[i] = '';
            bestScore = Math.min(score, bestScore);
          }
        }
        return bestScore;
      }
    }
    
    function endTTTGame(message) {
      tictactoe.gameOver = true;
      const status = document.getElementById('ticTacStatus');
      if (status) status.textContent = message;
      setTimeout(() => {
        alert(message);
        initTicTacToe();
        if (status) status.textContent = 'Your turn! (X)';
      }, 100);
    }

    function resetTicTac() {
      initTicTacToe();
      const status = document.getElementById('ticTacStatus');
      if (status) status.textContent = 'Your turn! (X)';
    }
    
    if (document.getElementById('ticTacBoard')) {
      initTicTacToe();
    }
  </script>

  <!-- Helper Functions for Drawing Games -->
  <script>
    // Drawing canvas helper functions
    function clearDrawing() {
      const canvas = document.getElementById('drawingCanvas');
      if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function downloadDrawing() {
      const canvas = document.getElementById('drawingCanvas');
      if (canvas) {
        const link = document.createElement('a');
        link.download = 'drawing.png';
        link.href = canvas.toDataURL();
        link.click();
      }
    }

    function setDrawColor(color) {
      // This would be handled by the drawing game logic
      if (window.currentDrawingColor !== undefined) {
        window.currentDrawingColor = color;
      }
    }
  </script>

  <!-- ZOMBIE SURVIVAL SHOOTER -->
  <script>
    const zombieCanvas = document.getElementById('zombieCanvas');
    const zombieCtx = zombieCanvas ? zombieCanvas.getContext('2d') : null;
    
    let zombieGame = {
      player: { x: 350, y: 250, size: 20, speed: 3, health: 100, maxHealth: 100, angle: 0 },
      zombies: [],
      bullets: [],
      items: [],
      powerups: [],
      inventory: { weapons: ['pistol'], currentWeapon: 'pistol', ammo: 30, healthPacks: 0 },
      wave: 1,
      score: 0,
      keys: {},
      gameActive: false,
      paused: false,
      gameLoop: null,
      mouseX: 0,
      mouseY: 0,
      activePowerups: { minigun: 0, rapidFire: 0, shield: 0, speedBoost: 0 },
      weapons: {
        pistol: { damage: 20, fireRate: 300, ammo: 30, maxAmmo: 30, spread: 0.1 },
        shotgun: { damage: 15, fireRate: 800, ammo: 8, maxAmmo: 8, spread: 0.3, pellets: 5 },
        rifle: { damage: 30, fireRate: 150, ammo: 50, maxAmmo: 50, spread: 0.05 },
        smg: { damage: 12, fireRate: 100, ammo: 60, maxAmmo: 60, spread: 0.15 },
        minigun: { damage: 25, fireRate: 50, ammo: 200, maxAmmo: 200, spread: 0.2 }
      },
      lastShot: 0,
      minigunActive: false,
      minigunTimer: null,
      waveTransitioning: false
    };

    function startZombieGame() {
      if (!zombieCanvas) return;
      stopAllGames();
      zombieGame.gameActive = true;
      zombieGame.paused = false;
      zombieGame.wave = 1; // Reset to wave 1
      zombieGame.score = 0; // Reset score
      zombieGame.player.health = zombieGame.player.maxHealth;
      zombieGame.inventory.ammo = 30; // Reset ammo
      zombieGame.zombies = [];
      zombieGame.bullets = [];
      zombieGame.items = [];
      zombieGame.powerups = [];
      zombieGame.activePowerups = { minigun: 0, rapidFire: 0, shield: 0, speedBoost: 0 };
      zombieGame.minigunActive = false;
      updateZombieUI();
      if (zombieGame.gameLoop) cancelAnimationFrame(zombieGame.gameLoop);
      zombieGameLoop();
      spawnZombieWave();
    }

    function pauseZombieGame() {
      zombieGame.paused = !zombieGame.paused;
      if (!zombieGame.paused && zombieGame.gameActive) zombieGameLoop();
    }

    function zombieGameLoop() {
      if (!zombieCtx || !zombieGame.gameActive || zombieGame.paused) return;

      // Clear canvas
      zombieCtx.fillStyle = '#1a1a2e';
      zombieCtx.fillRect(0, 0, zombieCanvas.width, zombieCanvas.height);

      // Grid background
      zombieCtx.strokeStyle = 'rgba(0,217,255,0.1)';
      zombieCtx.lineWidth = 1;
      for (let i = 0; i < zombieCanvas.width; i += 50) {
        zombieCtx.beginPath();
        zombieCtx.moveTo(i, 0);
        zombieCtx.lineTo(i, zombieCanvas.height);
        zombieCtx.stroke();
      }
      for (let i = 0; i < zombieCanvas.height; i += 50) {
        zombieCtx.beginPath();
        zombieCtx.moveTo(0, i);
        zombieCtx.lineTo(zombieCanvas.width, i);
        zombieCtx.stroke();
      }

      // Move player
      const playerSpeed = zombieGame.player.speed * (zombieGame.activePowerups.speedBoost > Date.now() ? 2 : 1);
      if (zombieGame.keys['w'] || zombieGame.keys['W']) zombieGame.player.y = Math.max(zombieGame.player.size, zombieGame.player.y - playerSpeed);
      if (zombieGame.keys['s'] || zombieGame.keys['S']) zombieGame.player.y = Math.min(zombieCanvas.height - zombieGame.player.size, zombieGame.player.y + playerSpeed);
      if (zombieGame.keys['a'] || zombieGame.keys['A']) zombieGame.player.x = Math.max(zombieGame.player.size, zombieGame.player.x - playerSpeed);
      if (zombieGame.keys['d'] || zombieGame.keys['D']) zombieGame.player.x = Math.min(zombieCanvas.width - zombieGame.player.size, zombieGame.player.x + playerSpeed);

      // Calculate player angle to mouse
      const rect = zombieCanvas.getBoundingClientRect();
      zombieGame.player.angle = Math.atan2(zombieGame.mouseY - zombieGame.player.y, zombieGame.mouseX - zombieGame.player.x);

      // Draw shield if active
      if (zombieGame.activePowerups.shield > Date.now()) {
        zombieCtx.strokeStyle = '#00d9ff';
        zombieCtx.lineWidth = 3;
        zombieCtx.beginPath();
        zombieCtx.arc(zombieGame.player.x, zombieGame.player.y, zombieGame.player.size + 10, 0, Math.PI * 2);
        zombieCtx.stroke();
        zombieCtx.strokeStyle = '#a855f7';
        zombieCtx.lineWidth = 2;
        zombieCtx.beginPath();
        zombieCtx.arc(zombieGame.player.x, zombieGame.player.y, zombieGame.player.size + 15, 0, Math.PI * 2);
        zombieCtx.stroke();
      }

      // Draw player
      zombieCtx.save();
      zombieCtx.translate(zombieGame.player.x, zombieGame.player.y);
      zombieCtx.rotate(zombieGame.player.angle);
      zombieCtx.fillStyle = zombieGame.minigunActive ? '#ff0000' : '#00d9ff';
      zombieCtx.fillRect(-zombieGame.player.size, -zombieGame.player.size/2, zombieGame.player.size * 2, zombieGame.player.size);
      zombieCtx.fillStyle = zombieGame.minigunActive ? '#ff6600' : '#a855f7';
      zombieCtx.fillRect(zombieGame.player.size, -5, zombieGame.minigunActive ? 20 : 15, 10); // Gun
      zombieCtx.restore();

      // Health bar
      zombieCtx.fillStyle = '#ef4444';
      zombieCtx.fillRect(zombieGame.player.x - 20, zombieGame.player.y - 30, 40 * (zombieGame.player.health / zombieGame.player.maxHealth), 5);
      zombieCtx.strokeStyle = 'white';
      zombieCtx.strokeRect(zombieGame.player.x - 20, zombieGame.player.y - 30, 40, 5);

      // Update and draw bullets
      zombieGame.bullets = zombieGame.bullets.filter(bullet => {
        bullet.x += Math.cos(bullet.angle) * bullet.speed;
        bullet.y += Math.sin(bullet.angle) * bullet.speed;
        
        zombieCtx.fillStyle = '#ffff00';
        zombieCtx.beginPath();
        zombieCtx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
        zombieCtx.fill();

        return bullet.x > 0 && bullet.x < zombieCanvas.width && bullet.y > 0 && bullet.y < zombieCanvas.height;
      });

      // Update and draw zombies
      zombieGame.zombies = zombieGame.zombies.filter(zombie => {
        // Move towards player
        const dx = zombieGame.player.x - zombie.x;
        const dy = zombieGame.player.y - zombie.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0) {
          zombie.x += (dx / dist) * zombie.speed;
          zombie.y += (dy / dist) * zombie.speed;
        }

        // Draw zombie
        zombieCtx.fillStyle = zombie.type === 'fast' ? '#ff6b00' : '#00ff00';
        zombieCtx.beginPath();
        zombieCtx.arc(zombie.x, zombie.y, zombie.size, 0, Math.PI * 2);
        zombieCtx.fill();
        zombieCtx.fillStyle = '#ef4444';
        zombieCtx.fillRect(zombie.x - 3, zombie.y - 5, 6, 3); // Eyes

        // Health bar
        if (zombie.health < zombie.maxHealth) {
          zombieCtx.fillStyle = '#ef4444';
          zombieCtx.fillRect(zombie.x - 15, zombie.y - 25, 30 * (zombie.health / zombie.maxHealth), 3);
          zombieCtx.strokeStyle = 'white';
          zombieCtx.strokeRect(zombie.x - 15, zombie.y - 25, 30, 3);
        }

        // Check bullet collisions
        for (let i = zombieGame.bullets.length - 1; i >= 0; i--) {
          const bullet = zombieGame.bullets[i];
          const dx = bullet.x - zombie.x;
          const dy = bullet.y - zombie.y;
          if (Math.sqrt(dx * dx + dy * dy) < zombie.size + 3) {
            zombie.health -= zombieGame.weapons[zombieGame.inventory.currentWeapon].damage;
            zombieGame.bullets.splice(i, 1);
            if (zombie.health <= 0) {
              zombieGame.score += 10;
              updateZombieUI();
              // Random item drop (30% chance)
              if (Math.random() < 0.3) {
                spawnItem(zombie.x, zombie.y);
              }
              // Random powerup drop (15% chance)
              if (Math.random() < 0.15) {
                spawnPowerup(zombie.x, zombie.y);
              }
              return false;
            }
          }
        }

        // Check player collision
        const playerDist = Math.sqrt(dx * dx + dy * dy);
        if (playerDist < zombieGame.player.size + zombie.size) {
          // Shield blocks damage
          if (zombieGame.activePowerups.shield > Date.now()) {
            zombieGame.activePowerups.shield = 0; // Shield breaks after one hit
          } else {
            zombieGame.player.health -= 0.5;
          }
          updateZombieUI();
          if (zombieGame.player.health <= 0) {
            endZombieGame();
          }
        }

        return true;
      });

      // Draw and update items
      zombieGame.items = zombieGame.items.filter(item => {
        zombieCtx.fillStyle = item.type === 'ammo' ? '#f59e0b' : item.type === 'health' ? '#10b981' : '#a855f7';
        zombieCtx.fillRect(item.x - 8, item.y - 8, 16, 16);
        zombieCtx.strokeStyle = 'white';
        zombieCtx.strokeRect(item.x - 8, item.y - 8, 16, 16);
        zombieCtx.fillStyle = 'white';
        zombieCtx.font = '12px Arial';
        zombieCtx.textAlign = 'center';
        zombieCtx.fillText(item.type === 'ammo' ? 'üéØ' : item.type === 'health' ? '‚ù§Ô∏è' : 'üî´', item.x, item.y + 4);

        // Check pickup
        const dx = zombieGame.player.x - item.x;
        const dy = zombieGame.player.y - item.y;
        if (Math.sqrt(dx * dx + dy * dy) < 30) {
          pickupItem(item);
          return false;
        }
        return true;
      });

      // Draw and update powerups
      zombieGame.powerups = zombieGame.powerups.filter(powerup => {
        const colors = { minigun: '#ff0000', rapidFire: '#ffff00', shield: '#00d9ff', speedBoost: '#10b981' };
        const emojis = { minigun: 'üî•', rapidFire: '‚ö°', shield: 'üõ°Ô∏è', speedBoost: 'üí®' };
        
        zombieCtx.fillStyle = colors[powerup.type];
        zombieCtx.shadowBlur = 15;
        zombieCtx.shadowColor = colors[powerup.type];
        zombieCtx.beginPath();
        zombieCtx.arc(powerup.x, powerup.y, 12, 0, Math.PI * 2);
        zombieCtx.fill();
        zombieCtx.shadowBlur = 0;
        
        zombieCtx.fillStyle = 'white';
        zombieCtx.font = 'bold 16px Arial';
        zombieCtx.textAlign = 'center';
        zombieCtx.textBaseline = 'middle';
        zombieCtx.fillText(emojis[powerup.type], powerup.x, powerup.y);

        // Check pickup
        const dx = zombieGame.player.x - powerup.x;
        const dy = zombieGame.player.y - powerup.y;
        if (Math.sqrt(dx * dx + dy * dy) < 30) {
          pickupPowerup(powerup);
          return false;
        }
        return true;
      });

      // Check wave complete
      if (zombieGame.zombies.length === 0 && zombieGame.gameActive && !zombieGame.waveTransitioning) {
        zombieGame.waveTransitioning = true;
        updateZombieUI();
        setTimeout(() => {
          zombieGame.wave++;
          updateZombieUI();
          spawnZombieWave();
          zombieGame.waveTransitioning = false;
        }, 2000);
      }

      zombieGame.gameLoop = requestAnimationFrame(zombieGameLoop);
    }

    function spawnZombieWave() {
      // Make wave 1 MUCH easier (only 2 zombies), then scale up progressively
      const zombieCount = zombieGame.wave === 1 ? 2 : Math.min(2 + zombieGame.wave * 1.5, 15);
      for (let i = 0; i < zombieCount; i++) {
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = Math.random() * zombieCanvas.width; y = -20; }
        else if (side === 1) { x = zombieCanvas.width + 20; y = Math.random() * zombieCanvas.height; }
        else if (side === 2) { x = Math.random() * zombieCanvas.width; y = zombieCanvas.height + 20; }
        else { x = -20; y = Math.random() * zombieCanvas.height; }

        // Wave 1: only slow zombies. Later waves: mix of types
        const fastChance = zombieGame.wave === 1 ? 0 : Math.min(0.2 + zombieGame.wave * 0.05, 0.5);
        const type = Math.random() < fastChance ? 'fast' : 'normal';
        
        zombieGame.zombies.push({
          x, y,
          size: type === 'fast' ? 12 : 15,
          speed: type === 'fast' ? (1.5 + zombieGame.wave * 0.1) : (0.8 + zombieGame.wave * 0.05),
          health: type === 'fast' ? (20 + zombieGame.wave * 3) : (30 + zombieGame.wave * 5),
          maxHealth: type === 'fast' ? (20 + zombieGame.wave * 3) : (30 + zombieGame.wave * 5),
          type
        });
      }
    }

    function spawnItem(x, y) {
      const types = ['ammo', 'health', 'weapon'];
      const type = types[Math.floor(Math.random() * types.length)];
      zombieGame.items.push({ x, y, type });
    }

    function spawnPowerup(x, y) {
      const types = ['minigun', 'rapidFire', 'shield', 'speedBoost'];
      const type = types[Math.floor(Math.random() * types.length)];
      zombieGame.powerups.push({ x, y, type });
    }

    function pickupItem(item) {
      if (item.type === 'ammo') {
        zombieGame.inventory.ammo = Math.min(
          zombieGame.inventory.ammo + 20,
          zombieGame.weapons[zombieGame.inventory.currentWeapon].maxAmmo
        );
      } else if (item.type === 'health') {
        zombieGame.player.health = Math.min(zombieGame.player.maxHealth, zombieGame.player.health + 30);
      } else if (item.type === 'weapon') {
        const weapons = ['shotgun', 'rifle', 'smg'];
        const newWeapon = weapons[Math.floor(Math.random() * weapons.length)];
        if (!zombieGame.inventory.weapons.includes(newWeapon)) {
          zombieGame.inventory.weapons.push(newWeapon);
        }
      }
      updateZombieUI();
    }

    function pickupPowerup(powerup) {
      const duration = 10000; // 10 seconds
      
      if (powerup.type === 'minigun') {
        zombieGame.minigunActive = true;
        zombieGame.activePowerups.minigun = Date.now() + duration;
        if (zombieGame.minigunTimer) clearInterval(zombieGame.minigunTimer);
        zombieGame.minigunTimer = setInterval(() => {
          if (zombieGame.minigunActive && zombieGame.gameActive && !zombieGame.paused) {
            shootZombie();
          }
        }, 50); // 20 bullets per second
        setTimeout(() => {
          zombieGame.minigunActive = false;
          if (zombieGame.minigunTimer) clearInterval(zombieGame.minigunTimer);
        }, duration);
      } else if (powerup.type === 'rapidFire') {
        zombieGame.activePowerups.rapidFire = Date.now() + duration;
      } else if (powerup.type === 'shield') {
        zombieGame.activePowerups.shield = Date.now() + duration;
      } else if (powerup.type === 'speedBoost') {
        zombieGame.activePowerups.speedBoost = Date.now() + duration;
      }
      updateZombieUI();
    }

    function shootZombie() {
      const now = Date.now();
      const weapon = zombieGame.minigunActive ? zombieGame.weapons.minigun : zombieGame.weapons[zombieGame.inventory.currentWeapon];
      
      // Apply rapid fire powerup (half the fire rate)
      const fireRate = zombieGame.activePowerups.rapidFire > Date.now() ? weapon.fireRate / 2 : weapon.fireRate;
      
      // Infinite ammo - only check fire rate
      if (now - zombieGame.lastShot < fireRate) return;
      
      zombieGame.lastShot = now;
      // Don't decrease ammo - infinite!
      updateZombieUI();

      const pellets = weapon.pellets || 1;
      for (let i = 0; i < pellets; i++) {
        const spread = (Math.random() - 0.5) * weapon.spread;
        zombieGame.bullets.push({
          x: zombieGame.player.x,
          y: zombieGame.player.y,
          angle: zombieGame.player.angle + spread,
          speed: 10
        });
      }
    }

    function updateZombieUI() {
      if (document.getElementById('zombieWave')) document.getElementById('zombieWave').textContent = zombieGame.wave;
      if (document.getElementById('zombieHealth')) document.getElementById('zombieHealth').textContent = Math.max(0, Math.floor(zombieGame.player.health));
      if (document.getElementById('zombieAmmo')) document.getElementById('zombieAmmo').textContent = '‚àû'; // Infinite ammo
      if (document.getElementById('zombieScore')) document.getElementById('zombieScore').textContent = zombieGame.score;
      
      const invDiv = document.getElementById('zombieInventory');
      if (invDiv) {
        invDiv.innerHTML = zombieGame.inventory.weapons.map(w => 
          `<span style="padding: 8px 15px; background: ${w === zombieGame.inventory.currentWeapon ? 'var(--primary-color)' : 'rgba(255,255,255,0.1)'}; border-radius: 8px; font-size: 0.9rem;">${w}</span>`
        ).join('');
      }
      
      const powerupsDiv = document.getElementById('zombiePowerups');
      if (powerupsDiv) {
        const now = Date.now();
        const activePowerups = [];
        const colors = { minigun: '#ff0000', rapidFire: '#ffff00', shield: '#00d9ff', speedBoost: '#10b981' };
        const names = { minigun: 'üî• MINIGUN', rapidFire: '‚ö° RAPID FIRE', shield: 'üõ°Ô∏è SHIELD', speedBoost: 'üí® SPEED BOOST' };
        
        for (const [key, expiry] of Object.entries(zombieGame.activePowerups)) {
          if (expiry > now) {
            const timeLeft = Math.ceil((expiry - now) / 1000);
            activePowerups.push(`<span style="padding: 6px 12px; background: ${colors[key]}; color: black; border-radius: 8px; font-weight: bold; font-size: 0.85rem;">${names[key]} (${timeLeft}s)</span>`);
          }
        }
        
        powerupsDiv.innerHTML = activePowerups.length > 0 ? activePowerups.join('') : '<span>None active</span>';
      }
    }

    function endZombieGame() {
      zombieGame.gameActive = false;
      zombieCtx.fillStyle = 'rgba(0,0,0,0.8)';
      zombieCtx.fillRect(0, 0, zombieCanvas.width, zombieCanvas.height);
      zombieCtx.fillStyle = '#ef4444';
      zombieCtx.font = 'bold 40px Arial';
      zombieCtx.textAlign = 'center';
      zombieCtx.fillText('GAME OVER', zombieCanvas.width / 2, zombieCanvas.height / 2 - 30);
      zombieCtx.fillStyle = 'white';
      zombieCtx.font = '24px Arial';
      zombieCtx.fillText(`Wave: ${zombieGame.wave} | Score: ${zombieGame.score}`, zombieCanvas.width / 2, zombieCanvas.height / 2 + 20);
    }

    if (zombieCanvas) {
      zombieCanvas.addEventListener('mousemove', (e) => {
        const rect = zombieCanvas.getBoundingClientRect();
        zombieGame.mouseX = e.clientX - rect.left;
        zombieGame.mouseY = e.clientY - rect.top;
      });
      
      zombieCanvas.addEventListener('click', shootZombie);
      
      document.addEventListener('keydown', (e) => {
        zombieGame.keys[e.key] = true;
        if (e.key === 'r' || e.key === 'R') {
          zombieGame.inventory.ammo = zombieGame.weapons[zombieGame.inventory.currentWeapon].maxAmmo;
          updateZombieUI();
        }
        if (e.key >= '1' && e.key <= '4') {
          const weapons = ['pistol', 'shotgun', 'rifle', 'smg'];
          const weaponIndex = parseInt(e.key) - 1;
          if (zombieGame.inventory.weapons.includes(weapons[weaponIndex])) {
            zombieGame.inventory.currentWeapon = weapons[weaponIndex];
            zombieGame.inventory.ammo = zombieGame.weapons[zombieGame.inventory.currentWeapon].maxAmmo;
            updateZombieUI();
          }
        }
      });
      
      document.addEventListener('keyup', (e) => { zombieGame.keys[e.key] = false; });
    }
  </script>

  <!-- AI DRAWING GUESSER -->
  <script>
    const guessCanvas = document.getElementById('guessCanvas');
    const guessCtx = guessCanvas ? guessCanvas.getContext('2d') : null;
    
    let guessGame = {
      mode: 'player', // 'player' or 'ai'
      drawing: false,
      strokes: [],
      currentWord: '',
      prompts: ['cat', 'dog', 'house', 'tree', 'car', 'sun', 'flower', 'boat', 'bird', 'fish'],
      aiGuessInterval: null,
      aiDrawingData: [],
      correctGuesses: 0,
      totalRounds: 0,
      aiDrawProgress: 0
    };

    function setGuessMode(mode) {
      guessGame.mode = mode;
      document.getElementById('playerDrawMode').style.display = mode === 'player' ? 'block' : 'none';
      document.getElementById('aiDrawMode').style.display = mode === 'ai' ? 'block' : 'none';
      document.getElementById('modePlayer').style.background = mode === 'player' ? 'var(--primary-color)' : '';
      document.getElementById('modeAI').style.background = mode === 'ai' ? 'var(--primary-color)' : '';
      newGuessRound();
    }

    function newGuessRound() {
      clearGuessCanvas();
      guessGame.strokes = [];
      guessGame.currentWord = guessGame.prompts[Math.floor(Math.random() * guessGame.prompts.length)];
      guessGame.totalRounds++;
      updateGuessStats();
      
      if (guessGame.mode === 'player') {
        document.getElementById('drawPrompt').textContent = guessGame.currentWord;
        document.getElementById('secretWord').value = '';
        document.getElementById('guessList').innerHTML = '<p style="color: var(--text-secondary);">AI will start guessing as you draw...</p>';
        
        if (guessGame.aiGuessInterval) clearInterval(guessGame.aiGuessInterval);
        guessGame.aiGuessInterval = setInterval(makeAIGuess, 3000);
      } else {
        document.getElementById('playerGuess').value = '';
        document.getElementById('guessResult').style.display = 'none';
        startAIDrawing();
      }
    }

    function makeAIGuess() {
      if (guessGame.strokes.length === 0) return;
      
      const possibleWords = ['cat', 'dog', 'house', 'tree', 'car', 'circle', 'square', 'person', 'sun', 'flower'];
      const guess = possibleWords[Math.floor(Math.random() * possibleWords.length)];
      
      const guessList = document.getElementById('guessList');
      const secretWord = document.getElementById('secretWord').value.toLowerCase();
      
      if (secretWord && guess.toLowerCase() === secretWord) {
        guessList.innerHTML = `<p style="color: #10b981; font-weight: bold;">‚úÖ AI guessed correctly: "${guess}"!</p>`;
        guessGame.correctGuesses++;
        updateGuessStats();
        if (guessGame.aiGuessInterval) clearInterval(guessGame.aiGuessInterval);
        setTimeout(newGuessRound, 2000);
      } else {
        const currentGuesses = guessList.innerHTML;
        if (!currentGuesses.includes('AI will start')) {
          guessList.innerHTML = `<p style="color: var(--text-secondary);">ü§î AI guessed: ${guess}</p>` + currentGuesses;
        } else {
          guessList.innerHTML = `<p style="color: var(--text-secondary);">ü§î AI guessed: ${guess}</p>`;
        }
      }
    }

    function startAIDrawing() {
      const drawings = {
        cat: [[100,300], [150,250], [200,200], [250,250], [300,300], [150,200], [200,150]],
        house: [[200,100], [300,200], [300,350], [100,350], [100,200], [200,100], [150,200], [150,280]],
        tree: [[200,350], [200,200], [150,150], [200,100], [250,150], [200,200]]
      };
      
      const wordsToDraw = Object.keys(drawings);
      guessGame.currentWord = wordsToDraw[Math.floor(Math.random() * wordsToDraw.length)];
      guessGame.aiDrawingData = drawings[guessGame.currentWord];
      guessGame.aiDrawProgress = 0;
      
      const drawInterval = setInterval(() => {
        if (guessGame.aiDrawProgress < guessGame.aiDrawingData.length - 1) {
          const p1 = guessGame.aiDrawingData[guessGame.aiDrawProgress];
          const p2 = guessGame.aiDrawingData[guessGame.aiDrawProgress + 1];
          
          guessCtx.strokeStyle = '#000000';
          guessCtx.lineWidth = 3;
          guessCtx.beginPath();
          guessCtx.moveTo(p1[0], p1[1]);
          guessCtx.lineTo(p2[0], p2[1]);
          guessCtx.stroke();
          
          guessGame.aiDrawProgress++;
        } else {
          clearInterval(drawInterval);
        }
      }, 500);
    }

    function submitPlayerGuess() {
      const guess = document.getElementById('playerGuess').value.toLowerCase();
      const resultDiv = document.getElementById('guessResult');
      
      if (guess === guessGame.currentWord.toLowerCase()) {
        resultDiv.innerHTML = '<p style="color: #10b981; font-weight: bold;">‚úÖ Correct! You guessed it!</p>';
        resultDiv.style.background = 'rgba(16,185,129,0.1)';
        guessGame.correctGuesses++;
      } else {
        resultDiv.innerHTML = `<p style="color: #ef4444; font-weight: bold;">‚ùå Wrong! It was: ${guessGame.currentWord}</p>`;
        resultDiv.style.background = 'rgba(239,68,68,0.1)';
      }
      
      resultDiv.style.display = 'block';
      updateGuessStats();
      setTimeout(newGuessRound, 2000);
    }

    function clearGuessCanvas() {
      if (!guessCtx) return;
      guessCtx.fillStyle = 'white';
      guessCtx.fillRect(0, 0, guessCanvas.width, guessCanvas.height);
    }

    function updateGuessStats() {
      if (document.getElementById('correctGuesses')) document.getElementById('correctGuesses').textContent = guessGame.correctGuesses;
      if (document.getElementById('totalRounds')) document.getElementById('totalRounds').textContent = guessGame.totalRounds;
      if (document.getElementById('accuracy')) {
        const acc = guessGame.totalRounds > 0 ? Math.round((guessGame.correctGuesses / guessGame.totalRounds) * 100) : 0;
        document.getElementById('accuracy').textContent = acc + '%';
      }
    }

    if (guessCanvas) {
      guessCanvas.addEventListener('mousedown', (e) => {
        if (guessGame.mode !== 'player') return;
        guessGame.drawing = true;
        const rect = guessCanvas.getBoundingClientRect();
        guessGame.strokes.push([]);
        guessGame.strokes[guessGame.strokes.length - 1].push({
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        });
      });
      
      guessCanvas.addEventListener('mousemove', (e) => {
        if (!guessGame.drawing || guessGame.mode !== 'player') return;
        const rect = guessCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        guessGame.strokes[guessGame.strokes.length - 1].push({ x, y });
        
        guessCtx.strokeStyle = '#000000';
        guessCtx.lineWidth = 3;
        guessCtx.lineCap = 'round';
        guessCtx.beginPath();
        const lastStroke = guessGame.strokes[guessGame.strokes.length - 1];
        guessCtx.moveTo(lastStroke[lastStroke.length - 2].x, lastStroke[lastStroke.length - 2].y);
        guessCtx.lineTo(x, y);
        guessCtx.stroke();
      });
      
      guessCanvas.addEventListener('mouseup', () => { guessGame.drawing = false; });
      
      clearGuessCanvas();
      newGuessRound();
    }
  </script>

  <!-- AI HIDE AND SEEK -->
  <script>
    const hideSeekCanvas = document.getElementById('hideSeekCanvas');
    const hideSeekCtx = hideSeekCanvas ? hideSeekCanvas.getContext('2d') : null;
    
    let hideSeekGame = {
      player: { x: 100, y: 100, size: 15, speed: 4 },
      ai: { x: 550, y: 350, size: 15, speed: 2.5, path: [], searchMode: 'patrol', memory: [], patrolTarget: null, lastSeenPos: null, chaseSpeed: 4 },
      obstacles: [],
      timeLeft: 45,
      wins: parseInt(localStorage.getItem('hideSeekWins')) || 0,
      losses: parseInt(localStorage.getItem('hideSeekLosses')) || 0,
      gameActive: false,
      keys: {},
      difficulty: 'medium',
      gameLoop: null,
      timer: null,
      canSeePlayer: false
    };

    function generateRandomMap() {
      const obstacles = [];
      const canvas = hideSeekCanvas;
      
      // Add walls around border with gaps for movement
      obstacles.push(
        { x: 0, y: 0, width: canvas.width, height: 20 },
        { x: 0, y: canvas.height - 20, width: canvas.width, height: 20 },
        { x: 0, y: 0, width: 20, height: canvas.height },
        { x: canvas.width - 20, y: 0, width: 20, height: canvas.height }
      );
      
      // Generate strategic obstacles (walls and boxes) ensuring paths exist
      const numObstacles = 10 + Math.floor(Math.random() * 5);
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      for (let i = 0; i < numObstacles; i++) {
        const isWall = Math.random() < 0.4;
        let x, y, width, height;
        
        // Avoid placing in center corridor for AI movement
        do {
          x = 50 + Math.random() * (canvas.width - 150);
          y = 50 + Math.random() * (canvas.height - 150);
          width = isWall ? (60 + Math.random() * 80) : (35 + Math.random() * 35);
          height = isWall ? (20 + Math.random() * 25) : (35 + Math.random() * 35);
        } while (
          // Keep center paths clear
          (x < centerX + 80 && x + width > centerX - 80 && Math.abs(y - centerY) < 40) ||
          (y < centerY + 80 && y + height > centerY - 80 && Math.abs(x - centerX) < 40)
        );
        
        obstacles.push({ x, y, width, height });
      }
      
      return obstacles;
    }

    function hasLineOfSight(x1, y1, x2, y2) {
      // Cast ray from AI to player
      const dx = x2 - x1;
      const dy = y2 - y1;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const steps = Math.floor(distance / 5);
      
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const checkX = x1 + dx * t;
        const checkY = y1 + dy * t;
        
        // Check if this point intersects any obstacle
        for (const obs of hideSeekGame.obstacles) {
          if (checkX > obs.x && checkX < obs.x + obs.width &&
              checkY > obs.y && checkY < obs.y + obs.height) {
            return false;
          }
        }
      }
      return true;
    }

    function findPatrolPoint() {
      // Pick a random reachable point
      for (let attempts = 0; attempts < 20; attempts++) {
        const x = 50 + Math.random() * (hideSeekCanvas.width - 100);
        const y = 50 + Math.random() * (hideSeekCanvas.height - 100);
        if (!checkCollision(x, y, hideSeekGame.ai.size)) {
          return { x, y };
        }
      }
      return { x: hideSeekCanvas.width / 2, y: hideSeekCanvas.height / 2 };
    }

    function startHideSeek() {
      if (!hideSeekCanvas) return;
      stopAllGames();
      hideSeekGame.gameActive = true;
      hideSeekGame.timeLeft = 45;
      hideSeekGame.canSeePlayer = false;
      
      // Generate new random map
      hideSeekGame.obstacles = generateRandomMap();
      
      // Find valid spawn positions
      let playerSpawned = false, aiSpawned = false;
      for (let attempts = 0; attempts < 50 && (!playerSpawned || !aiSpawned); attempts++) {
        if (!playerSpawned) {
          const px = 50 + Math.random() * 150;
          const py = 50 + Math.random() * 150;
          if (!checkCollision(px, py, 15)) {
            hideSeekGame.player = { x: px, y: py, size: 15, speed: 4 };
            playerSpawned = true;
          }
        }
        if (!aiSpawned) {
          const ax = hideSeekCanvas.width - 150 + Math.random() * 100;
          const ay = hideSeekCanvas.height - 150 + Math.random() * 100;
          if (!checkCollision(ax, ay, 15)) {
            const baseSpeed = hideSeekGame.difficulty === 'easy' ? 1.8 : hideSeekGame.difficulty === 'hard' ? 3.2 : 2.5;
            hideSeekGame.ai = { 
              x: ax, y: ay, size: 15, 
              speed: baseSpeed, 
              chaseSpeed: baseSpeed * 1.6,
              path: [], 
              searchMode: 'patrol', 
              memory: [],
              patrolTarget: null,
              lastSeenPos: null
            };
            aiSpawned = true;
          }
        }
      }
      
      hideSeekGame.ai.patrolTarget = findPatrolPoint();

      updateHideSeekUI();
      
      if (hideSeekGame.timer) clearInterval(hideSeekGame.timer);
      hideSeekGame.timer = setInterval(() => {
        hideSeekGame.timeLeft--;
        updateHideSeekUI();
        if (hideSeekGame.timeLeft <= 0) {
          winHideSeek();
        }
      }, 1000);

      if (hideSeekGame.gameLoop) cancelAnimationFrame(hideSeekGame.gameLoop);
      hideSeekGameLoop();
    }

    function hideSeekGameLoop() {
      if (!hideSeekCtx || !hideSeekGame.gameActive) return;

      hideSeekCtx.fillStyle = '#1a1a2e';
      hideSeekCtx.fillRect(0, 0, hideSeekCanvas.width, hideSeekCanvas.height);

      // Draw obstacles
      hideSeekGame.obstacles.forEach(obs => {
        hideSeekCtx.fillStyle = '#4a5568';
        hideSeekCtx.fillRect(obs.x, obs.y, obs.width, obs.height);
        hideSeekCtx.strokeStyle = '#2d3748';
        hideSeekCtx.lineWidth = 2;
        hideSeekCtx.strokeRect(obs.x, obs.y, obs.width, obs.height);
      });

      // Move player (always allowed)
      let newX = hideSeekGame.player.x;
      let newY = hideSeekGame.player.y;

      if (hideSeekGame.keys['w'] || hideSeekGame.keys['ArrowUp']) newY -= hideSeekGame.player.speed;
      if (hideSeekGame.keys['s'] || hideSeekGame.keys['ArrowDown']) newY += hideSeekGame.player.speed;
      if (hideSeekGame.keys['a'] || hideSeekGame.keys['ArrowLeft']) newX -= hideSeekGame.player.speed;
      if (hideSeekGame.keys['d'] || hideSeekGame.keys['ArrowRight']) newX += hideSeekGame.player.speed;

      // Check collisions and keep in bounds
      if (!checkCollision(newX, newY, hideSeekGame.player.size)) {
        hideSeekGame.player.x = Math.max(hideSeekGame.player.size + 5, Math.min(hideSeekCanvas.width - hideSeekGame.player.size - 5, newX));
        hideSeekGame.player.y = Math.max(hideSeekGame.player.size + 5, Math.min(hideSeekCanvas.height - hideSeekGame.player.size - 5, newY));
      }

      // AI behavior with line of sight
      const dx = hideSeekGame.player.x - hideSeekGame.ai.x;
      const dy = hideSeekGame.player.y - hideSeekGame.ai.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      hideSeekGame.canSeePlayer = hasLineOfSight(hideSeekGame.ai.x, hideSeekGame.ai.y, hideSeekGame.player.x, hideSeekGame.player.y);
      
      let targetX = hideSeekGame.player.x, targetY = hideSeekGame.player.y, moveSpeed = hideSeekGame.ai.speed;
      
      if (hideSeekGame.canSeePlayer) {
        // Chase player directly when visible
        hideSeekGame.ai.searchMode = 'chase';
        hideSeekGame.ai.lastSeenPos = { x: hideSeekGame.player.x, y: hideSeekGame.player.y };
        targetX = hideSeekGame.player.x;
        targetY = hideSeekGame.player.y;
        moveSpeed = hideSeekGame.ai.chaseSpeed;
      } else if (hideSeekGame.ai.lastSeenPos) {
        // Move to last seen position
        const lastDx = hideSeekGame.ai.lastSeenPos.x - hideSeekGame.ai.x;
        const lastDy = hideSeekGame.ai.lastSeenPos.y - hideSeekGame.ai.y;
        const lastDist = Math.sqrt(lastDx * lastDx + lastDy * lastDy);
        
        if (lastDist < 30) {
          // Reached last seen position, start searching nearby
          hideSeekGame.ai.lastSeenPos = null;
          hideSeekGame.ai.searchMode = 'search';
          hideSeekGame.ai.patrolTarget = findPatrolPoint();
          targetX = hideSeekGame.ai.patrolTarget.x;
          targetY = hideSeekGame.ai.patrolTarget.y;
          moveSpeed = hideSeekGame.ai.speed;
        } else {
          targetX = hideSeekGame.ai.lastSeenPos.x;
          targetY = hideSeekGame.ai.lastSeenPos.y;
          moveSpeed = hideSeekGame.ai.speed * 1.2;
        }
      } else {
        // Patrol mode - always moving
        hideSeekGame.ai.searchMode = 'patrol';
        if (!hideSeekGame.ai.patrolTarget) {
          hideSeekGame.ai.patrolTarget = findPatrolPoint();
        }
        
        const patrolDx = hideSeekGame.ai.patrolTarget.x - hideSeekGame.ai.x;
        const patrolDy = hideSeekGame.ai.patrolTarget.y - hideSeekGame.ai.y;
        const patrolDist = Math.sqrt(patrolDx * patrolDx + patrolDy * patrolDy);
        
        if (patrolDist < 20) {
          hideSeekGame.ai.patrolTarget = findPatrolPoint();
        }
        
        targetX = hideSeekGame.ai.patrolTarget.x;
        targetY = hideSeekGame.ai.patrolTarget.y;
        moveSpeed = hideSeekGame.ai.speed;
      }
      
      // ALWAYS Move AI toward target
      const moveDx = targetX - hideSeekGame.ai.x;
      const moveDy = targetY - hideSeekGame.ai.y;
      const moveDist = Math.sqrt(moveDx * moveDx + moveDy * moveDy);
      
      if (moveDist > 3) {
        const angle = Math.atan2(moveDy, moveDx);
        let newAiX = hideSeekGame.ai.x + Math.cos(angle) * moveSpeed;
        let newAiY = hideSeekGame.ai.y + Math.sin(angle) * moveSpeed;
        
        // Try to move around obstacles
        if (checkCollision(newAiX, newAiY, hideSeekGame.ai.size)) {
          // Try perpendicular directions
          newAiX = hideSeekGame.ai.x + Math.cos(angle + Math.PI/2) * moveSpeed;
          newAiY = hideSeekGame.ai.y + Math.sin(angle + Math.PI/2) * moveSpeed;
          
          if (checkCollision(newAiX, newAiY, hideSeekGame.ai.size)) {
            newAiX = hideSeekGame.ai.x + Math.cos(angle - Math.PI/2) * moveSpeed;
            newAiY = hideSeekGame.ai.y + Math.sin(angle - Math.PI/2) * moveSpeed;
          }
          
          // If still blocked, try backwards
          if (checkCollision(newAiX, newAiY, hideSeekGame.ai.size)) {
            newAiX = hideSeekGame.ai.x + Math.cos(angle + Math.PI) * moveSpeed * 0.5;
            newAiY = hideSeekGame.ai.y + Math.sin(angle + Math.PI) * moveSpeed * 0.5;
          }
        }
        
        if (!checkCollision(newAiX, newAiY, hideSeekGame.ai.size)) {
          hideSeekGame.ai.x = newAiX;
          hideSeekGame.ai.y = newAiY;
        }
      }
      
      // Check if AI caught player
      if (distance < hideSeekGame.ai.size + hideSeekGame.player.size + 5) {
        loseHideSeek();
        return;
      }

      // Draw player
      hideSeekCtx.fillStyle = hideSeekGame.canSeePlayer ? '#f59e0b' : '#10b981';
      hideSeekCtx.beginPath();
      hideSeekCtx.arc(hideSeekGame.player.x, hideSeekGame.player.y, hideSeekGame.player.size, 0, Math.PI * 2);
      hideSeekCtx.fill();
      hideSeekCtx.strokeStyle = 'white';
      hideSeekCtx.lineWidth = 2;
      hideSeekCtx.stroke();

      // Draw AI
      hideSeekCtx.fillStyle = hideSeekGame.ai.searchMode === 'chase' ? '#dc2626' : '#ef4444';
      hideSeekCtx.beginPath();
      hideSeekCtx.arc(hideSeekGame.ai.x, hideSeekGame.ai.y, hideSeekGame.ai.size, 0, Math.PI * 2);
      hideSeekCtx.fill();
      hideSeekCtx.strokeStyle = 'white';
      hideSeekCtx.lineWidth = 2;
      hideSeekCtx.stroke();

      // Draw sight line when AI can see player
      if (hideSeekGame.canSeePlayer) {
        hideSeekCtx.strokeStyle = 'rgba(239,68,68,0.6)';
        hideSeekCtx.lineWidth = 3;
        hideSeekCtx.setLineDash([5, 5]);
        hideSeekCtx.beginPath();
        hideSeekCtx.moveTo(hideSeekGame.ai.x, hideSeekGame.ai.y);
        hideSeekCtx.lineTo(hideSeekGame.player.x, hideSeekGame.player.y);
        hideSeekCtx.stroke();
        hideSeekCtx.setLineDash([]);
      }

      updateHideSeekUI();
      hideSeekGame.gameLoop = requestAnimationFrame(hideSeekGameLoop);
    }

    function checkCollision(x, y, size) {
      return hideSeekGame.obstacles.some(obs => 
        x + size > obs.x && x - size < obs.x + obs.width &&
        y + size > obs.y && y - size < obs.y + obs.height
      );
    }

    function winHideSeek() {
      hideSeekGame.gameActive = false;
      hideSeekGame.wins++;
      localStorage.setItem('hideSeekWins', hideSeekGame.wins);
      updateHideSeekUI();
      if (hideSeekGame.timer) clearInterval(hideSeekGame.timer);
      alert('üéâ You Win! Successfully hid from the AI!');
    }

    function loseHideSeek() {
      hideSeekGame.gameActive = false;
      hideSeekGame.losses++;
      localStorage.setItem('hideSeekLosses', hideSeekGame.losses);
      updateHideSeekUI();
      if (hideSeekGame.timer) clearInterval(hideSeekGame.timer);
      alert('‚ùå Caught! The AI found you!');
    }

    function toggleHideSeekDifficulty() {
      const difficulties = ['easy', 'medium', 'hard'];
      const current = difficulties.indexOf(hideSeekGame.difficulty);
      hideSeekGame.difficulty = difficulties[(current + 1) % 3];
      document.getElementById('aiDifficulty').textContent = hideSeekGame.difficulty.charAt(0).toUpperCase() + hideSeekGame.difficulty.slice(1);
    }

    function updateHideSeekUI() {
      if (document.getElementById('hideSeekTime')) document.getElementById('hideSeekTime').textContent = hideSeekGame.timeLeft;
      if (document.getElementById('hideSeekWins')) document.getElementById('hideSeekWins').textContent = hideSeekGame.wins;
      if (document.getElementById('hideSeekLosses')) document.getElementById('hideSeekLosses').textContent = hideSeekGame.losses;
      if (document.getElementById('aiStatus')) {
        let status = 'Click Start to begin!';
        if (hideSeekGame.gameActive) {
          const dist = Math.floor(Math.sqrt((hideSeekGame.player.x - hideSeekGame.ai.x)**2 + (hideSeekGame.player.y - hideSeekGame.ai.y)**2));
          const mode = hideSeekGame.ai.searchMode;
          const canSee = hideSeekGame.canSeePlayer ? 'üëÅÔ∏è SPOTTED!' : 'üîç';
          status = `${canSee} Mode: ${mode.toUpperCase()} | Distance: ${dist}px`;
        }
        document.getElementById('aiStatus').textContent = status;
      }
    }

    if (hideSeekCanvas) {
      document.addEventListener('keydown', (e) => { hideSeekGame.keys[e.key] = true; });
      document.addEventListener('keyup', (e) => { hideSeekGame.keys[e.key] = false; });
    }
  </script>

  <!-- EPIC RPG ADVENTURE - OPEN WORLD -->
  <script>
    const rpgCanvas = document.getElementById('rpgWorldCanvas');
    const rpgCtx = rpgCanvas ? rpgCanvas.getContext('2d') : null;
    const miniMapCanvas = document.getElementById('miniMap');
    const miniMapCtx = miniMapCanvas ? miniMapCanvas.getContext('2d') : null;

    let rpgGame = {
      // Character data
      character: {
        name: 'Hero',
        class: 'Adventurer',
        emoji: 'üó°Ô∏è',
        x: 450,
        y: 300,
        width: 30,
        height: 30,
        speed: 3,
        level: 1,
        health: 100,
        maxHealth: 100,
        mana: 50,
        maxMana: 50,
        attack: 12,
        defense: 6,
        gold: 100,
        experience: 0,
        kills: 0,
        direction: 'down'
      },
      
      // World data
      world: {
        width: 2400,
        height: 1800,
        tileSize: 40
      },
      
      camera: {
        x: 0,
        y: 0
      },
      
      // Game state
      keys: {},
      inventory: [],
      maxInventory: 48,
      equipment: {
        weapon: null,
        helmet: null,
        armor: null,
        boots: null,
        ring: null
      },
      
      // Entities in the world
      enemies: [],
      npcs: [],
      treasures: [],
      obstacles: [],
      
      // Combat state
      inCombat: false,
      currentEnemy: null,
      combatTimer: 0,
      timingIndicator: 0,
      timingDirection: 1,
      
      // Quest system
      quest: {
        active: false,
        type: '',
        target: 0,
        progress: 0,
        reward: {},
        title: '',
        description: ''
      },
      
      // Stats
      stats: {
        dungeonsCleared: 0,
        treasuresFound: 0,
        questsCompleted: 0,
        playtime: 0
      },
      
      // Game settings
      gameActive: false,
      lastUpdate: Date.now(),
      
      // Item database
      itemRarities: ['common', 'uncommon', 'rare', 'epic', 'legendary'],
      itemColors: {
        common: '#9ca3af',
        uncommon: '#10b981',
        rare: '#3b82f6',
        epic: '#a855f7',
        legendary: '#f59e0b'
      }
    };

    // World generation
    function initRPGWorld() {
      // Generate terrain obstacles (trees, rocks)
      for (let i = 0; i < 80; i++) {
        rpgGame.obstacles.push({
          x: Math.random() * (rpgGame.world.width - 100) + 50,
          y: Math.random() * (rpgGame.world.height - 100) + 50,
          width: 40 + Math.random() * 40,
          height: 40 + Math.random() * 40,
          type: Math.random() > 0.5 ? 'tree' : 'rock',
          emoji: Math.random() > 0.5 ? 'üå≤' : 'ü™®'
        });
      }
      
      // Add special landmarks
      rpgGame.obstacles.push(
        // Town fountain
        { x: 450, y: 350, width: 60, height: 60, type: 'landmark', emoji: '‚õ≤' },
        // Ancient statue in ruins
        { x: 1200, y: 1000, width: 70, height: 70, type: 'landmark', emoji: 'üóø' },
        // Mountain cave entrance
        { x: 1850, y: 450, width: 80, height: 80, type: 'landmark', emoji: 'üï≥Ô∏è' },
        // Dark forest shrine
        { x: 1950, y: 1450, width: 65, height: 65, type: 'landmark', emoji: '‚õ©Ô∏è' }
      );
      
      // Generate NPCs with different roles
      const npcData = [
        { name: 'Village Elder', emoji: 'üßô', quest: 'Defeat 10 enemies to protect our village!', questType: 'kills', questTarget: 10, role: 'quest', x: 400, y: 300 },
        { name: 'Merchant', emoji: 'üßë‚Äçüíº', quest: 'Bring me 5 treasures and I\'ll reward you!', questType: 'treasures', questTarget: 5, role: 'shop', x: 500, y: 400 },
        { name: 'Blacksmith', emoji: '‚öíÔ∏è', quest: '', questType: '', questTarget: 0, role: 'craft', x: 600, y: 350 },
        { name: 'Knight', emoji: '‚öîÔ∏è', quest: 'Reach level 5 and prove your strength!', questType: 'level', questTarget: 5, role: 'quest', x: 350, y: 450 },
        { name: 'Wizard', emoji: 'üßô‚Äç‚ôÇÔ∏è', quest: 'Collect 300 gold for my research!', questType: 'gold', questTarget: 300, role: 'quest', x: 450, y: 500 },
        { name: 'Trader', emoji: 'ü§ù', quest: '', questType: '', questTarget: 0, role: 'trade', x: 1800, y: 400 },
        { name: 'Healer', emoji: 'üßë‚Äç‚öïÔ∏è', quest: '', questType: '', questTarget: 0, role: 'heal', x: 400, y: 200 },
        { name: 'Innkeeper', emoji: 'üè†', quest: '', questType: '', questTarget: 0, role: 'rest', x: 300, y: 300 }
      ];
      
      npcData.forEach((npc) => {
        rpgGame.npcs.push({
          ...npc,
          width: 35,
          height: 35,
          hasQuest: npc.role === 'quest',
          questGiven: false,
          dialogue: getNPCDialogue(npc.role)
        });
      });
      
      // Generate enemies
      spawnEnemies();
      
      // Generate treasures (more spread out)
      for (let i = 0; i < 20; i++) {
        spawnTreasure();
      }
      
      // Start quest
      startNewQuest();
      
      // Initialize UI
      initRPGUI();
      
      // Initial location update
      updateLocationName();
      
      // Welcome message
      addGameLog('üéÆ Welcome to the RPG Adventure!', '#00d9ff');
      addGameLog('üí° Use WASD to move, Space to interact, E for inventory', '#10b981');
      
      rpgGame.gameActive = true;
      requestAnimationFrame(updateRPGWorld);
    }

    function spawnEnemies() {
      const enemyTypes = [
        // Level 1-2 enemies
        { name: 'Slime', emoji: 'üü¢', hp: 30, atk: 8, def: 2, gold: 15, xp: 20, speed: 1.5, minLevel: 1 },
        { name: 'Rat', emoji: 'üêÄ', hp: 25, atk: 7, def: 1, gold: 12, xp: 18, speed: 2.2, minLevel: 1 },
        { name: 'Spider', emoji: 'üï∑Ô∏è', hp: 28, atk: 9, def: 2, gold: 14, xp: 22, speed: 2, minLevel: 1 },
        
        // Level 3-4 enemies
        { name: 'Goblin', emoji: 'üë∫', hp: 45, atk: 12, def: 4, gold: 25, xp: 30, speed: 2, minLevel: 3 },
        { name: 'Wolf', emoji: 'üê∫', hp: 50, atk: 14, def: 3, gold: 28, xp: 32, speed: 2.3, minLevel: 3 },
        { name: 'Bat', emoji: 'ü¶á', hp: 40, atk: 11, def: 3, gold: 20, xp: 28, speed: 2.5, minLevel: 3 },
        
        // Level 5-6 enemies
        { name: 'Orc', emoji: 'üëπ', hp: 60, atk: 18, def: 6, gold: 40, xp: 45, speed: 1.8, minLevel: 5 },
        { name: 'Skeleton', emoji: 'üíÄ', hp: 55, atk: 16, def: 5, gold: 35, xp: 40, speed: 2.2, minLevel: 5 },
        { name: 'Ghost', emoji: 'üëª', hp: 50, atk: 15, def: 4, gold: 30, xp: 38, speed: 2, minLevel: 5 },
        
        // Level 7-9 enemies
        { name: 'Troll', emoji: 'üëø', hp: 80, atk: 22, def: 8, gold: 55, xp: 60, speed: 1.6, minLevel: 7 },
        { name: 'Demon', emoji: 'üòà', hp: 75, atk: 24, def: 7, gold: 60, xp: 65, speed: 1.9, minLevel: 7 },
        { name: 'Gargoyle', emoji: 'üóø', hp: 90, atk: 20, def: 10, gold: 50, xp: 55, speed: 1.5, minLevel: 7 },
        
        // Level 10+ enemies (Boss tier)
        { name: 'Dragon', emoji: 'üêâ', hp: 150, atk: 35, def: 15, gold: 120, xp: 120, speed: 1.5, minLevel: 10 },
        { name: 'Vampire', emoji: 'üßõ', hp: 130, atk: 32, def: 12, gold: 100, xp: 110, speed: 2, minLevel: 10 },
        { name: 'Lich', emoji: '‚ò†Ô∏è', hp: 140, atk: 30, def: 14, gold: 110, xp: 115, speed: 1.7, minLevel: 10 }
      ];
      
      // Filter enemies appropriate for current level
      const availableEnemies = enemyTypes.filter(e => e.minLevel <= rpgGame.character.level);
      
      for (let i = 0; i < 25; i++) {
        const type = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
        const levelMult = 0.8 + rpgGame.character.level * 0.2;
        
        // Spawn enemies in regions based on difficulty
        let spawnX, spawnY;
        if (type.minLevel <= 2) {
          // Easy enemies near town
          spawnX = 200 + Math.random() * 800;
          spawnY = 200 + Math.random() * 600;
        } else if (type.minLevel <= 5) {
          // Mid enemies in middle areas
          spawnX = Math.random() * rpgGame.world.width;
          spawnY = Math.random() * rpgGame.world.height;
        } else {
          // Hard enemies in far regions
          spawnX = 1400 + Math.random() * 800;
          spawnY = 1000 + Math.random() * 700;
        }
        
        rpgGame.enemies.push({
          ...type,
          hp: Math.floor(type.hp * levelMult),
          maxHp: Math.floor(type.hp * levelMult),
          atk: Math.floor(type.atk * levelMult),
          def: Math.floor(type.def * levelMult),
          gold: Math.floor(type.gold * levelMult),
          xp: Math.floor(type.xp * levelMult),
          x: spawnX,
          y: spawnY,
          width: 32,
          height: 32,
          vx: (Math.random() - 0.5) * type.speed,
          vy: (Math.random() - 0.5) * type.speed,
          alive: true,
          aggroRange: 180 + (type.minLevel * 10),
          chasing: false,
          level: Math.max(1, rpgGame.character.level + Math.floor(Math.random() * 3) - 1)
        });
      }
    }

    function spawnTreasure() {
      rpgGame.treasures.push({
        x: Math.random() * (rpgGame.world.width - 200) + 100,
        y: Math.random() * (rpgGame.world.height - 200) + 100,
        width: 30,
        height: 30,
        emoji: 'üíé',
        collected: false
      });
    }

    // Input handling
    document.addEventListener('keydown', (e) => {
      if (!rpgGame.gameActive) return;
      
      rpgGame.keys[e.key.toLowerCase()] = true;
      
      if (e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        handleSpacePress();
      }
      
      if (e.key.toLowerCase() === 'e') {
        openInventoryMenu();
      }
      
      if (e.key.toLowerCase() === 'm') {
        // Toggle map view
      }
    });

    document.addEventListener('keyup', (e) => {
      rpgGame.keys[e.key.toLowerCase()] = false;
    });

    // Canvas click for combat timing
    if (rpgCanvas) {
      rpgCanvas.addEventListener('click', () => {
        if (rpgGame.inCombat) {
          handleCombatClick();
        }
      });
    }

    function handleSpacePress() {
      if (rpgGame.inCombat) {
        handleCombatClick();
        return;
      }
      
      // Check for NPC interaction
      const player = rpgGame.character;
      rpgGame.npcs.forEach(npc => {
        const dx = npc.x - player.x;
        const dy = npc.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 60) {
          interactWithNPC(npc);
        }
      });
      
      // Check for treasure collection
      rpgGame.treasures.forEach(treasure => {
        if (treasure.collected) return;
        const dx = treasure.x - player.x;
        const dy = treasure.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 50) {
          collectTreasure(treasure);
        }
      });
      
      // Check for enemy combat
      rpgGame.enemies.forEach(enemy => {
        if (!enemy.alive) return;
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 60) {
          startCombat(enemy);
        }
      });
    }

    function interactWithNPC(npc) {
      if (npc.role === 'shop') {
        openShop();
      } else if (npc.role === 'craft') {
        openCrafting();
      } else if (npc.role === 'trade') {
        openTrading(npc);
      } else if (npc.role === 'heal') {
        healPlayer(npc);
      } else if (npc.role === 'rest') {
        restAtInn(npc);
      } else if (!npc.questGiven && npc.hasQuest) {
        rpgGame.quest = {
          active: true,
          type: npc.questType,
          target: npc.questTarget,
          progress: 0,
          reward: { gold: npc.questTarget * 20, xp: npc.questTarget * 15 },
          title: `${npc.name}'s Request`,
          description: npc.quest,
          giver: npc.name
        };
        
        npc.questGiven = true;
        addGameLog(`üí¨ ${npc.name}: "${npc.quest}"`, '#f59e0b');
        updateQuestUI();
      } else if (npc.questGiven) {
        addGameLog(`üí¨ ${npc.name}: ${npc.dialogue[Math.floor(Math.random() * npc.dialogue.length)]}`, '#10b981');
      }
    }
    
    function getNPCDialogue(role) {
      const dialogues = {
        shop: ['Welcome to my shop!', 'Looking to buy something?', 'I have the finest wares!'],
        craft: ['Need equipment crafted?', 'I can forge powerful items!', 'Bring me materials!'],
        trade: ['Want to trade items?', 'I\'ll exchange these for those!', 'Fair trades only!'],
        heal: ['Need healing?', 'Let me tend to your wounds.', 'Health is wealth!'],
        rest: ['Rest here for 50 gold.', 'A bed for the weary traveler.', 'Welcome to my inn!'],
        quest: ['Good luck on your quest!', 'May fortune favor you!', 'Come back when you\'re done!']
      };
      return dialogues[role] || ['Hello traveler!'];
    }
    
    function openShop() {
      const shopItems = [
        { name: 'Health Potion', emoji: 'üß™', cost: 35, type: 'potion', effect: 'health', value: 50 },
        { name: 'Mana Potion', emoji: 'üíô', cost: 30, type: 'potion', effect: 'mana', value: 40 },
        { name: 'Elixir', emoji: 'üç∂', cost: 80, type: 'potion', effect: 'both', value: 100 },
        { name: 'Iron Sword', emoji: '‚öîÔ∏è', cost: 120, type: 'weapon', stats: { attack: 15 } },
        { name: 'Steel Armor', emoji: 'üõ°Ô∏è', cost: 150, type: 'armor', stats: { defense: 12 } },
        { name: 'Magic Ring', emoji: 'üíç', cost: 100, type: 'ring', stats: { attack: 8, defense: 5 } },
        { name: 'Rare Loot Box', emoji: 'üì¶', cost: 200, type: 'lootbox', effect: 'random' }
      ];
      
      let shopText = 'üè™ MERCHANT SHOP (Gold: ' + rpgGame.character.gold + ')\n\n';
      shopItems.forEach((item, i) => {
        shopText += `${i + 1}. ${item.emoji} ${item.name} - ${item.cost}g\n`;
      });
      shopText += '\nEnter item number (1-' + shopItems.length + ') or 0 to cancel:';
      
      const choice = prompt(shopText);
      const index = parseInt(choice) - 1;
      
      if (index >= 0 && index < shopItems.length) {
        const item = shopItems[index];
        if (rpgGame.character.gold >= item.cost) {
          if (rpgGame.inventory.length >= rpgGame.maxInventory && item.type !== 'potion') {
            addGameLog('‚ö†Ô∏è Inventory full!', '#ef4444');
            return;
          }
          
          rpgGame.character.gold -= item.cost;
          
          if (item.type === 'potion') {
            if (item.effect === 'health') {
              rpgGame.character.health = Math.min(rpgGame.character.maxHealth, rpgGame.character.health + item.value);
              addGameLog(`${item.emoji} Used ${item.name}! +${item.value} HP`, '#10b981');
            } else if (item.effect === 'mana') {
              rpgGame.character.mana = Math.min(rpgGame.character.maxMana, rpgGame.character.mana + item.value);
              addGameLog(`${item.emoji} Used ${item.name}! +${item.value} MP`, '#3b82f6');
            } else if (item.effect === 'both') {
              rpgGame.character.health = rpgGame.character.maxHealth;
              rpgGame.character.mana = rpgGame.character.maxMana;
              addGameLog(`${item.emoji} Used ${item.name}! Full HP & MP!`, '#f59e0b');
            }
          } else if (item.type === 'lootbox') {
            addGameLog('üì¶ Opening loot box...', '#f59e0b');
            for (let i = 0; i < 3; i++) {
              generateRandomLoot('rare');
            }
          } else {
            // Add equipment to inventory
            const newItem = {
              name: item.name,
              emoji: item.emoji,
              type: item.type,
              slot: item.type,
              rarity: 'uncommon',
              statBonus: item.stats.attack || item.stats.defense || 10,
              statType: item.stats.attack ? 'attack' : 'defense',
              value: Math.floor(item.cost * 0.6)
            };
            rpgGame.inventory.push(newItem);
            addGameLog(`‚ú® Purchased: ${item.emoji} ${item.name}!`, '#10b981');
          }
          
          updateRPGUI();
        } else {
          addGameLog('‚ö†Ô∏è Not enough gold!', '#ef4444');
        }
      }
    }
    
    function openCrafting() {
      if (rpgGame.inventory.length < 3) {
        addGameLog('üî® Blacksmith: "Bring me at least 3 items to craft!"', '#9ca3af');
        return;
      }
      
      const recipes = [
        { name: 'Forge Epic Weapon', emoji: '‚öîÔ∏è', requires: 3, rarity: 'rare', result: 'epic', type: 'weapon', cost: 150 },
        { name: 'Forge Epic Armor', emoji: 'üõ°Ô∏è', requires: 3, rarity: 'rare', result: 'epic', type: 'armor', cost: 150 },
        { name: 'Forge Legendary', emoji: 'üëë', requires: 2, rarity: 'epic', result: 'legendary', type: 'random', cost: 300 }
      ];
      
      let craftText = 'üî® BLACKSMITH (Gold: ' + rpgGame.character.gold + ')\n\n';
      recipes.forEach((recipe, i) => {
        const count = rpgGame.inventory.filter(item => item.rarity === recipe.rarity).length;
        craftText += `${i + 1}. ${recipe.emoji} ${recipe.name}\n   Requires: ${recipe.requires}x ${recipe.rarity} items (You have: ${count}) + ${recipe.cost}g\n\n`;
      });
      craftText += 'Enter recipe number (1-' + recipes.length + ') or 0 to cancel:';
      
      const choice = prompt(craftText);
      const index = parseInt(choice) - 1;
      
      if (index >= 0 && index < recipes.length) {
        const recipe = recipes[index];
        const materials = rpgGame.inventory.filter(item => item.rarity === recipe.rarity);
        
        if (materials.length >= recipe.requires && rpgGame.character.gold >= recipe.cost) {
          // Remove materials
          for (let i = 0; i < recipe.requires; i++) {
            const idx = rpgGame.inventory.findIndex(item => item.rarity === recipe.rarity);
            rpgGame.inventory.splice(idx, 1);
          }
          rpgGame.character.gold -= recipe.cost;
          
          // Create crafted item
          const craftedType = recipe.type === 'random' ? 
            ['weapon', 'armor', 'helmet', 'boots', 'ring'][Math.floor(Math.random() * 5)] : recipe.type;
          
          generateRandomLoot(recipe.result, craftedType);
          addGameLog(`üî®‚ú® Crafted ${recipe.result} ${craftedType}!`, rpgGame.itemColors[recipe.result]);
          updateRPGUI();
        } else {
          addGameLog('‚ö†Ô∏è Not enough materials or gold!', '#ef4444');
        }
      }
    }
    
    function openTrading(npc) {
      const tradeOffers = [
        { give: 'common', giveCount: 5, get: 'uncommon', getText: '5 Common items ‚Üí 1 Uncommon' },
        { give: 'uncommon', giveCount: 3, get: 'rare', getText: '3 Uncommon items ‚Üí 1 Rare' },
        { give: 'rare', giveCount: 2, get: 'epic', getText: '2 Rare items ‚Üí 1 Epic' },
        { give: 'gold', giveCount: 250, get: 'rare', getText: '250 Gold ‚Üí 1 Rare item' }
      ];
      
      let tradeText = 'ü§ù TRADER (Items: ' + rpgGame.inventory.length + ', Gold: ' + rpgGame.character.gold + ')\n\n';
      tradeOffers.forEach((offer, i) => {
        if (offer.give === 'gold') {
          tradeText += `${i + 1}. ${offer.getText}\n`;
        } else {
          const count = rpgGame.inventory.filter(item => item.rarity === offer.give).length;
          tradeText += `${i + 1}. ${offer.getText} (You have: ${count})\n`;
        }
      });
      tradeText += '\nEnter trade number (1-' + tradeOffers.length + ') or 0 to cancel:';
      
      const choice = prompt(tradeText);
      const index = parseInt(choice) - 1;
      
      if (index >= 0 && index < tradeOffers.length) {
        const trade = tradeOffers[index];
        
        if (trade.give === 'gold') {
          if (rpgGame.character.gold >= trade.giveCount) {
            rpgGame.character.gold -= trade.giveCount;
            generateRandomLoot(trade.get);
            addGameLog(`ü§ù Trade complete! Received ${trade.get} item!`, '#10b981');
            updateRPGUI();
          } else {
            addGameLog('‚ö†Ô∏è Not enough gold!', '#ef4444');
          }
        } else {
          const materials = rpgGame.inventory.filter(item => item.rarity === trade.give);
          if (materials.length >= trade.giveCount) {
            for (let i = 0; i < trade.giveCount; i++) {
              const idx = rpgGame.inventory.findIndex(item => item.rarity === trade.give);
              rpgGame.inventory.splice(idx, 1);
            }
            generateRandomLoot(trade.get);
            addGameLog(`ü§ù Trade complete! Received ${trade.get} item!`, '#10b981');
            updateRPGUI();
          } else {
            addGameLog('‚ö†Ô∏è Not enough items to trade!', '#ef4444');
          }
        }
      }
    }
    
    function healPlayer(npc) {
      const healCost = 25;
      if (rpgGame.character.health >= rpgGame.character.maxHealth) {
        addGameLog('üßë‚Äç‚öïÔ∏è Healer: "You are already at full health!"', '#10b981');
        return;
      }
      
      if (rpgGame.character.gold >= healCost) {
        rpgGame.character.gold -= healCost;
        rpgGame.character.health = rpgGame.character.maxHealth;
        rpgGame.character.mana = rpgGame.character.maxMana;
        addGameLog(`üßë‚Äç‚öïÔ∏è Healed to full HP & MP! (-${healCost} gold)`, '#10b981');
        updateRPGUI();
      } else {
        addGameLog('‚ö†Ô∏è Not enough gold! Healing costs 25 gold.', '#ef4444');
      }
    }
    
    function restAtInn(npc) {
      const restCost = 50;
      if (rpgGame.character.gold >= restCost) {
        rpgGame.character.gold -= restCost;
        rpgGame.character.health = rpgGame.character.maxHealth;
        rpgGame.character.mana = rpgGame.character.maxMana;
        
        // Bonus: restore to town spawn
        rpgGame.character.x = 450;
        rpgGame.character.y = 300;
        
        addGameLog(`üè† Rested at inn. Full HP/MP restored! (-${restCost} gold)`, '#10b981');
        updateRPGUI();
      } else {
        addGameLog('‚ö†Ô∏è Not enough gold! Rest costs 50 gold.', '#ef4444');
      }
    }

    function collectTreasure(treasure) {
      treasure.collected = true;
      const goldAmount = 30 + Math.floor(Math.random() * 70);
      rpgGame.character.gold += goldAmount;
      rpgGame.stats.treasuresFound++;
      
      addGameLog(`üíé Found treasure! +${goldAmount} gold`, '#f59e0b');
      
      // Chance for item
      if (Math.random() < 0.6) {
        generateRandomLoot();
      }
      
      // Respawn treasure elsewhere
      setTimeout(() => spawnTreasure(), 10000);
      
      updateQuestProgress();
      updateRPGUI();
    }

    // Combat system with timing mechanics
    function startCombat(enemy) {
      if (rpgGame.inCombat) return;
      
      rpgGame.inCombat = true;
      rpgGame.currentEnemy = enemy;
      rpgGame.timingIndicator = 0;
      rpgGame.timingDirection = 1;
      
      document.getElementById('combatHUD').style.display = 'block';
      document.getElementById('enemyNameDisplay').textContent = `${enemy.emoji} ${enemy.name} (Lv.${rpgGame.character.level})`;
      
      addGameLog(`‚öîÔ∏è Battle started with ${enemy.name}!`, '#ef4444');
      updateCombatUI();
    }

    function handleCombatClick() {
      if (!rpgGame.inCombat || !rpgGame.currentEnemy) return;
      
      const enemy = rpgGame.currentEnemy;
      
      // Check timing for critical hit (green zone is 40-60%)
      const isCritical = rpgGame.timingIndicator >= 0.4 && rpgGame.timingIndicator <= 0.6;
      const critMultiplier = isCritical ? 2.5 : 1;
      
      // Player attacks
      const baseDmg = rpgGame.character.attack - enemy.def;
      const damage = Math.max(1, Math.floor((baseDmg + Math.random() * 10) * critMultiplier));
      enemy.hp -= damage;
      
      if (isCritical) {
        addGameLog(`‚ö° CRITICAL HIT! ${damage} damage!`, '#f59e0b');
      } else {
        addGameLog(`‚öîÔ∏è You hit for ${damage} damage`, '#10b981');
      }
      
      // Check if enemy defeated
      if (enemy.hp <= 0) {
        endCombat(true);
        return;
      }
      
      // Enemy counterattacks
      const enemyDmg = Math.max(1, enemy.atk - rpgGame.character.defense + Math.floor(Math.random() * 5));
      rpgGame.character.health -= enemyDmg;
      addGameLog(`üí• ${enemy.name} hits you for ${enemyDmg} damage!`, '#ef4444');
      
      // Check if player defeated
      if (rpgGame.character.health <= 0) {
        endCombat(false);
        return;
      }
      
      updateCombatUI();
      updateRPGUI();
    }

    function endCombat(playerWon) {
      const enemy = rpgGame.currentEnemy;
      
      if (playerWon) {
        enemy.alive = false;
        rpgGame.character.gold += enemy.gold;
        rpgGame.character.experience += enemy.xp;
        rpgGame.character.kills++;
        
        addGameLog(`üéâ Victory! +${enemy.gold} gold, +${enemy.xp} XP`, '#10b981');
        
        // Loot chance
        if (Math.random() < 0.5) {
          generateRandomLoot();
        }
        
        checkLevelUp();
        updateQuestProgress();
      } else {
        // Player defeated
        const goldLost = Math.floor(rpgGame.character.gold * 0.1);
        rpgGame.character.gold = Math.max(0, rpgGame.character.gold - goldLost);
        rpgGame.character.health = Math.floor(rpgGame.character.maxHealth * 0.5);
        
        // Respawn player to safe location
        rpgGame.character.x = 450;
        rpgGame.character.y = 300;
        
        addGameLog(`üíÄ Defeated! Lost ${goldLost} gold. Respawned at town.`, '#ef4444');
      }
      
      rpgGame.inCombat = false;
      rpgGame.currentEnemy = null;
      document.getElementById('combatHUD').style.display = 'none';
      
      // Respawn enemies if too few
      if (rpgGame.enemies.filter(e => e.alive).length < 10) {
        spawnEnemies();
      }
      
      updateRPGUI();
    }

    // Game loop
    function updateRPGWorld() {
      if (!rpgGame.gameActive || !rpgCtx) return;
      
      const now = Date.now();
      const dt = (now - rpgGame.lastUpdate) / 1000;
      rpgGame.lastUpdate = now;
      
      // Update playtime
      rpgGame.stats.playtime += dt;
      
      // Handle player movement
      if (!rpgGame.inCombat) {
        updatePlayerMovement();
      }
      
      // Update enemies
      updateEnemies();
      
      // Update combat timing indicator
      if (rpgGame.inCombat) {
        rpgGame.combatTimer += dt;
        rpgGame.timingIndicator += rpgGame.timingDirection * dt * 0.8;
        
        if (rpgGame.timingIndicator >= 1) {
          rpgGame.timingIndicator = 1;
          rpgGame.timingDirection = -1;
        } else if (rpgGame.timingIndicator <= 0) {
          rpgGame.timingIndicator = 0;
          rpgGame.timingDirection = 1;
        }
      }
      
      // Update camera
      updateCamera();
      
      // Render
      renderWorld();
      renderMiniMap();
      
      // Check NPC proximity
      checkNPCProximity();
      
      requestAnimationFrame(updateRPGWorld);
    }

    function updatePlayerMovement() {
      const player = rpgGame.character;
      let dx = 0, dy = 0;
      
      if (rpgGame.keys['w'] || rpgGame.keys['arrowup']) {
        dy -= player.speed;
        player.direction = 'up';
      }
      if (rpgGame.keys['s'] || rpgGame.keys['arrowdown']) {
        dy += player.speed;
        player.direction = 'down';
      }
      if (rpgGame.keys['a'] || rpgGame.keys['arrowleft']) {
        dx -= player.speed;
        player.direction = 'left';
      }
      if (rpgGame.keys['d'] || rpgGame.keys['arrowright']) {
        dx += player.speed;
        player.direction = 'right';
      }
      
      // Normalize diagonal movement
      if (dx !== 0 && dy !== 0) {
        dx *= 0.707;
        dy *= 0.707;
      }
      
      // Check collision with obstacles
      const newX = player.x + dx;
      const newY = player.y + dy;
      
      let canMove = true;
      
      // World boundaries
      if (newX < 20 || newX > rpgGame.world.width - 20 || 
          newY < 20 || newY > rpgGame.world.height - 20) {
        canMove = false;
      }
      
      // Obstacle collision
      rpgGame.obstacles.forEach(obs => {
        if (checkCollision(
          {x: newX, y: newY, width: player.width, height: player.height},
          obs
        )) {
          canMove = false;
        }
      });
      
      if (canMove) {
        player.x = newX;
        player.y = newY;
      }
      
      // Update location name
      updateLocationName();
    }

    function updateEnemies() {
      rpgGame.enemies.forEach(enemy => {
        if (!enemy.alive || enemy === rpgGame.currentEnemy) return;
        
        const player = rpgGame.character;
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Chase player if in range
        if (dist < enemy.aggroRange && !rpgGame.inCombat) {
          enemy.chasing = true;
          const angle = Math.atan2(dy, dx);
          enemy.vx = Math.cos(angle) * enemy.speed;
          enemy.vy = Math.sin(angle) * enemy.speed;
        } else {
          enemy.chasing = false;
          // Random wandering
          if (Math.random() < 0.02) {
            enemy.vx = (Math.random() - 0.5) * enemy.speed;
            enemy.vy = (Math.random() - 0.5) * enemy.speed;
          }
        }
        
        // Move enemy
        enemy.x += enemy.vx;
        enemy.y += enemy.vy;
        
        // Boundary check
        if (enemy.x < 50 || enemy.x > rpgGame.world.width - 50) enemy.vx *= -1;
        if (enemy.y < 50 || enemy.y > rpgGame.world.height - 50) enemy.vy *= -1;
        
        enemy.x = Math.max(50, Math.min(rpgGame.world.width - 50, enemy.x));
        enemy.y = Math.max(50, Math.min(rpgGame.world.height - 50, enemy.y));
      });
    }

    function updateCamera() {
      const player = rpgGame.character;
      
      // Center camera on player
      rpgGame.camera.x = player.x - rpgCanvas.width / 2;
      rpgGame.camera.y = player.y - rpgCanvas.height / 2;
      
      // Clamp camera to world bounds
      rpgGame.camera.x = Math.max(0, Math.min(rpgGame.world.width - rpgCanvas.width, rpgGame.camera.x));
      rpgGame.camera.y = Math.max(0, Math.min(rpgGame.world.height - rpgCanvas.height, rpgGame.camera.y));
    }

    function checkCollision(rect1, rect2) {
      return rect1.x < rect2.x + rect2.width &&
             rect1.x + rect1.width > rect2.x &&
             rect1.y < rect2.y + rect2.height &&
             rect1.y + rect1.height > rect2.y;
    }

    function checkNPCProximity() {
      const player = rpgGame.character;
      let nearNPC = false;
      
      rpgGame.npcs.forEach(npc => {
        const dx = npc.x - player.x;
        const dy = npc.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 70) {
          nearNPC = true;
        }
      });
      
      document.getElementById('npcInteraction').style.display = nearNPC ? 'block' : 'none';
    }

    function updateLocationName() {
      const player = rpgGame.character;
      let location = 'Wilderness';
      let bgColor = '#1a3a1a';
      
      // Define detailed regions with atmosphere
      if (player.x < 700 && player.y < 700) {
        location = 'üèòÔ∏è Town Square';
        bgColor = '#2a4a2a';
      } else if (player.x < 800 && player.y < 900) {
        location = 'üåæ Farmlands';
        bgColor = '#3a4a2a';
      } else if (player.x < 600) {
        location = 'üå∏ Peaceful Plains';
        bgColor = '#2a5a3a';
      } else if (player.x > 1800 && player.y > 1200) {
        location = 'üå≤ Dark Forest';
        bgColor = '#1a2a1a';
      } else if (player.x > 1700 && player.y < 600) {
        location = '‚õ∞Ô∏è Mountain Peak';
        bgColor = '#2a2a3a';
      } else if (player.x > 1400 && player.y < 800) {
        location = 'üèîÔ∏è Mountain Pass';
        bgColor = '#2a3a3a';
      } else if (player.y > 1400) {
        location = 'üêä Swamp Lands';
        bgColor = '#1a3a2a';
      } else if (player.y > 1000 && player.y < 1400) {
        location = 'üåø Deep Jungle';
        bgColor = '#1a4a1a';
      } else if (player.x > 1000 && player.x < 1400 && player.y > 800 && player.y < 1200) {
        location = 'üèõÔ∏è Ancient Ruins';
        bgColor = '#2a2a2a';
      } else if (player.x > 800 && player.x < 1200 && player.y > 600 && player.y < 1000) {
        location = 'üèïÔ∏è Adventurer\'s Camp';
        bgColor = '#2a3a2a';
      } else {
        location = 'üó∫Ô∏è Wilderness';
        bgColor = '#1a3a1a';
      }
      
      const locDisplay = document.getElementById('currentLocation');
      if (locDisplay && locDisplay.textContent !== location) {
        locDisplay.textContent = location;
        addGameLog(`üìç Entered: ${location}`, '#00d9ff');
        
        // Change world background based on region
        rpgGame.world.bgColor = bgColor;
      }
    }

    // Rendering
    function renderWorld() {
      if (!rpgCtx) return;
      
      const ctx = rpgCtx;
      const cam = rpgGame.camera;
      
      // Clear canvas with dynamic background
      ctx.fillStyle = rpgGame.world.bgColor || '#1a3a1a';
      ctx.fillRect(0, 0, rpgCanvas.width, rpgCanvas.height);
      
      // Draw grid
      ctx.strokeStyle = 'rgba(0,217,255,0.08)';
      ctx.lineWidth = 1;
      
      const startX = Math.floor(cam.x / 40) * 40;
      const startY = Math.floor(cam.y / 40) * 40;
      
      for (let x = startX; x < cam.x + rpgCanvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x - cam.x, 0);
        ctx.lineTo(x - cam.x, rpgCanvas.height);
        ctx.stroke();
      }
      
      for (let y = startY; y < cam.y + rpgCanvas.height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y - cam.y);
        ctx.lineTo(rpgCanvas.width, y - cam.y);
        ctx.stroke();
      }
      
      // Draw obstacles and landmarks
      rpgGame.obstacles.forEach(obs => {
        const screenX = obs.x - cam.x;
        const screenY = obs.y - cam.y;
        
        if (screenX > -100 && screenX < rpgCanvas.width + 100 &&
            screenY > -100 && screenY < rpgCanvas.height + 100) {
          // Shadow
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.fillRect(screenX + 5, screenY + 5, obs.width, obs.height);
          
          // Background
          if (obs.type === 'landmark') {
            ctx.fillStyle = 'rgba(255,215,0,0.2)';
            ctx.fillRect(screenX - 5, screenY - 5, obs.width + 10, obs.height + 10);
            ctx.fillStyle = 'rgba(0,217,255,0.5)';
          } else {
            ctx.fillStyle = obs.type === 'tree' ? 'rgba(34,139,34,0.7)' : 'rgba(105,105,105,0.7)';
          }
          ctx.fillRect(screenX, screenY, obs.width, obs.height);
          
          // Emoji
          ctx.font = `${obs.width * 0.8}px Arial`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          if (obs.type === 'landmark') {
            ctx.shadowColor = '#f59e0b';
            ctx.shadowBlur = 10;
          }
          ctx.fillText(obs.emoji, screenX + obs.width / 2, screenY + obs.height / 2);
          ctx.shadowBlur = 0;
        }
      });
      
      // Draw treasures
      rpgGame.treasures.forEach(treasure => {
        if (treasure.collected) return;
        const screenX = treasure.x - cam.x;
        const screenY = treasure.y - cam.y;
        
        if (screenX > -50 && screenX < rpgCanvas.width + 50) {
          // Pulsing glow effect
          const pulse = Math.sin(Date.now() / 300) * 5 + 15;
          ctx.font = '30px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          ctx.shadowColor = '#f59e0b';
          ctx.shadowBlur = pulse;
          ctx.fillText(treasure.emoji, screenX, screenY);
          ctx.shadowBlur = 0;
        }
      });
      
      // Draw NPCs
      rpgGame.npcs.forEach(npc => {
        const screenX = npc.x - cam.x;
        const screenY = npc.y - cam.y;
        
        if (screenX > -50 && screenX < rpgCanvas.width + 50) {
          // Quest indicator with bounce
          if (!npc.questGiven && npc.hasQuest) {
            const bounce = Math.sin(Date.now() / 200) * 3;
            ctx.fillStyle = '#f59e0b';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f59e0b';
            ctx.shadowBlur = 8;
            ctx.fillText('!', screenX, screenY - 30 - bounce);
            ctx.shadowBlur = 0;
          }
          
          // Shop/Service icon
          if (npc.role === 'shop' || npc.role === 'craft' || npc.role === 'trade') {
            ctx.fillStyle = '#10b981';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(npc.role === 'shop' ? 'üè™' : npc.role === 'craft' ? 'üî®' : 'ü§ù', screenX + 20, screenY - 20);
          }
          
          // NPC
          ctx.font = '35px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = '#00d9ff';
          ctx.shadowBlur = 10;
          ctx.fillText(npc.emoji, screenX, screenY);
          ctx.shadowBlur = 0;
          
          // Name
          ctx.font = 'bold 11px Arial';
          ctx.fillStyle = 'white';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 3;
          ctx.strokeText(npc.name, screenX, screenY + 28);
          ctx.fillText(npc.name, screenX, screenY + 28);
        }
      });
      
      // Draw enemies
      rpgGame.enemies.forEach(enemy => {
        if (!enemy.alive) return;
        const screenX = enemy.x - cam.x;
        const screenY = enemy.y - cam.y;
        
        if (screenX > -50 && screenX < rpgCanvas.width + 50) {
          // Enemy shadow
          ctx.fillStyle = 'rgba(0,0,0,0.3)';
          ctx.beginPath();
          ctx.ellipse(screenX, screenY + 15, 16, 7, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Enemy
          ctx.font = '32px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          if (enemy.chasing) {
            ctx.shadowColor = '#ef4444';
            ctx.shadowBlur = 15;
            // Aggro indicator
            ctx.fillStyle = 'rgba(239,68,68,0.3)';
            ctx.beginPath();
            ctx.arc(screenX, screenY, 25, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.fillText(enemy.emoji, screenX, screenY);
          ctx.shadowBlur = 0;
          
          // Enemy level badge
          ctx.font = 'bold 11px Arial';
          ctx.fillStyle = enemy.chasing ? '#ef4444' : '#9ca3af';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3;
          ctx.strokeText(`Lv${enemy.level}`, screenX + 18, screenY - 18);
          ctx.fillText(`Lv${enemy.level}`, screenX + 18, screenY - 18);
          
          // HP bar
          const barWidth = 40;
          const barHeight = 5;
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(screenX - barWidth/2, screenY - 28, barWidth, barHeight);
          
          const hpPercent = enemy.hp / enemy.maxHp;
          ctx.fillStyle = hpPercent > 0.5 ? '#10b981' : hpPercent > 0.25 ? '#f59e0b' : '#ef4444';
          ctx.fillRect(screenX - barWidth/2, screenY - 28, barWidth * hpPercent, barHeight);
          
          // HP text (on hover would be better, but show for chasing enemies)
          if (enemy.chasing) {
            ctx.font = '9px Arial';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeText(`${Math.floor(enemy.hp)}/${enemy.maxHp}`, screenX, screenY - 35);
            ctx.fillText(`${Math.floor(enemy.hp)}/${enemy.maxHp}`, screenX, screenY - 35);
          }
        }
      });
      
      // Draw player
      const player = rpgGame.character;
      const screenX = player.x - cam.x;
      const screenY = player.y - cam.y;
      
      // Player shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(screenX, screenY + 18, 18, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Player character
      ctx.font = '35px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = '#00d9ff';
      ctx.shadowBlur = 20;
      ctx.fillText(player.emoji, screenX, screenY);
      ctx.shadowBlur = 0;
      
      // Player level
      ctx.font = 'bold 14px Arial';
      ctx.fillStyle = '#f59e0b';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 3;
      ctx.strokeText(player.level, screenX + 15, screenY - 15);
      ctx.fillText(player.level, screenX + 15, screenY - 15);
      
      // Draw combat timing indicator
      if (rpgGame.inCombat) {
        drawCombatTimingBar();
      }
    }

    function drawCombatTimingBar() {
      const ctx = rpgCtx;
      const barWidth = 400;
      const barHeight = 30;
      const barX = (rpgCanvas.width - barWidth) / 2;
      const barY = rpgCanvas.height - 150;
      
      // Background
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(barX - 10, barY - 10, barWidth + 20, barHeight + 20);
      
      // Timing zones
      ctx.fillStyle = '#ef4444'; // Red zone
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      ctx.fillStyle = '#f59e0b'; // Yellow zone
      ctx.fillRect(barX + barWidth * 0.3, barY, barWidth * 0.2, barHeight);
      ctx.fillRect(barX + barWidth * 0.6, barY, barWidth * 0.2, barHeight);
      
      ctx.fillStyle = '#10b981'; // Green zone (critical)
      ctx.fillRect(barX + barWidth * 0.4, barY, barWidth * 0.2, barHeight);
      
      // Timing indicator
      const indicatorX = barX + barWidth * rpgGame.timingIndicator;
      ctx.fillStyle = 'white';
      ctx.fillRect(indicatorX - 3, barY - 5, 6, barHeight + 10);
      
      // Border
      ctx.strokeStyle = '#00d9ff';
      ctx.lineWidth = 2;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
    }

    function renderMiniMap() {
      if (!miniMapCtx) return;
      
      const ctx = miniMapCtx;
      const scale = 250 / rpgGame.world.width;
      
      // Background
      ctx.fillStyle = '#0f1f0f';
      ctx.fillRect(0, 0, 250, 250);
      
      // World boundaries
      ctx.strokeStyle = 'rgba(0,217,255,0.3)';
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, 248, 248);
      
      // Obstacles (small dots)
      ctx.fillStyle = 'rgba(105,105,105,0.4)';
      rpgGame.obstacles.forEach(obs => {
        ctx.fillRect(obs.x * scale, obs.y * scale, 3, 3);
      });
      
      // Treasures
      rpgGame.treasures.forEach(treasure => {
        if (!treasure.collected) {
          ctx.fillStyle = '#f59e0b';
          ctx.fillRect(treasure.x * scale - 2, treasure.y * scale - 2, 4, 4);
        }
      });
      
      // NPCs
      ctx.fillStyle = '#ffff00';
      rpgGame.npcs.forEach(npc => {
        ctx.beginPath();
        ctx.arc(npc.x * scale, npc.y * scale, 3, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Enemies
      ctx.fillStyle = '#ef4444';
      rpgGame.enemies.forEach(enemy => {
        if (enemy.alive) {
          ctx.beginPath();
          ctx.arc(enemy.x * scale, enemy.y * scale, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Player
      ctx.fillStyle = '#10b981';
      ctx.shadowColor = '#10b981';
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.arc(rpgGame.character.x * scale, rpgGame.character.y * scale, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Camera view rectangle
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 1;
      ctx.strokeRect(
        rpgGame.camera.x * scale,
        rpgGame.camera.y * scale,
        rpgCanvas.width * scale,
        rpgCanvas.height * scale
      );
    }

    function updateCombatUI() {
      const enemy = rpgGame.currentEnemy;
      if (!enemy) return;
      
      document.getElementById('enemyHPText').textContent = `${Math.max(0, enemy.hp)}/${enemy.maxHp}`;
      const hpPercent = (enemy.hp / enemy.maxHp) * 100;
      document.getElementById('enemyHealthBar').style.width = hpPercent + '%';
    }

    // Quest system
    function startNewQuest() {
      const questTypes = [
        { type: 'kills', target: 5, text: 'Defeat 5 enemies', reward: { gold: 100, xp: 75 } },
        { type: 'treasures', target: 3, text: 'Collect 3 treasures', reward: { gold: 150, xp: 50 } },
        { type: 'gold', target: 200, text: 'Accumulate 200 gold', reward: { gold: 100, xp: 100 } }
      ];
      
      const quest = questTypes[Math.floor(Math.random() * questTypes.length)];
      rpgGame.quest = {
        active: true,
        type: quest.type,
        target: quest.target,
        progress: 0,
        reward: quest.reward,
        title: 'Adventure Quest',
        description: quest.text
      };
      
      updateQuestUI();
    }

    function updateQuestProgress() {
      if (!rpgGame.quest.active) return;
      
      const progress = rpgGame.quest.type === 'kills' ? rpgGame.character.kills :
                      rpgGame.quest.type === 'treasures' ? rpgGame.stats.treasuresFound :
                      rpgGame.character.gold;
      
      rpgGame.quest.progress = progress;
      
      if (progress >= rpgGame.quest.target) {
        completeQuest();
      }
      
      updateQuestUI();
    }

    function completeQuest() {
      rpgGame.character.gold += rpgGame.quest.reward.gold;
      rpgGame.character.experience += rpgGame.quest.reward.xp;
      rpgGame.stats.questsCompleted++;
      
      addGameLog(`üéâ Quest Complete! +${rpgGame.quest.reward.gold} gold, +${rpgGame.quest.reward.xp} XP`, '#10b981');
      
      rpgGame.quest.active = false;
      
      checkLevelUp();
      updateRPGUI();
      
      setTimeout(() => startNewQuest(), 3000);
    }

    function updateQuestUI() {
      if (!rpgGame.quest.active) {
        document.getElementById('questTitle').textContent = 'No active quest';
        document.getElementById('questDescription').textContent = 'Complete current quest or find NPCs!';
        document.getElementById('questProgressBar').style.width = '0%';
        document.getElementById('questProgressText').textContent = '';
        document.getElementById('questReward').textContent = '';
        return;
      }
      
      document.getElementById('questTitle').textContent = rpgGame.quest.title;
      document.getElementById('questDescription').textContent = rpgGame.quest.description;
      
      const progress = rpgGame.quest.type === 'kills' ? rpgGame.character.kills :
                      rpgGame.quest.type === 'treasures' ? rpgGame.stats.treasuresFound :
                      rpgGame.character.gold;
      
      const percent = Math.min(100, (progress / rpgGame.quest.target) * 100);
      document.getElementById('questProgressBar').style.width = percent + '%';
      document.getElementById('questProgressText').textContent = `${progress}/${rpgGame.quest.target}`;
      document.getElementById('questReward').textContent = `üí∞ Reward: ${rpgGame.quest.reward.gold}g, ${rpgGame.quest.reward.xp} XP`;
    }

    // Inventory system (continued in next part due to length...)
    function generateRandomLoot(forcedRarity = null, forcedType = null) {
      if (rpgGame.inventory.length >= rpgGame.maxInventory) {
        addGameLog('‚ö†Ô∏è Inventory full!', '#ef4444');
        return;
      }

      const itemTypes = [
        { type: 'weapon', emoji: '‚öîÔ∏è', slot: 'weapon', statType: 'attack', names: ['Sword', 'Axe', 'Dagger', 'Mace', 'Staff', 'Spear', 'Bow', 'Hammer', 'Scythe'] },
        { type: 'helmet', emoji: '‚õëÔ∏è', slot: 'helmet', statType: 'defense', names: ['Helm', 'Hood', 'Crown', 'Cap', 'Mask', 'Circlet'] },
        { type: 'armor', emoji: 'üõ°Ô∏è', slot: 'armor', statType: 'defense', names: ['Plate', 'Mail', 'Robe', 'Vest', 'Tunic', 'Chainmail'] },
        { type: 'boots', emoji: 'üë¢', slot: 'boots', statType: 'defense', names: ['Boots', 'Shoes', 'Greaves', 'Sandals', 'Treads'] },
        { type: 'ring', emoji: 'üíç', slot: 'ring', statType: 'attack', names: ['Ring', 'Band', 'Signet', 'Amulet', 'Pendant'] }
      ];

      let itemTemplate;
      if (forcedType) {
        itemTemplate = itemTypes.find(t => t.type === forcedType) || itemTypes[0];
      } else {
        itemTemplate = itemTypes[Math.floor(Math.random() * itemTypes.length)];
      }
      
      let rarity;
      if (forcedRarity) {
        rarity = forcedRarity;
      } else {
        // Weighted rarity based on player level
        const rarityChances = [
          { rarity: 'common', chance: Math.max(10, 50 - rpgGame.character.level * 2) },
          { rarity: 'uncommon', chance: 30 },
          { rarity: 'rare', chance: Math.min(25, 15 + rpgGame.character.level) },
          { rarity: 'epic', chance: Math.min(15, rpgGame.character.level >= 5 ? 8 : 2) },
          { rarity: 'legendary', chance: Math.min(10, rpgGame.character.level >= 10 ? 5 : 0) }
        ];
        
        const totalChance = rarityChances.reduce((sum, r) => sum + r.chance, 0);
        let roll = Math.random() * totalChance;
        
        for (const r of rarityChances) {
          roll -= r.chance;
          if (roll <= 0) {
            rarity = r.rarity;
            break;
          }
        }
        
        if (!rarity) rarity = 'common';
      }
      
      const rarityMultiplier = { common: 1, uncommon: 1.5, rare: 2.5, epic: 4, legendary: 7 }[rarity];
      const rarityPrefixes = {
        common: ['Rusty', 'Old', 'Worn', 'Simple'],
        uncommon: ['Fine', 'Quality', 'Sturdy', 'Good'],
        rare: ['Enchanted', 'Mystic', 'Superior', 'Blessed'],
        epic: ['Legendary', 'Heroic', 'Divine', 'Ancient'],
        legendary: ['Godly', 'Mythical', 'Eternal', 'Supreme']
      };
      
      const prefix = rarityPrefixes[rarity][Math.floor(Math.random() * rarityPrefixes[rarity].length)];
      const name = itemTemplate.names[Math.floor(Math.random() * itemTemplate.names.length)];

      const item = {
        name: `${prefix} ${name}`,
        type: itemTemplate.type,
        emoji: itemTemplate.emoji,
        rarity: rarity,
        slot: itemTemplate.slot,
        statBonus: Math.floor((8 + Math.random() * 25 + rpgGame.character.level * 2) * rarityMultiplier),
        statType: itemTemplate.statType,
        value: Math.floor((20 + Math.random() * 60) * rarityMultiplier)
      };

      rpgGame.inventory.push(item);
      addGameLog(`‚ú® Found: ${item.emoji} ${item.name} (+${item.statBonus} ${item.statType})!`, rpgGame.itemColors[rarity]);
      updateRPGUI();
    }

    function checkLevelUp() {
      const xpNeeded = rpgGame.character.level * 100;
      if (rpgGame.character.experience >= xpNeeded) {
        const oldLevel = rpgGame.character.level;
        rpgGame.character.level++;
        rpgGame.character.experience -= xpNeeded;
        rpgGame.character.maxHealth += 25;
        rpgGame.character.maxMana += 10;
        rpgGame.character.health = rpgGame.character.maxHealth;
        rpgGame.character.mana = rpgGame.character.maxMana;
        rpgGame.character.attack += 4;
        rpgGame.character.defense += 3;
        
        addGameLog(`üéâ LEVEL UP! Now Level ${rpgGame.character.level}! (+25 HP, +10 MP, +4 ATK, +3 DEF)`, '#f59e0b');
        
        // Special rewards at milestone levels
        if (rpgGame.character.level === 5) {
          addGameLog('üéÅ Level 5 Bonus: Received 200 gold and a rare item!', '#a855f7');
          rpgGame.character.gold += 200;
          generateRandomLoot('rare');
        } else if (rpgGame.character.level === 10) {
          addGameLog('üéÅ Level 10 Bonus: Received 500 gold and an epic item!', '#a855f7');
          rpgGame.character.gold += 500;
          generateRandomLoot('epic');
          rpgGame.character.speed += 0.5; // Speed boost
          addGameLog('‚ö° Movement speed increased!', '#10b981');
        } else if (rpgGame.character.level === 15) {
          addGameLog('üéÅ Level 15 Bonus: Received 1000 gold and a legendary item!', '#f59e0b');
          rpgGame.character.gold += 1000;
          generateRandomLoot('legendary');
        }
        
        // Respawn stronger enemies based on new level
        const deadEnemies = rpgGame.enemies.filter(e => !e.alive).length;
        if (deadEnemies > 5 || rpgGame.character.level % 3 === 0) {
          rpgGame.enemies = rpgGame.enemies.filter(e => e.alive);
          spawnEnemies();
          addGameLog('üîÑ Stronger enemies have appeared!', '#ef4444');
        }
        
        updateRPGUI();
      }
    }

    function addGameLog(message, color = '#ffffff') {
      const log = document.getElementById('gameLog');
      if (!log) return;
      
      const entry = document.createElement('div');
      entry.style.color = color;
      entry.style.marginBottom = '4px';
      const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
      entry.textContent = `[${time}] ${message}`;
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
      
      while (log.children.length > 30) {
        log.removeChild(log.firstChild);
      }
    }

    // UI Functions
    function initRPGUI() {
      // Equipment slots
      const equipSlots = document.getElementById('equipmentSlots');
      if (equipSlots) {
        const slots = [
          { slot: 'weapon', emoji: '‚öîÔ∏è', name: 'Weapon' },
          { slot: 'helmet', emoji: '‚õëÔ∏è', name: 'Helmet' },
          { slot: 'armor', emoji: 'üõ°Ô∏è', name: 'Armor' },
          { slot: 'boots', emoji: 'üë¢', name: 'Boots' },
          { slot: 'ring', emoji: 'üíç', name: 'Ring' }
        ];
        
        equipSlots.innerHTML = slots.map(s => `
          <div data-equip="${s.slot}" onclick="unequipItem('${s.slot}')" style="padding: 10px; background: rgba(0,217,255,0.08); border-radius: 6px; text-align: center; cursor: pointer; border: 2px solid rgba(0,217,255,0.2); transition: all 0.3s;">
            <div style="font-size: 1.5rem;">${s.emoji}</div>
            <div style="color: var(--text-secondary); font-size: 0.7rem; margin-top: 3px;">${s.name}</div>
          </div>
        `).join('');
      }
      
      updateRPGUI();
    }

    function updateRPGUI() {
      const char = rpgGame.character;
      
      if (document.getElementById('heroName')) document.getElementById('heroName').textContent = char.name;
      if (document.getElementById('heroClass')) document.getElementById('heroClass').textContent = char.class;
      if (document.getElementById('heroEmoji')) document.getElementById('heroEmoji').textContent = char.emoji;
      if (document.getElementById('heroLevelBadge')) document.getElementById('heroLevelBadge').textContent = char.level;
      if (document.getElementById('heroXP')) document.getElementById('heroXP').textContent = char.experience;
      if (document.getElementById('heroXPNext')) document.getElementById('heroXPNext').textContent = char.level * 100;
      
      const xpPercent = (char.experience / (char.level * 100)) * 100;
      if (document.getElementById('xpBar')) document.getElementById('xpBar').style.width = xpPercent + '%';
      
      if (document.getElementById('heroHealth')) document.getElementById('heroHealth').textContent = `${Math.floor(char.health)}/${char.maxHealth}`;
      if (document.getElementById('heroMana')) document.getElementById('heroMana').textContent = `${char.mana}/${char.maxMana}`;
      if (document.getElementById('heroAttack')) document.getElementById('heroAttack').textContent = char.attack;
      if (document.getElementById('heroDefense')) document.getElementById('heroDefense').textContent = char.defense;
      if (document.getElementById('heroGold')) document.getElementById('heroGold').textContent = char.gold;
      if (document.getElementById('killCount')) document.getElementById('killCount').textContent = char.kills;
      
      // Update equipment slots
      ['weapon', 'helmet', 'armor', 'boots', 'ring'].forEach(slot => {
        const slotElement = document.querySelector(`[data-equip="${slot}"]`);
        if (slotElement) {
          const item = rpgGame.equipment[slot];
          if (item) {
            slotElement.innerHTML = `
              <div style="font-size: 1.8rem;">${item.emoji}</div>
              <div style="color: ${rpgGame.itemColors[item.rarity]}; font-size: 0.7rem; font-weight: bold; margin-top: 2px;">+${item.statBonus}</div>
            `;
            slotElement.style.background = rpgGame.itemColors[item.rarity] + '15';
            slotElement.style.borderColor = rpgGame.itemColors[item.rarity];
          } else {
            const icons = { weapon: '‚öîÔ∏è', helmet: '‚õëÔ∏è', armor: 'üõ°Ô∏è', boots: 'üë¢', ring: 'üíç' };
            slotElement.innerHTML = `
              <div style="font-size: 1.8rem; opacity: 0.3;">${icons[slot]}</div>
            `;
            slotElement.style.background = 'rgba(255,255,255,0.05)';
            slotElement.style.borderColor = 'rgba(0,217,255,0.3)';
          }
        }
      });
      
      // Stats
      if (document.getElementById('dungeonsClearedStat')) document.getElementById('dungeonsClearedStat').textContent = rpgGame.stats.dungeonsCleared;
      if (document.getElementById('treasuresFoundStat')) document.getElementById('treasuresFoundStat').textContent = rpgGame.stats.treasuresFound;
      if (document.getElementById('questsCompletedStat')) document.getElementById('questsCompletedStat').textContent = rpgGame.stats.questsCompleted;
      if (document.getElementById('playtimeStat')) {
        const minutes = Math.floor(rpgGame.stats.playtime / 60);
        document.getElementById('playtimeStat').textContent = `${minutes}m`;
      }
    }

    function openInventoryMenu() {
      document.getElementById('inventoryModal').style.display = 'block';
      renderInventoryModal();
    }

    function closeInventoryMenu() {
      document.getElementById('inventoryModal').style.display = 'none';
    }

    function renderInventoryModal() {
      const grid = document.getElementById('inventoryModalGrid');
      if (!grid) return;
      
      grid.innerHTML = '';
      for (let i = 0; i < rpgGame.maxInventory; i++) {
        const slot = document.createElement('div');
        const item = rpgGame.inventory[i];
        
        slot.style.cssText = 'width: 60px; height: 60px; background: rgba(255,255,255,0.05); border: 2px solid rgba(0,217,255,0.3); border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; font-size: 1.8rem; transition: all 0.3s; position: relative;';
        
        if (item) {
          slot.textContent = item.emoji;
          slot.style.background = rpgGame.itemColors[item.rarity] + '20';
          slot.style.borderColor = rpgGame.itemColors[item.rarity];
          
          // Tooltip
          slot.title = `${item.name}\n+${item.statBonus} ${item.statType}\nValue: ${item.value} gold\nClick to equip | Right-click to drop`;
          
          // Click to equip
          slot.onclick = () => useItem(i);
          
          // Right-click to drop
          slot.oncontextmenu = (e) => {
            e.preventDefault();
            if (confirm(`Drop ${item.name}?`)) {
              rpgGame.inventory.splice(i, 1);
              addGameLog(`üóëÔ∏è Dropped: ${item.name}`, '#9ca3af');
              renderInventoryModal();
              updateRPGUI();
            }
          };
          
          // Hover effect
          slot.onmouseenter = () => {
            slot.style.transform = 'scale(1.1)';
            slot.style.zIndex = '10';
          };
          slot.onmouseleave = () => {
            slot.style.transform = 'scale(1)';
            slot.style.zIndex = '1';
          };
        }
        
        grid.appendChild(slot);
      }
      
      document.getElementById('invModalCount').textContent = rpgGame.inventory.length;
    }

    function useItem(index) {
      const item = rpgGame.inventory[index];
      if (!item) return;

      if (item.slot === 'consumable') {
        if (item.statType === 'health') {
          rpgGame.character.health = Math.min(rpgGame.character.maxHealth, rpgGame.character.health + item.statBonus);
          addGameLog(`${item.emoji} Used ${item.name}! +${item.statBonus} HP`, '#10b981');
        }
        rpgGame.inventory.splice(index, 1);
      } else {
        const oldItem = rpgGame.equipment[item.slot];
        if (oldItem) {
          rpgGame.inventory.push(oldItem);
        }
        rpgGame.equipment[item.slot] = item;
        rpgGame.inventory.splice(index, 1);
        addGameLog(`‚ö° Equipped: ${item.name}`, rpgGame.itemColors[item.rarity]);
        
        // Recalculate stats
        rpgGame.character.attack = 12 + (rpgGame.character.level - 1) * 4;
        rpgGame.character.defense = 6 + (rpgGame.character.level - 1) * 3;
        
        Object.values(rpgGame.equipment).forEach(eq => {
          if (eq) {
            if (eq.statType === 'attack') rpgGame.character.attack += eq.statBonus;
            if (eq.statType === 'defense') rpgGame.character.defense += eq.statBonus;
          }
        });
      }

      updateRPGUI();
      renderInventoryModal();
    }
    
    function unequipItem(slot) {
      const item = rpgGame.equipment[slot];
      if (!item) return;
      
      if (rpgGame.inventory.length >= rpgGame.maxInventory) {
        addGameLog('‚ö†Ô∏è Inventory full!', '#ef4444');
        return;
      }
      
      rpgGame.inventory.push(item);
      rpgGame.equipment[slot] = null;
      addGameLog(`üì¶ Unequipped: ${item.name}`, '#9ca3af');
      
      // Recalculate stats
      rpgGame.character.attack = 12 + (rpgGame.character.level - 1) * 4;
      rpgGame.character.defense = 6 + (rpgGame.character.level - 1) * 3;
      
      Object.values(rpgGame.equipment).forEach(eq => {
        if (eq) {
          if (eq.statType === 'attack') rpgGame.character.attack += eq.statBonus;
          if (eq.statType === 'defense') rpgGame.character.defense += eq.statBonus;
        }
      });
      
      updateRPGUI();
    }

    function sellAllJunk() {
      let goldEarned = 0;
      let itemsSold = 0;
      rpgGame.inventory = rpgGame.inventory.filter(item => {
        if (item.rarity === 'common') {
          goldEarned += item.value;
          itemsSold++;
          return false;
        }
        return true;
      });
      rpgGame.character.gold += goldEarned;
      
      if (goldEarned > 0) {
        addGameLog(`üí∞ Sold ${itemsSold} items for ${goldEarned} gold!`, '#f59e0b');
      } else {
        addGameLog('No common items to sell.', '#9ca3af');
      }
      
      updateRPGUI();
      renderInventoryModal();
    }

    // Initialize game
    if (rpgCanvas) {
      initRPGWorld();
    }
  </script>

  <!-- TOWER DEFENSE STRATEGY -->
  <script>
    const towerCanvas = document.getElementById('towerCanvas');
    const towerCtx = towerCanvas ? towerCanvas.getContext('2d') : null;

    let towerGame = {
      towers: [],
      enemies: [],
      projectiles: [],
      path: [],
      lives: 20,
      gold: 100,
      wave: 1,
      score: 0,
      selectedTower: null,
      selectedType: null,
      gameActive: false,
      gameLoop: null,
      waveActive: false,
      towerTypes: {
        basic: { cost: 50, damage: 10, range: 100, fireRate: 1000, color: '#f59e0b', emoji: 'üèπ' },
        cannon: { cost: 100, damage: 30, range: 80, fireRate: 2000, color: '#ef4444', emoji: 'üí£', splash: 40 },
        magic: { cost: 150, damage: 20, range: 120, fireRate: 800, color: '#a855f7', emoji: '‚ú®', slow: 0.5 }
      }
    };

    function initTowerDefense() {
      if (!towerCanvas) return;

      // Reset canvas dimensions
      towerCanvas.width = 1000;
      towerCanvas.height = 600;

      // Create path scaled to new canvas size (S-shaped)
      towerGame.path = [
        {x: 0, y: 125},
        {x: 250, y: 125},
        {x: 250, y: 375},
        {x: 625, y: 375},
        {x: 625, y: 187},
        {x: 875, y: 187},
        {x: 875, y: 500},
        {x: 1000, y: 500}
      ];

      renderTowerField();
      updateTowerUI();
    }

    function renderTowerField() {
      if (!towerCtx) return;

      // Background
      const gradient = towerCtx.createLinearGradient(0, 0, 0, towerCanvas.height);
      gradient.addColorStop(0, '#1a4d2e');
      gradient.addColorStop(1, '#0a2f1e');
      towerCtx.fillStyle = gradient;
      towerCtx.fillRect(0, 0, towerCanvas.width, towerCanvas.height);

      // Draw path
      towerCtx.strokeStyle = '#8b4513';
      towerCtx.lineWidth = 40;
      towerCtx.lineCap = 'round';
      towerCtx.lineJoin = 'round';
      towerCtx.beginPath();
      towerGame.path.forEach((point, i) => {
        if (i === 0) towerCtx.moveTo(point.x, point.y);
        else towerCtx.lineTo(point.x, point.y);
      });
      towerCtx.stroke();

      // Draw towers
      towerGame.towers.forEach(tower => {
        const type = towerGame.towerTypes[tower.type];
        
        // Range circle
        towerCtx.strokeStyle = 'rgba(0,217,255,0.2)';
        towerCtx.lineWidth = 2;
        towerCtx.beginPath();
        towerCtx.arc(tower.x, tower.y, type.range, 0, Math.PI * 2);
        towerCtx.stroke();

        // Tower base
        towerCtx.fillStyle = type.color;
        towerCtx.beginPath();
        towerCtx.arc(tower.x, tower.y, 20, 0, Math.PI * 2);
        towerCtx.fill();

        // Tower emoji
        towerCtx.font = '20px Arial';
        towerCtx.textAlign = 'center';
        towerCtx.textBaseline = 'middle';
        towerCtx.fillText(type.emoji, tower.x, tower.y);

        // Level indicator
        if (tower.level > 1) {
          towerCtx.fillStyle = '#ffd700';
          towerCtx.font = 'bold 12px Arial';
          towerCtx.fillText('‚òÖ'.repeat(tower.level - 1), tower.x, tower.y - 30);
        }
      });

      // Draw enemies
      towerGame.enemies.forEach(enemy => {
        towerCtx.fillStyle = enemy.type === 'fast' ? '#ff6b00' : enemy.type === 'tank' ? '#ff0000' : '#00ff00';
        towerCtx.beginPath();
        towerCtx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
        towerCtx.fill();

        // Health bar
        if (enemy.health < enemy.maxHealth) {
          towerCtx.fillStyle = '#ef4444';
          towerCtx.fillRect(enemy.x - 15, enemy.y - 20, 30 * (enemy.health / enemy.maxHealth), 4);
          towerCtx.strokeStyle = 'white';
          towerCtx.strokeRect(enemy.x - 15, enemy.y - 20, 30, 4);
        }
      });

      // Draw projectiles
      towerGame.projectiles.forEach(proj => {
        towerCtx.fillStyle = proj.color || '#ffff00';
        towerCtx.beginPath();
        towerCtx.arc(proj.x, proj.y, proj.size || 5, 0, Math.PI * 2);
        towerCtx.fill();
      });
    }

    function selectTowerType(type) {
      towerGame.selectedType = type;
      alert(`Selected ${type} tower! Click on the field to place it. Cost: ${towerGame.towerTypes[type].cost} gold`);
    }

    function startTowerWave() {
      if (towerGame.waveActive) return;
      towerGame.waveActive = true;
      towerGame.gameActive = true;

      const enemyCount = 5 + towerGame.wave * 3;
      const spawnInterval = setInterval(() => {
        if (towerGame.enemies.filter(e => !e.spawned).length >= enemyCount) {
          clearInterval(spawnInterval);
          return;
        }

        const type = Math.random() < 0.3 ? 'fast' : Math.random() < 0.6 ? 'normal' : 'tank';
        const enemy = {
          x: towerGame.path[0].x,
          y: towerGame.path[0].y,
          pathIndex: 0,
          progress: 0,
          type: type,
          size: type === 'tank' ? 12 : 8,
          speed: type === 'fast' ? 2 : type === 'tank' ? 0.8 : 1.5,
          health: type === 'tank' ? 100 : type === 'fast' ? 20 : 50,
          maxHealth: type === 'tank' ? 100 : type === 'fast' ? 20 : 50,
          reward: type === 'tank' ? 15 : type === 'fast' ? 5 : 10,
          spawned: true,
          slowEffect: 1
        };
        towerGame.enemies.push(enemy);
      }, 800);

      if (towerGame.gameLoop) cancelAnimationFrame(towerGame.gameLoop);
      towerDefenseLoop();
    }

    function towerDefenseLoop() {
      if (!towerCtx || !towerGame.gameActive) return;

      try {
        renderTowerField();

        // Move enemies along path
        towerGame.enemies = towerGame.enemies.filter(enemy => {
          if (!enemy || enemy.pathIndex >= towerGame.path.length - 1) {
            if (enemy) {
              towerGame.lives--;
              updateTowerUI();
              if (towerGame.lives <= 0) {
                endTowerDefense();
              }
            }
            return false;
          }

          const target = towerGame.path[enemy.pathIndex + 1];
          if (!target) return false;
          
          const dx = target.x - enemy.x;
          const dy = target.y - enemy.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 5) {
            enemy.pathIndex++;
          } else {
            const moveSpeed = enemy.speed * enemy.slowEffect;
            enemy.x += (dx / dist) * moveSpeed;
            enemy.y += (dy / dist) * moveSpeed;
          }

          enemy.slowEffect = Math.min(1, enemy.slowEffect + 0.02); // Recover from slow

          return enemy.health > 0;
        });

        // Tower shooting
        towerGame.towers.forEach(tower => {
          if (!tower) return;
          
          const now = Date.now();
          const towerType = towerGame.towerTypes[tower.type];
          if (!towerType) return;
          
          if (now - (tower.lastShot || 0) < towerType.fireRate / tower.level) return;

          // Find nearest enemy in range
          let target = null;
          let minDist = Infinity;

          towerGame.enemies.forEach(enemy => {
            if (!enemy) return;
            const dx = enemy.x - tower.x;
            const dy = enemy.y - tower.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < towerType.range && dist < minDist) {
              minDist = dist;
              target = enemy;
            }
          });

          if (target) {
            tower.lastShot = now;
            towerGame.projectiles.push({
              x: tower.x,
              y: tower.y,
              targetX: target.x,
              targetY: target.y,
              target: target,
              damage: towerType.damage * tower.level,
              speed: 5,
              color: towerType.color,
              splash: towerType.splash,
              slow: towerType.slow,
              towerType: tower.type
            });
          }
        });

        // Move projectiles
        towerGame.projectiles = towerGame.projectiles.filter(proj => {
          if (!proj || !proj.target) return false;
          
          const dx = proj.targetX - proj.x;
          const dy = proj.targetY - proj.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 10 || isNaN(dist)) {
            // Hit!
            if (proj.splash) {
              // Area damage
              towerGame.enemies.forEach(enemy => {
                if (!enemy) return;
                const edx = enemy.x - proj.targetX;
                const edy = enemy.y - proj.targetY;
                const eDist = Math.sqrt(edx * edx + edy * edy);
                if (eDist < proj.splash) {
                  enemy.health -= proj.damage * 0.5;
                  if (enemy.health <= 0) {
                    towerGame.gold += enemy.reward;
                    towerGame.score += enemy.reward * 10;
                  }
                }
              });
            } else if (proj.target) {
              proj.target.health -= proj.damage;
              if (proj.slow) {
                proj.target.slowEffect = proj.slow;
              }
              if (proj.target.health <= 0) {
                towerGame.gold += proj.target.reward;
                towerGame.score += proj.target.reward * 10;
              }
            }
            updateTowerUI();
            return false;
          }

          proj.x += (dx / dist) * proj.speed;
          proj.y += (dy / dist) * proj.speed;
          return true;
        });

        // Check wave complete
        if (towerGame.enemies.length === 0 && towerGame.waveActive) {
          towerGame.waveActive = false;
          towerGame.wave++;
          towerGame.gold += 50;
          updateTowerUI();
          alert(`Wave ${towerGame.wave - 1} complete! +50 gold`);
        }
      } catch (error) {
        console.error('Tower Defense error:', error);
      }

      towerGame.gameLoop = requestAnimationFrame(towerDefenseLoop);
    }

    function upgradeTower() {
      if (towerGame.selectedTower) {
        const upgradeCost = 50 * towerGame.selectedTower.level;
        if (towerGame.gold >= upgradeCost) {
          towerGame.gold -= upgradeCost;
          towerGame.selectedTower.level++;
          updateTowerUI();
          alert(`Tower upgraded to level ${towerGame.selectedTower.level}!`);
        } else {
          alert('Not enough gold!');
        }
      } else {
        alert('Select a tower first by clicking on it!');
      }
    }

    function sellTower() {
      if (towerGame.selectedTower) {
        const refund = Math.floor(towerGame.towerTypes[towerGame.selectedTower.type].cost * 0.7);
        towerGame.gold += refund;
        towerGame.towers = towerGame.towers.filter(t => t !== towerGame.selectedTower);
        towerGame.selectedTower = null;
        updateTowerUI();
        renderTowerField();
        alert(`Tower sold for ${refund} gold!`);
      } else {
        alert('Select a tower first!');
      }
    }

    function updateTowerUI() {
      if (document.getElementById('towerLives')) document.getElementById('towerLives').textContent = towerGame.lives;
      if (document.getElementById('towerGold')) document.getElementById('towerGold').textContent = towerGame.gold;
      if (document.getElementById('towerWave')) document.getElementById('towerWave').textContent = towerGame.wave;
      if (document.getElementById('towerScore')) document.getElementById('towerScore').textContent = towerGame.score;
    }

    function endTowerDefense() {
      towerGame.gameActive = false;
      alert(`Game Over! Final Score: ${towerGame.score}\nWaves Survived: ${towerGame.wave - 1}`);
    }

    if (towerCanvas) {
      towerCanvas.addEventListener('click', (e) => {
        const rect = towerCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (towerGame.selectedType) {
          const towerType = towerGame.towerTypes[towerGame.selectedType];
          if (towerGame.gold >= towerType.cost) {
            // Check if not on path
            let onPath = false;
            towerGame.path.forEach(point => {
              if (Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2) < 30) onPath = true;
            });

            if (!onPath) {
              towerGame.gold -= towerType.cost;
              towerGame.towers.push({
                x: x,
                y: y,
                type: towerGame.selectedType,
                level: 1,
                lastShot: 0
              });
              towerGame.selectedType = null;
              updateTowerUI();
              renderTowerField();
            } else {
              alert('Cannot place tower on the path!');
            }
          } else {
            alert('Not enough gold!');
          }
        } else {
          // Select tower
          towerGame.selectedTower = towerGame.towers.find(tower => 
            Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2) < 20
          );
        }
      });

      initTowerDefense();
    }
  </script>

  <!-- AI Chatbot -->
  <script src="../js/ai-chatbot.js"></script>
  <script>
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', function() {
        const chatbot = new PortfolioChatbot();
        chatbot.init();
      });
    } else {
      const chatbot = new PortfolioChatbot();
      chatbot.init();
    }
  </script>

  <!-- AI DEMOS IMPLEMENTATIONS -->
  <script>
    // ========================================
    // 1. A* PATHFINDING ALGORITHM
    // ========================================
    const astarCanvas = document.getElementById('astarCanvas');
    const astarCtx = astarCanvas ? astarCanvas.getContext('2d') : null;

    let astarState = {
      grid: [],
      gridSize: 25,
      cellSize: 28,
      start: { x: 2, y: 2 },
      end: { x: 22, y: 18 },
      mode: 'wall',
      path: [],
      explored: [],
      isDrawing: false
    };

    function initAstar() {
      if (!astarCanvas) return;
      astarState.gridSize = 25;
      astarState.cellSize = astarCanvas.width / astarState.gridSize;
      
      // Initialize grid
      astarState.grid = [];
      for (let y = 0; y < astarState.gridSize; y++) {
        astarState.grid[y] = [];
        for (let x = 0; x < astarState.gridSize; x++) {
          astarState.grid[y][x] = { wall: false, explored: false, path: false };
        }
      }
      
      // Add some initial obstacles
      for (let i = 5; i < 20; i++) {
        astarState.grid[10][i].wall = true;
        astarState.grid[15][i].wall = true;
      }
      
      drawAstar();
    }

    function drawAstar() {
      if (!astarCtx) return;
      const cs = astarState.cellSize;
      
      astarCtx.fillStyle = '#0a0a0f';
      astarCtx.fillRect(0, 0, astarCanvas.width, astarCanvas.height);
      
      // Draw grid and cells
      for (let y = 0; y < astarState.gridSize; y++) {
        for (let x = 0; x < astarState.gridSize; x++) {
          const cell = astarState.grid[y][x];
          
          // Cell background
          if (cell.wall) {
            astarCtx.fillStyle = '#dc2626';
          } else if (cell.path) {
            astarCtx.fillStyle = '#f59e0b';
          } else if (cell.explored) {
            astarCtx.fillStyle = '#00d9ff33';
          } else {
            astarCtx.fillStyle = '#16162a';
          }
          astarCtx.fillRect(x * cs + 1, y * cs + 1, cs - 2, cs - 2);
          
          // Grid lines
          astarCtx.strokeStyle = '#222244';
          astarCtx.strokeRect(x * cs, y * cs, cs, cs);
        }
      }
      
      // Draw start node
      astarCtx.fillStyle = '#10b981';
      astarCtx.beginPath();
      astarCtx.arc(astarState.start.x * cs + cs/2, astarState.start.y * cs + cs/2, cs/3, 0, Math.PI * 2);
      astarCtx.fill();
      
      // Draw end node
      astarCtx.fillStyle = '#ef4444';
      astarCtx.beginPath();
      astarCtx.arc(astarState.end.x * cs + cs/2, astarState.end.y * cs + cs/2, cs/3, 0, Math.PI * 2);
      astarCtx.fill();
    }

    function astarSetMode(mode) {
      astarState.mode = mode;
      document.querySelectorAll('[id^="astarMode"]').forEach(btn => btn.style.opacity = '0.6');
      document.getElementById('astarMode' + mode.charAt(0).toUpperCase() + mode.slice(1)).style.opacity = '1';
    }

    function astarClear() {
      astarState.path = [];
      astarState.explored = [];
      for (let y = 0; y < astarState.gridSize; y++) {
        for (let x = 0; x < astarState.gridSize; x++) {
          astarState.grid[y][x] = { wall: false, explored: false, path: false };
        }
      }
      document.getElementById('astarExplored').textContent = '0';
      document.getElementById('astarPathLength').textContent = '0';
      document.getElementById('astarTime').textContent = '0ms';
      drawAstar();
    }

    if (astarCanvas) {
      astarCanvas.addEventListener('mousedown', (e) => {
        astarState.isDrawing = true;
        handleAstarClick(e);
      });
      
      astarCanvas.addEventListener('mousemove', (e) => {
        if (astarState.isDrawing && astarState.mode === 'wall') {
          handleAstarClick(e);
        }
      });
      
      astarCanvas.addEventListener('mouseup', () => {
        astarState.isDrawing = false;
      });

      function handleAstarClick(e) {
        const rect = astarCanvas.getBoundingClientRect();
        // Account for canvas scaling
        const scaleX = astarCanvas.width / rect.width;
        const scaleY = astarCanvas.height / rect.height;
        const canvasX = (e.clientX - rect.left) * scaleX;
        const canvasY = (e.clientY - rect.top) * scaleY;
        const x = Math.floor(canvasX / astarState.cellSize);
        const y = Math.floor(canvasY / astarState.cellSize);
        
        if (x >= 0 && x < astarState.gridSize && y >= 0 && y < astarState.gridSize) {
          if (astarState.mode === 'start') {
            astarState.start = { x, y };
          } else if (astarState.mode === 'end') {
            astarState.end = { x, y };
          } else if (astarState.mode === 'wall') {
            astarState.grid[y][x].wall = !astarState.grid[y][x].wall;
          }
          drawAstar();
        }
      }

      initAstar();
    }

    function astarFindPath() {
      const startTime = performance.now();
      
      // Reset
      astarState.path = [];
      astarState.explored = [];
      for (let y = 0; y < astarState.gridSize; y++) {
        for (let x = 0; x < astarState.gridSize; x++) {
          astarState.grid[y][x].explored = false;
          astarState.grid[y][x].path = false;
        }
      }
      
      // A* Algorithm
      const start = astarState.start;
      const end = astarState.end;
      
      const openSet = [{ ...start, g: 0, h: heuristic(start, end), f: heuristic(start, end), parent: null }];
      const closedSet = new Set();
      
      function heuristic(a, b) {
        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); // Manhattan distance
      }
      
      function getNeighbors(node) {
        const neighbors = [];
        const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
        
        for (const [dx, dy] of dirs) {
          const x = node.x + dx;
          const y = node.y + dy;
          if (x >= 0 && x < astarState.gridSize && y >= 0 && y < astarState.gridSize) {
            if (!astarState.grid[y][x].wall) {
              neighbors.push({ x, y });
            }
          }
        }
        return neighbors;
      }
      
      while (openSet.length > 0) {
        // Find node with lowest f score
        openSet.sort((a, b) => a.f - b.f);
        const current = openSet.shift();
        
        const key = `${current.x},${current.y}`;
        if (closedSet.has(key)) continue;
        closedSet.add(key);
        
        astarState.grid[current.y][current.x].explored = true;
        
        // Found the end
        if (current.x === end.x && current.y === end.y) {
          // Reconstruct path
          let node = current;
          while (node) {
            astarState.path.push({ x: node.x, y: node.y });
            if (node.x !== start.x || node.y !== start.y) {
              astarState.grid[node.y][node.x].path = true;
            }
            node = node.parent;
          }
          break;
        }
        
        // Check neighbors
        const neighbors = getNeighbors(current);
        for (const neighbor of neighbors) {
          const neighborKey = `${neighbor.x},${neighbor.y}`;
          if (closedSet.has(neighborKey)) continue;
          
          const g = current.g + 1;
          const h = heuristic(neighbor, end);
          const f = g + h;
          
          const existingNode = openSet.find(n => n.x === neighbor.x && n.y === neighbor.y);
          if (!existingNode || g < existingNode.g) {
            if (existingNode) {
              existingNode.g = g;
              existingNode.f = f;
              existingNode.parent = current;
            } else {
              openSet.push({ ...neighbor, g, h, f, parent: current });
            }
          }
        }
      }
      
      const endTime = performance.now();
      
      document.getElementById('astarExplored').textContent = closedSet.size;
      document.getElementById('astarPathLength').textContent = astarState.path.length;
      document.getElementById('astarTime').textContent = (endTime - startTime).toFixed(2) + 'ms';
      
      drawAstar();
    }

    // ========================================
    // 2. GENETIC ALGORITHM EVOLUTION
    // ========================================
    const geneticCanvas = document.getElementById('geneticCanvas');
    const geneticCtx = geneticCanvas ? geneticCanvas.getContext('2d') : null;

    let geneticState = {
      population: [],
      generation: 0,
      populationSize: 50,
      mutationRate: 0.02,
      target: { x: 500, y: 175 },
      lifespan: 150,
      count: 0,
      running: false,
      animationId: null
    };

    class Creature {
      constructor(dna) {
        this.pos = { x: 100, y: 175 };
        this.vel = { x: 0, y: 0 };
        this.acc = { x: 0, y: 0 };
        this.dna = dna || this.randomDNA();
        this.fitness = 0;
        this.completed = false;
      }
      
      randomDNA() {
        const dna = [];
        for (let i = 0; i < geneticState.lifespan; i++) {
          const angle = Math.random() * Math.PI * 2;
          dna.push({ x: Math.cos(angle) * 0.5, y: Math.sin(angle) * 0.5 });
        }
        return dna;
      }
      
      applyForce(force) {
        this.acc.x += force.x;
        this.acc.y += force.y;
      }
      
      update(count) {
        if (this.completed) return;
        
        const force = this.dna[count];
        this.applyForce(force);
        
        this.vel.x += this.acc.x;
        this.vel.y += this.acc.y;
        this.vel.x *= 0.99;
        this.vel.y *= 0.99;
        
        this.pos.x += this.vel.x;
        this.pos.y += this.vel.y;
        
        this.acc.x = 0;
        this.acc.y = 0;
        
        // Boundaries
        if (this.pos.x < 0 || this.pos.x > geneticCanvas.width) this.completed = true;
        if (this.pos.y < 0 || this.pos.y > geneticCanvas.height) this.completed = true;
        
        // Check if reached target
        const d = Math.hypot(this.pos.x - geneticState.target.x, this.pos.y - geneticState.target.y);
        if (d < 15) this.completed = true;
      }
      
      calcFitness() {
        const d = Math.hypot(this.pos.x - geneticState.target.x, this.pos.y - geneticState.target.y);
        this.fitness = 1 / (d + 1);
        
        if (this.completed) this.fitness *= 10;
      }
      
      draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        
        const angle = Math.atan2(this.vel.y, this.vel.x);
        ctx.rotate(angle);
        
        ctx.fillStyle = this.completed ? '#10b981' : '#00d9ff';
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-8, 6);
        ctx.lineTo(-8, -6);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
    }

    function initGenetic() {
      geneticState.population = [];
      for (let i = 0; i < geneticState.populationSize; i++) {
        geneticState.population.push(new Creature());
      }
      geneticState.generation = 0;
      geneticState.count = 0;
      updateGeneticUI();
    }

    function updateGeneticUI() {
      document.getElementById('genGeneration').textContent = geneticState.generation;
      document.getElementById('genPopSize').textContent = geneticState.populationSize;
      document.getElementById('genMutationRate').textContent = (geneticState.mutationRate * 100).toFixed(0) + '%';
      
      if (geneticState.population.length > 0) {
        const bestFitness = Math.max(...geneticState.population.map(c => c.fitness));
        const avgFitness = geneticState.population.reduce((sum, c) => sum + c.fitness, 0) / geneticState.population.length;
        document.getElementById('genBestFitness').textContent = (bestFitness * 100).toFixed(0);
        document.getElementById('genAvgFitness').textContent = (avgFitness * 100).toFixed(0);
      }
    }

    function drawGenetic() {
      if (!geneticCtx) return;
      
      geneticCtx.fillStyle = '#0a0a1e';
      geneticCtx.fillRect(0, 0, geneticCanvas.width, geneticCanvas.height);
      
      // Draw target with very prominent styling
      geneticCtx.fillStyle = '#f59e0b';
      geneticCtx.shadowBlur = 30;
      geneticCtx.shadowColor = '#f59e0b';
      geneticCtx.beginPath();
      geneticCtx.arc(geneticState.target.x, geneticState.target.y, 20, 0, Math.PI * 2);
      geneticCtx.fill();
      
      // Add pulsing ring around target
      geneticCtx.strokeStyle = '#f59e0b';
      geneticCtx.lineWidth = 3;
      geneticCtx.beginPath();
      geneticCtx.arc(geneticState.target.x, geneticState.target.y, 25 + Math.sin(Date.now() / 200) * 5, 0, Math.PI * 2);
      geneticCtx.stroke();
      
      // Add star emoji
      geneticCtx.shadowBlur = 0;
      geneticCtx.font = 'bold 30px Arial';
      geneticCtx.textAlign = 'center';
      geneticCtx.textBaseline = 'middle';
      geneticCtx.fillStyle = '#fff';
      geneticCtx.fillText('‚≠ê', geneticState.target.x, geneticState.target.y);
      
      // Draw creatures
      geneticState.population.forEach(creature => creature.draw(geneticCtx));
    }

    function geneticLoop() {
      if (!geneticState.running) return;
      
      geneticState.count++;
      
      if (geneticState.count < geneticState.lifespan) {
        geneticState.population.forEach(creature => creature.update(geneticState.count));
        drawGenetic();
        geneticState.animationId = requestAnimationFrame(geneticLoop);
      } else {
        // Generation complete - evolve
        evolvePopulation();
        geneticState.count = 0;
        geneticState.animationId = requestAnimationFrame(geneticLoop);
      }
    }

    function evolvePopulation() {
      // Calculate fitness
      geneticState.population.forEach(c => c.calcFitness());
      
      // Create mating pool
      const matingPool = [];
      geneticState.population.forEach(creature => {
        const n = Math.floor(creature.fitness * 100);
        for (let i = 0; i < n; i++) {
          matingPool.push(creature);
        }
      });
      
      // Create new generation
      const newPopulation = [];
      for (let i = 0; i < geneticState.populationSize; i++) {
        const parentA = matingPool[Math.floor(Math.random() * matingPool.length)];
        const parentB = matingPool[Math.floor(Math.random() * matingPool.length)];
        
        if (parentA && parentB) {
          const childDNA = crossover(parentA.dna, parentB.dna);
          mutate(childDNA);
          newPopulation.push(new Creature(childDNA));
        } else {
          newPopulation.push(new Creature());
        }
      }
      
      geneticState.population = newPopulation;
      geneticState.generation++;
      updateGeneticUI();
    }

    function crossover(dnaA, dnaB) {
      const newDNA = [];
      const midpoint = Math.floor(Math.random() * dnaA.length);
      for (let i = 0; i < dnaA.length; i++) {
        newDNA.push(i < midpoint ? { ...dnaA[i] } : { ...dnaB[i] });
      }
      return newDNA;
    }

    function mutate(dna) {
      for (let i = 0; i < dna.length; i++) {
        if (Math.random() < geneticState.mutationRate) {
          const angle = Math.random() * Math.PI * 2;
          dna[i] = { x: Math.cos(angle) * 0.5, y: Math.sin(angle) * 0.5 };
        }
      }
    }

    function startGeneticAlgorithm() {
      if (!geneticState.running) {
        geneticState.running = true;
        document.getElementById('genStartBtn').disabled = true;
        document.getElementById('genPauseBtn').disabled = false;
        geneticLoop();
      }
    }

    function pauseGeneticAlgorithm() {
      geneticState.running = false;
      if (geneticState.animationId) {
        cancelAnimationFrame(geneticState.animationId);
      }
      document.getElementById('genStartBtn').disabled = false;
      document.getElementById('genPauseBtn').disabled = true;
    }

    function resetGeneticAlgorithm() {
      pauseGeneticAlgorithm();
      initGenetic();
      drawGenetic();
    }

    if (geneticCanvas) {
      initGenetic();
      drawGenetic();
    }

    // ========================================
    // 3. REINFORCEMENT LEARNING AGENT
    // ========================================
    const rlCanvas = document.getElementById('rlCanvas');
    const rlCtx = rlCanvas ? rlCanvas.getContext('2d') : null;

    let rlState = {
      gridSize: 10,
      cellSize: 45,
      agent: { x: 0, y: 0 },
      treasure: { x: 9, y: 9 },
      lava: [],
      qTable: {},
      epsilon: 1.0,
      epsilonDecay: 0.96,
      epsilonMin: 0.01,
      alpha: 0.3,
      gamma: 0.95,
      episode: 0,
      totalReward: 0,
      steps: 0,
      successes: 0,
      totalEpisodes: 0,
      running: false,
      animationId: null
    };

    function initRL() {
      rlState.gridSize = 10;
      rlState.cellSize = rlCanvas.width / rlState.gridSize;
      rlState.agent = { x: 0, y: 0 };
      rlState.treasure = { x: 9, y: 9 };
      rlState.lava = [];
      
      // Generate random lava positions (reduced from 15 to 10)
      for (let i = 0; i < 10; i++) {
        const x = Math.floor(Math.random() * rlState.gridSize);
        const y = Math.floor(Math.random() * rlState.gridSize);
        if ((x !== 0 || y !== 0) && (x !== 9 || y !== 9)) {
          rlState.lava.push({ x, y });
        }
      }
      
      rlState.qTable = {};
      rlState.epsilon = 1.0;
      rlState.episode = 0;
      rlState.successes = 0;
      rlState.totalEpisodes = 0;
      
      updateRLUI();
      drawRL();
    }

    function getState() {
      return `${rlState.agent.x},${rlState.agent.y}`;
    }

    function getQValue(state, action) {
      if (!rlState.qTable[state]) {
        rlState.qTable[state] = { up: 0, down: 0, left: 0, right: 0 };
      }
      return rlState.qTable[state][action];
    }

    function setQValue(state, action, value) {
      if (!rlState.qTable[state]) {
        rlState.qTable[state] = { up: 0, down: 0, left: 0, right: 0 };
      }
      rlState.qTable[state][action] = value;
    }

    function chooseAction() {
      if (Math.random() < rlState.epsilon) {
        // Explore
        const actions = ['up', 'down', 'left', 'right'];
        return actions[Math.floor(Math.random() * actions.length)];
      } else {
        // Exploit
        const state = getState();
        const actions = ['up', 'down', 'left', 'right'];
        let bestAction = actions[0];
        let bestValue = getQValue(state, bestAction);
        
        for (const action of actions) {
          const value = getQValue(state, action);
          if (value > bestValue) {
            bestValue = value;
            bestAction = action;
          }
        }
        return bestAction;
      }
    }

    function takeAction(action) {
      const newPos = { ...rlState.agent };
      
      if (action === 'up') newPos.y = Math.max(0, newPos.y - 1);
      else if (action === 'down') newPos.y = Math.min(rlState.gridSize - 1, newPos.y + 1);
      else if (action === 'left') newPos.x = Math.max(0, newPos.x - 1);
      else if (action === 'right') newPos.x = Math.min(rlState.gridSize - 1, newPos.x + 1);
      
      rlState.agent = newPos;
      rlState.steps++;
      
      // Calculate reward
      let reward = -1; // Small penalty for each step
      let done = false;
      
      if (rlState.agent.x === rlState.treasure.x && rlState.agent.y === rlState.treasure.y) {
        reward = 100;
        done = true;
        rlState.successes++;
      } else if (rlState.lava.some(l => l.x === rlState.agent.x && l.y === rlState.agent.y)) {
        reward = -100;
        done = true;
      } else if (rlState.steps > 100) {
        done = true;
      }
      
      rlState.totalReward += reward;
      
      return { reward, done };
    }

    function updateRLUI() {
      document.getElementById('rlEpisode').textContent = rlState.episode;
      document.getElementById('rlReward').textContent = rlState.totalReward;
      document.getElementById('rlSteps').textContent = rlState.steps;
      document.getElementById('rlEpsilon').textContent = Math.round(rlState.epsilon * 100) + '%';
      document.getElementById('rlSuccess').textContent = rlState.totalEpisodes > 0 ? 
        Math.round((rlState.successes / rlState.totalEpisodes) * 100) + '%' : '0%';
    }

    function drawRL() {
      if (!rlCtx) return;
      
      const cs = rlState.cellSize;
      
      rlCtx.fillStyle = '#0a0a0f';
      rlCtx.fillRect(0, 0, rlCanvas.width, rlCanvas.height);
      
      // Draw grid
      rlCtx.strokeStyle = '#222244';
      for (let x = 0; x <= rlState.gridSize; x++) {
        rlCtx.beginPath();
        rlCtx.moveTo(x * cs, 0);
        rlCtx.lineTo(x * cs, rlCanvas.height);
        rlCtx.stroke();
      }
      for (let y = 0; y <= rlState.gridSize; y++) {
        rlCtx.beginPath();
        rlCtx.moveTo(0, y * cs);
        rlCtx.lineTo(rlCanvas.width, y * cs);
        rlCtx.stroke();
      }
      
      // Draw lava
      rlState.lava.forEach(lava => {
        rlCtx.fillStyle = '#ef4444';
        rlCtx.fillRect(lava.x * cs + 2, lava.y * cs + 2, cs - 4, cs - 4);
        rlCtx.font = '30px Arial';
        rlCtx.textAlign = 'center';
        rlCtx.textBaseline = 'middle';
        rlCtx.fillText('üî•', lava.x * cs + cs/2, lava.y * cs + cs/2);
      });
      
      // Draw treasure
      rlCtx.fillStyle = '#f59e0b';
      rlCtx.fillRect(rlState.treasure.x * cs + 2, rlState.treasure.y * cs + 2, cs - 4, cs - 4);
      rlCtx.font = '30px Arial';
      rlCtx.fillText('üíé', rlState.treasure.x * cs + cs/2, rlState.treasure.y * cs + cs/2);
      
      // Draw agent
      rlCtx.fillStyle = '#00d9ff';
      rlCtx.fillRect(rlState.agent.x * cs + 2, rlState.agent.y * cs + 2, cs - 4, cs - 4);
      rlCtx.font = '30px Arial';
      rlCtx.fillText('ü§ñ', rlState.agent.x * cs + cs/2, rlState.agent.y * cs + cs/2);
    }

    async function rlEpisode() {
      rlState.agent = { x: 0, y: 0 };
      rlState.steps = 0;
      rlState.totalReward = 0;
      
      while (rlState.running) {
        const state = getState();
        const action = chooseAction();
        const { reward, done } = takeAction(action);
        const newState = getState();
        
        // Q-learning update
        const oldQ = getQValue(state, action);
        const maxNextQ = Math.max(
          getQValue(newState, 'up'),
          getQValue(newState, 'down'),
          getQValue(newState, 'left'),
          getQValue(newState, 'right')
        );
        const newQ = oldQ + rlState.alpha * (reward + rlState.gamma * maxNextQ - oldQ);
        setQValue(state, action, newQ);
        
        drawRL();
        updateRLUI();
        
        await new Promise(resolve => setTimeout(resolve, 10));
        
        if (done) {
          rlState.episode++;
          rlState.totalEpisodes++;
          rlState.epsilon = Math.max(rlState.epsilonMin, rlState.epsilon * rlState.epsilonDecay);
          updateRLUI();
          break;
        }
      }
      
      if (rlState.running) {
        rlState.animationId = requestAnimationFrame(() => rlEpisode());
      }
    }

    function startRLTraining() {
      if (!rlState.running) {
        rlState.running = true;
        document.getElementById('rlStartBtn').disabled = true;
        document.getElementById('rlStopBtn').disabled = false;
        rlEpisode();
      }
    }

    function stopRLTraining() {
      rlState.running = false;
      if (rlState.animationId) {
        cancelAnimationFrame(rlState.animationId);
      }
      document.getElementById('rlStartBtn').disabled = false;
      document.getElementById('rlStopBtn').disabled = true;
    }

    function resetRLAgent() {
      stopRLTraining();
      initRL();
    }

    if (rlCanvas) {
      initRL();
    }

    // ========================================
    // MULTI-LANGUAGE CODE COMPILER & EXECUTOR
    // ========================================
    const codeEditor = document.getElementById('codeEditor');
    let currentLanguage = 'javascript';
    
    const codeTemplates = {
      javascript: `// Fibonacci sequence
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

for (let i = 0; i < 10; i++) {
  console.log(\`Fib(\${i}) = \${fibonacci(i)}\`);
}`,
      python: `# Python Sorting Example
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

numbers = [64, 34, 25, 12, 22, 11, 90]
print("Sorted:", bubble_sort(numbers))`,
      html: `<!DOCTYPE html>
<html>
<head>
  <style>
    body { 
      font-family: Arial; 
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 20px;
    }
    .card {
      background: rgba(255,255,255,0.1);
      border-radius: 15px;
      padding: 30px;
      backdrop-filter: blur(10px);
    }
    button {
      background: #10b981;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>üé® Beautiful HTML Preview</h1>
    <p>This is a live HTML preview with CSS!</p>
    <button onclick="alert('Hello from code editor!')">Click Me!</button>
  </div>
</body>
</html>`,
      sql: `-- SQL Query Example
SELECT 
  users.name, 
  COUNT(orders.id) as order_count,
  SUM(orders.amount) as total_spent
FROM users
LEFT JOIN orders ON users.id = orders.user_id
WHERE orders.created_at >= '2024-01-01'
GROUP BY users.name
HAVING COUNT(orders.id) > 5
ORDER BY total_spent DESC
LIMIT 10;`,
      json: `{
  "name": "Code Compiler Demo",
  "version": "1.0.0",
  "features": [
    "Multi-language support",
    "Real-time execution",
    "Syntax validation",
    "Code formatting"
  ],
  "author": {
    "name": "Portfolio Showcase",
    "role": "Full Stack Developer"
  },
  "stats": {
    "languages": 5,
    "linesOfCode": 500,
    "impressive": true
  }
}`
    };
    
    function setCodeLanguage(lang) {
      // Save current code
      if (codeEditor) {
        localStorage.setItem(`code_${currentLanguage}`, codeEditor.value);
      }
      
      currentLanguage = lang;
      document.getElementById('currentLang').textContent = lang.toUpperCase();
      
      // Update button styles
      ['langJS', 'langPY', 'langHTML', 'langSQL', 'langJSON'].forEach(id => {
        document.getElementById(id).style.opacity = '0.6';
      });
      const btnMap = { javascript: 'langJS', python: 'langPY', html: 'langHTML', sql: 'langSQL', json: 'langJSON' };
      document.getElementById(btnMap[lang]).style.opacity = '1';
      
      // Load saved code or template
      const savedCode = localStorage.getItem(`code_${lang}`);
      if (codeEditor) {
        codeEditor.value = savedCode || codeTemplates[lang];
        updateCodeStats();
      }
      
      // Hide/show HTML preview
      document.getElementById('htmlPreview').style.display = lang === 'html' ? 'block' : 'none';
    }
    
    function updateCodeStats() {
      if (!codeEditor) return;
      const code = codeEditor.value;
      document.getElementById('codeLines').textContent = code.split('\n').length;
      document.getElementById('codeChars').textContent = code.length;
    }
    
    function runCode() {
      if (!codeEditor) return;
      const code = codeEditor.value;
      const outputDiv = document.getElementById('codeOutput');
      const outputContent = document.getElementById('outputContent');
      
      outputDiv.style.display = 'block';
      
      if (currentLanguage === 'javascript') {
        // Capture console.log
        const logs = [];
        const originalLog = console.log;
        console.log = (...args) => {
          logs.push(args.map(a => JSON.stringify(a)).join(' '));
          originalLog(...args);
        };
        
        try {
          eval(code);
          outputContent.textContent = logs.length > 0 ? logs.join('\n') : '‚úÖ Code executed successfully (no output)';
          outputContent.style.color = '#10b981';
        } catch (error) {
          outputContent.textContent = `‚ùå Error: ${error.message}\n${error.stack}`;
          outputContent.style.color = '#ef4444';
        } finally {
          console.log = originalLog;
        }
      } else if (currentLanguage === 'html') {
        const iframe = document.getElementById('htmlFrame');
        iframe.srcdoc = code;
        outputContent.textContent = '‚úÖ HTML rendered in preview above!';
        outputContent.style.color = '#10b981';
      } else if (currentLanguage === 'json') {
        try {
          const parsed = JSON.parse(code);
          outputContent.textContent = '‚úÖ Valid JSON!\n' + JSON.stringify(parsed, null, 2);
          outputContent.style.color = '#10b981';
        } catch (error) {
          outputContent.textContent = `‚ùå Invalid JSON: ${error.message}`;
          outputContent.style.color = '#ef4444';
        }
      } else {
        outputContent.textContent = `‚ÑπÔ∏è ${currentLanguage.toUpperCase()} execution requires a backend server.\nThis demo validates syntax only.`;
        outputContent.style.color = '#f59e0b';
        validateCode();
      }
    }
    
    function validateCode() {
      if (!codeEditor) return;
      const code = codeEditor.value;
      const outputDiv = document.getElementById('codeOutput');
      const outputContent = document.getElementById('outputContent');
      
      outputDiv.style.display = 'block';
      
      if (currentLanguage === 'javascript') {
        try {
          new Function(code);
          outputContent.textContent = '‚úÖ JavaScript syntax is valid!';
          outputContent.style.color = '#10b981';
        } catch (error) {
          outputContent.textContent = `‚ùå Syntax Error: ${error.message}`;
          outputContent.style.color = '#ef4444';
        }
      } else if (currentLanguage === 'json') {
        try {
          JSON.parse(code);
          outputContent.textContent = '‚úÖ Valid JSON structure!';
          outputContent.style.color = '#10b981';
        } catch (error) {
          outputContent.textContent = `‚ùå Invalid JSON: ${error.message}`;
          outputContent.style.color = '#ef4444';
        }
      } else {
        const lineCount = code.split('\n').length;
        const hasKeywords = currentLanguage === 'python' ? 
          /def |class |import |for |while |if /.test(code) :
          /SELECT|FROM|WHERE|JOIN|CREATE|INSERT|UPDATE|DELETE/.test(code.toUpperCase());
        
        if (code.trim().length === 0) {
          outputContent.textContent = '‚ö†Ô∏è Editor is empty';
          outputContent.style.color = '#f59e0b';
        } else if (hasKeywords) {
          outputContent.textContent = `‚úÖ ${currentLanguage.toUpperCase()} code looks valid!\nLines: ${lineCount}\nNote: Full execution requires appropriate runtime`;
          outputContent.style.color = '#10b981';
        } else {
          outputContent.textContent = `‚ö†Ô∏è Code might be missing ${currentLanguage} keywords`;
          outputContent.style.color = '#f59e0b';
        }
      }
    }
    
    function formatCode() {
      if (!codeEditor) return;
      const code = codeEditor.value;
      const outputDiv = document.getElementById('codeOutput');
      const outputContent = document.getElementById('outputContent');
      
      if (currentLanguage === 'json') {
        try {
          const parsed = JSON.parse(code);
          codeEditor.value = JSON.stringify(parsed, null, 2);
          outputContent.textContent = '‚ú® JSON formatted successfully!';
          outputContent.style.color = '#10b981';
          outputDiv.style.display = 'block';
          updateCodeStats();
        } catch (error) {
          outputContent.textContent = `‚ùå Cannot format invalid JSON: ${error.message}`;
          outputContent.style.color = '#ef4444';
          outputDiv.style.display = 'block';
        }
      } else {
        outputContent.textContent = `‚ÑπÔ∏è Auto-formatting for ${currentLanguage} requires external formatter libraries`;
        outputContent.style.color = '#f59e0b';
        outputDiv.style.display = 'block';
      }
    }
    
    function clearCode() {
      if (codeEditor) {
        codeEditor.value = '';
        updateCodeStats();
        document.getElementById('codeOutput').style.display = 'none';
        document.getElementById('htmlPreview').style.display = 'none';
      }
    }
    
    function loadTemplate() {
      if (codeEditor) {
        codeEditor.value = codeTemplates[currentLanguage];
        updateCodeStats();
        const outputDiv = document.getElementById('codeOutput');
        const outputContent = document.getElementById('outputContent');
        outputContent.textContent = `‚úÖ ${currentLanguage.toUpperCase()} template loaded!`;
        outputContent.style.color = '#10b981';
        outputDiv.style.display = 'block';
      }
    }
    
    // Initialize code editor
    if (codeEditor) {
      codeEditor.addEventListener('input', () => {
        updateCodeStats();
        localStorage.setItem(`code_${currentLanguage}`, codeEditor.value);
      });
      
      // Load saved code or default template
      const savedCode = localStorage.getItem('code_javascript');
      codeEditor.value = savedCode || codeTemplates.javascript;
      updateCodeStats();
    }
  </script>

  <!-- FOOTER -->
  <footer>
    <div class="footer-container">
      <div class="footer-grid">
        <!-- About Column -->
        <div class="footer-column">
          <h3 class="footer-heading">Nick Holmes</h3>
          <p class="footer-desc">Full Stack Developer & AI Engineer passionate about creating innovative solutions that make a difference.</p>
          <div class="footer-social">
            <a href="https://www.linkedin.com/in/nick-holmes-90264a217/" target="_blank" class="social-icon linkedin" aria-label="LinkedIn">
              <i class="fab fa-linkedin"></i>
            </a>
            <a href="https://github.com/NickHolmes999" target="_blank" class="social-icon github" aria-label="GitHub">
              <i class="fab fa-github"></i>
            </a>
            <div class="footer-social-split">
              <div class="social-icon email split-btn" onclick="toggleFooterSplit(this, 'email')" aria-label="Email">
                <i class="fas fa-envelope main-icon"></i>
              </div>
              <div class="footer-split-options">
                <a href="mailto:NickHolmes2003@gmail.com" class="footer-split-option send-btn">
                  <i class="fas fa-paper-plane"></i>
                  <span>Send</span>
                </a>
                <div class="footer-split-option copy-btn" onclick="copyFooterContact('NickHolmes2003@gmail.com', event)">
                  <i class="fas fa-copy"></i>
                  <span>Copy</span>
                </div>
              </div>
            </div>
            <div class="footer-social-split">
              <div class="social-icon phone split-btn" onclick="toggleFooterSplit(this, 'phone')" aria-label="Phone">
                <i class="fas fa-phone main-icon"></i>
              </div>
              <div class="footer-split-options">
                <a href="tel:+13015005152" class="footer-split-option call-btn">
                  <i class="fas fa-phone-alt"></i>
                  <span>Call</span>
                </a>
                <div class="footer-split-option copy-btn" onclick="copyFooterContact('(301) 500-5152', event)">
                  <i class="fas fa-copy"></i>
                  <span>Copy</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Quick Links -->
        <div class="footer-column">
          <h3 class="footer-heading">Quick Links</h3>
          <ul class="footer-links">
            <li><a href="../index.html"><i class="fas fa-home"></i> Home</a></li>
            <li><a href="about.html"><i class="fas fa-user"></i> About</a></li>
            <li><a href="projects.html"><i class="fas fa-project-diagram"></i> Projects</a></li>
            <li><a href="blog.html"><i class="fas fa-blog"></i> Blog</a></li>
            <li><a href="contact.html"><i class="fas fa-envelope"></i> Contact</a></li>
          </ul>
        </div>
        
        <!-- Services -->
        <div class="footer-column">
          <h3 class="footer-heading">Services</h3>
          <ul class="footer-links">
            <li><a href="interactive-showcase.html"><i class="fas fa-flask"></i> Interactive Demos</a></li>
            <li><a href="certificates.html"><i class="fas fa-certificate"></i> Certifications</a></li>
            <li><a href="services-faq.html"><i class="fas fa-question-circle"></i> FAQ</a></li>
            <li><a href="performance-metrics.html"><i class="fas fa-chart-line"></i> Performance</a></li>
          </ul>
        </div>
        
        <!-- Newsletter -->
        <div class="footer-column">
          <h3 class="footer-heading">Stay Updated</h3>
          <p class="footer-desc">Subscribe to get updates on new projects and articles.</p>
          <form class="newsletter-form" onsubmit="handleNewsletter(event)">
            <div class="newsletter-input-group">
              <input type="email" placeholder="Your email address" required>
              <button type="submit">
                <i class="fas fa-paper-plane"></i>
              </button>
            </div>
          </form>
          <p class="newsletter-note">üîí No spam, unsubscribe anytime</p>
        </div>
      </div>
      
      <!-- Footer Bottom -->
      <div class="footer-bottom">
        <p class="footer-copyright">
          ¬© 2025 <span class="gradient-text">Nick Holmes</span> - All rights reserved
        </p>
        <p class="footer-tech">
          <i class="fas fa-code"></i> Built with HTML, CSS, JavaScript & Python
        </p>
      </div>
    </div>
  </footer>

  <script>
    // Newsletter handler
    function handleNewsletter(event) {
      event.preventDefault();
      const email = event.target.querySelector('input[type="email"]').value;
      
      // Create success notification
      const notification = document.createElement('div');
      notification.className = 'newsletter-notification';
      notification.innerHTML = '<i class="fas fa-check-circle"></i> Thanks for subscribing!';
      notification.style.cssText = 'position: fixed; bottom: 30px; right: 30px; background: linear-gradient(135deg, var(--success-color), var(--primary-color)); color: white; padding: 20px 30px; border-radius: 12px; font-weight: bold; z-index: 10000; animation: slideInRight 0.5s ease;';
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'slideOutRight 0.5s ease';
        setTimeout(() => notification.remove(), 500);
      }, 3000);
      
      event.target.reset();
      console.log('Newsletter subscription:', email);
    }

    function toggleFooterSplit(button, type) {
      document.querySelectorAll('.split-btn.split-active').forEach(btn => {
        if (btn !== button) btn.classList.remove('split-active');
      });
      button.classList.toggle('split-active');
      if (button.classList.contains('split-active')) {
        setTimeout(() => {
          document.addEventListener('click', function closeOnOutside(e) {
            if (!e.target.closest('.footer-social-split')) {
              document.querySelectorAll('.split-btn.split-active').forEach(btn => btn.classList.remove('split-active'));
              document.removeEventListener('click', closeOnOutside);
            }
          });
        }, 100);
      }
    }

    function copyFooterContact(text, event) {
      event.stopPropagation();
      navigator.clipboard.writeText(text).then(() => {
        const notification = document.createElement('div');
        notification.className = 'footer-copy-notification';
        notification.innerHTML = `<i class="fas fa-check-circle"></i><span>Copied: ${text}</span>`;
        document.body.appendChild(notification);
        setTimeout(() => {
          notification.style.animation = 'slideOutRight 0.5s ease';
          setTimeout(() => notification.remove(), 500);
        }, 2500);
        document.querySelectorAll('.split-btn.split-active').forEach(btn => btn.classList.remove('split-active'));
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy to clipboard');
      });
    }
  </script>
  
  <!-- Back to Top Button -->
  <script src="../js/back-to-top.js"></script>

</body>
</html>
